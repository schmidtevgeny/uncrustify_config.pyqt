from PyQt5 import QtWidgets, QtGui, QtCore

import textwrap
import re
import html
import platform

import iuliia, markdown

def label(s):
        return markdown.markdown(s)
    
class Widget(QtWidgets.QTabWidget):
    # сворачивание вывода в config
    def wrap(self, s):
        if s == "\n": return "\n#"
        my_wrap = textwrap.TextWrapper(width=80)
        so = ""
        for si in s.split("\n"):
            if self.comment_type==0:
                si = si.replace('↑', '\x18').replace('↓', '\x19').replace('·', '\x0f').replace('¶', '\x14').replace('←','\x17').replace('⟼', '\t') 
                
                wrap_list = my_wrap.wrap(text=iuliia.translate(html.unescape(si), iuliia.MOSMETRO))
            else:
                wrap_list = my_wrap.wrap(html.unescape(si))
            for line in wrap_list:
                so += "\n# " + line
        return so
    def no_tr(self, s, s2=''):
        return s

    def __init__(self, parent=None):
        super(Widget, self).__init__(parent)
        self.setWindowTitle('Uncrustify-0.77.1')    
        font_name = QtGui.QFont('Arial', 14, 2)
        font_code = QtGui.QFont('monospace', 14, 2)
        self.comment_type=0        

        #================== help page ======================================
        self.help_page = QtWidgets.QWidget()
        self.help_page_layout = QtWidgets.QGridLayout(self.help_page)
        self.label_help_page_label = QtWidgets.QLabel(label(""+self.tr("Uncrustify")+"\n\n"+self.tr("Code Overview")+"\n\n"+self.tr("Step 1: Tokenize")+"\n\n"+self.tr("The entire source file is read into a buffer and then it is parsed into what I call 'chunks'.  These are the smallest lexical elements that form keywords, numbers, strings, identifiers, or punctuators.  The type of the chunk or token is as descriptive as needed and may depend on the language.")+"\n\n"+self.tr("The following information is gathered on each chunk:\n    • The token type (see src/c_token_enum.h for a complete list)\n    • The original line and column\n    • The length (character count) of the chunk\n    • The substring\n    • Whether the token was right after a tab\n    • The number of newlines in the string (mainly for the newline type)\n    • Flags (ie found in a preprocessor)")+"\n\n"+self.tr("The chunk entry has other fields that get populated later.\n    • The parent token type\n    • Flags (see cparse_types.h for a complete list)\n    • Output column\n    • Brace Level (depth of open braces '{')\n    • Level (depth of braces, parenthesis, and square brackets)")+"\n\n"+self.tr("Step 2: Tokenize Cleanup")+"\n\n"+self.tr("This step changes the type of certain chunks to a simpler type is the more complex type is not needed.")+"\n\n"+self.tr("This step checks the token after the version token and changes the type of the version chunk appropriately.")+"\n\n"+self.tr("Another example is the “[“ token followed by “]”.  This gets merged into a single chunk “[]”.")+"\n\n"+self.tr("Step 3: Brace Cleanup")+"\n\n"+self.tr("This is probably the most complicated step in the entire program.")+"\n\n"+self.tr("It figures out the brace level/depth of each token and inserts virtual braces around unbraced statements.")+"\n\n"+self.tr("This step also handles the ugliness of the #ifdef preprocessors in C, C++, and C#.")+"\n\n"+self.tr("To do this, the concept of a parse frame is introduced. I won't get into details here, but the idea is that the parse frame can be pushed onto a stack when it hits #if / #else / #endif preprocessors.")+"\n\n"+self.tr("A big unresolved problem is what to do when you have unbalanced #if / #else groups.")+"\n\n"+self.tr("Another big item here is marking expression and statement starts and setting the parent of parenthesis and braces.")+"\n\n"+self.tr("Step 4: Chunk Identification")+"\n\n"+self.tr("Once the brace stuff is all figured out, we can do some hard-core pattern matching to further identify each chunk.")+"\n\n"+self.tr("Everything else is marked in this step, such as:\n    • Variable definitions\n    • Function calls, prototypes, implementations\n    • Words are marked as types\n    • Operators like *, -, +, --, and ++ are classified\n    • Casts are identified\n    • The purpose of each colon (label, case, class, ?:, etc) is identified")+"\n\n"+self.tr("After all that is taken care of, we are ready to do useful work.")+"\n\n"+self.tr("Step 5: Brace to Virtual Brace conversion")+"\n\n"+self.tr("This step converts virtual braces into real braces or, optionally, converts real braces into virtual braces.  Obviously, this is only done on single-statement statements.")+"\n\n"+self.tr("Because of the macro abuse that C-like language allow, this can be dangerous and break your code.")+"\n\n"+self.tr("Step 6: Inter-chunk Spacing")+"\n\n"+self.tr("This step is really simple. It just goes through the list of chunks and looks at them two at a time.  It determines whether to ignore, add or remove spaces between the chunks.")+"\n\n"+self.tr("Step 7: Newlines ")+"\n\n"+self.tr("This step inserts and/or removes newlines in key areas.")+"\n\n"+self.tr("It does things like change brace styles, insert gaps between statements, etc.")+"\n\n"+self.tr("Step 8: Indenting")+"\n\n"+self.tr("This does the obvious indenting stuff.")+"\n\n"+self.tr("Indenting is done by changing the output column of the chunk.")+"\n\n"+self.tr("It is important to note that this ONLY shifts the entire line left or right.")+"\n\n"+self.tr("This step is revisited again near the end.")+"\n\n"+self.tr("Step 9: Aligning")+"\n\n"+self.tr("This does all the aligning stuff.\n    • enums on equal signs\n    • structure definitions (including bit fields)\n    • regular assignments\n    • variable definitions \n    • back-slash newline combos\n    • #define values\n    • trailing comments\n    • etc")+"\n\n"+self.tr("Step 10: Rendering")+"\n\n"+self.tr("The rendering step outputs the chunks to a stream.")+"\n\n"+self.tr("This is rather simple, as the column of each chunk has already been figured out.")+"\n\n"+self.tr("The only bit of complication is that multi-line comments are formatted in this step.")))
        self.label_help_page_label.setWordWrap(True)
        self.help_page_layout.addWidget(self.label_help_page_label, 0, 0, 1, 2)
        self.help_page_layout.addItem(QtWidgets.QSpacerItem(10, 10, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding), 1,0)
        self.scroll_help_page = QtWidgets.QScrollArea()
        self.scroll_help_page.setWidget(self.help_page)
        self.scroll_help_page.setWidgetResizable(True)
        self.addTab(self.scroll_help_page, self.tr("Help page"))
        #================== General options =================================================================
        self.group_page_1 = QtWidgets.QWidget()
        self.group_page_layout_1 = QtWidgets.QGridLayout(self.group_page_1)
        self.group_page_layout_1.addWidget(QtWidgets.QLabel(label(self.tr("General options help"))), 0, 0, 1, 2)
        #--------------------------------------------
        self.label_newlines = QtWidgets.QLabel(label("<hr>"+self.tr("The type of line endings.", "newlines")))
        self.label_newlines.setWordWrap(True)
        self.group_page_layout_1.addWidget(self.label_newlines, 1, 0, 1, 2)
        self.label_option_newlines = QtWidgets.QLabel("newlines")
        self.label_option_newlines.setFont(font_name)
        self.group_page_layout_1.addWidget(self.label_option_newlines, 2, 0)
        self.option_newlines =  QtWidgets.QComboBox()
        self.option_newlines.addItems(['lf', 'crlf', 'cr', 'auto'])
        self.option_newlines.setCurrentText("auto")
        self.group_page_layout_1.addWidget(self.option_newlines, 2, 1)
        #--------------------------------------------
        self.label_input_tab_size = QtWidgets.QLabel(label("<hr>"+self.tr("The original size of tabs in the input.", "input_tab_size")))
        self.label_input_tab_size.setWordWrap(True)
        self.group_page_layout_1.addWidget(self.label_input_tab_size, 3, 0, 1, 2)
        self.label_option_input_tab_size = QtWidgets.QLabel("input_tab_size")
        self.label_option_input_tab_size.setFont(font_name)
        self.group_page_layout_1.addWidget(self.label_option_input_tab_size, 4, 0)
        self.option_input_tab_size =  QtWidgets.QSpinBox()
        self.option_input_tab_size.setMinimum( 1)
        self.option_input_tab_size.setMaximum( 32)
        self.option_input_tab_size.setValue(8)
        self.group_page_layout_1.addWidget(self.option_input_tab_size, 4, 1)
        #--------------------------------------------
        self.label_output_tab_size = QtWidgets.QLabel(label("<hr>"+self.tr("The size of tabs in the output (only used if align_with_tabs=true).", "output_tab_size")))
        self.label_output_tab_size.setWordWrap(True)
        self.group_page_layout_1.addWidget(self.label_output_tab_size, 5, 0, 1, 2)
        self.label_option_output_tab_size = QtWidgets.QLabel("output_tab_size")
        self.label_option_output_tab_size.setFont(font_name)
        self.group_page_layout_1.addWidget(self.label_option_output_tab_size, 6, 0)
        self.option_output_tab_size =  QtWidgets.QSpinBox()
        self.option_output_tab_size.setMinimum( 1)
        self.option_output_tab_size.setMaximum( 32)
        self.option_output_tab_size.setValue(8)
        self.group_page_layout_1.addWidget(self.option_output_tab_size, 6, 1)
        #--------------------------------------------
        self.label_string_escape_char = QtWidgets.QLabel(label("<hr>"+self.tr("The ASCII value of the string escape char, usually 92 (\\) or (Pawn) 94 (^).", "string_escape_char")))
        self.label_string_escape_char.setWordWrap(True)
        self.group_page_layout_1.addWidget(self.label_string_escape_char, 7, 0, 1, 2)
        self.label_option_string_escape_char = QtWidgets.QLabel("string_escape_char")
        self.label_option_string_escape_char.setFont(font_name)
        self.group_page_layout_1.addWidget(self.label_option_string_escape_char, 8, 0)
        self.option_string_escape_char =  QtWidgets.QSpinBox()
        self.option_string_escape_char.setMinimum( 0)
        self.option_string_escape_char.setMaximum( 255)
        self.option_string_escape_char.setValue(92)
        self.group_page_layout_1.addWidget(self.option_string_escape_char, 8, 1)
        #--------------------------------------------
        self.label_string_escape_char2 = QtWidgets.QLabel(label("<hr>"+self.tr("Alternate string escape char (usually only used for Pawn).\nOnly works right before the quote char.", "string_escape_char2")))
        self.label_string_escape_char2.setWordWrap(True)
        self.group_page_layout_1.addWidget(self.label_string_escape_char2, 9, 0, 1, 2)
        self.label_option_string_escape_char2 = QtWidgets.QLabel("string_escape_char2")
        self.label_option_string_escape_char2.setFont(font_name)
        self.group_page_layout_1.addWidget(self.label_option_string_escape_char2, 10, 0)
        self.option_string_escape_char2 =  QtWidgets.QSpinBox()
        self.option_string_escape_char2.setMinimum( 0)
        self.option_string_escape_char2.setMaximum( 255)
        self.option_string_escape_char2.setValue(0)
        self.group_page_layout_1.addWidget(self.option_string_escape_char2, 10, 1)
        #--------------------------------------------
        self.label_string_replace_tab_chars = QtWidgets.QLabel(label("<hr>"+self.tr("Replace tab characters found in string literals with the escape sequence \\t\ninstead.", "string_replace_tab_chars")))
        self.label_string_replace_tab_chars.setWordWrap(True)
        self.group_page_layout_1.addWidget(self.label_string_replace_tab_chars, 11, 0, 1, 2)
        self.label_option_string_replace_tab_chars = QtWidgets.QLabel("string_replace_tab_chars")
        self.label_option_string_replace_tab_chars.setFont(font_name)
        self.group_page_layout_1.addWidget(self.label_option_string_replace_tab_chars, 12, 0)
        self.option_string_replace_tab_chars =  QtWidgets.QComboBox()
        self.option_string_replace_tab_chars.addItems(['true','false'])
        self.option_string_replace_tab_chars.setCurrentText("false")
        self.group_page_layout_1.addWidget(self.option_string_replace_tab_chars, 12, 1)
        #--------------------------------------------
        self.label_tok_split_gte = QtWidgets.QLabel(label("<hr>"+self.tr("Allow interpreting '>=' and '>>=' as part of a template in code like\n'void f(list<list<B>>=val);'. If true, 'assert(x<0 && y>=3)' will be broken.\nImprovements to template detection may make this option obsolete.", "tok_split_gte")))
        self.label_tok_split_gte.setWordWrap(True)
        self.group_page_layout_1.addWidget(self.label_tok_split_gte, 13, 0, 1, 2)
        self.label_option_tok_split_gte = QtWidgets.QLabel("tok_split_gte")
        self.label_option_tok_split_gte.setFont(font_name)
        self.group_page_layout_1.addWidget(self.label_option_tok_split_gte, 14, 0)
        self.option_tok_split_gte =  QtWidgets.QComboBox()
        self.option_tok_split_gte.addItems(['true','false'])
        self.option_tok_split_gte.setCurrentText("false")
        self.group_page_layout_1.addWidget(self.option_tok_split_gte, 14, 1)
        #--------------------------------------------
        self.label_disable_processing_nl_cont = QtWidgets.QLabel(label("<hr>"+self.tr("Disable formatting of NL_CONT ('\\\\n') ended lines (e.g. multi-line macros).", "disable_processing_nl_cont")))
        self.label_disable_processing_nl_cont.setWordWrap(True)
        self.group_page_layout_1.addWidget(self.label_disable_processing_nl_cont, 15, 0, 1, 2)
        self.label_option_disable_processing_nl_cont = QtWidgets.QLabel("disable_processing_nl_cont")
        self.label_option_disable_processing_nl_cont.setFont(font_name)
        self.group_page_layout_1.addWidget(self.label_option_disable_processing_nl_cont, 16, 0)
        self.option_disable_processing_nl_cont =  QtWidgets.QComboBox()
        self.option_disable_processing_nl_cont.addItems(['true','false'])
        self.option_disable_processing_nl_cont.setCurrentText("false")
        self.group_page_layout_1.addWidget(self.option_disable_processing_nl_cont, 16, 1)
        #--------------------------------------------
        self.label_disable_processing_cmt = QtWidgets.QLabel(label("<hr>"+self.tr("Specify the marker used in comments to disable processing of part of the\nfile.", "disable_processing_cmt")))
        self.label_disable_processing_cmt.setWordWrap(True)
        self.group_page_layout_1.addWidget(self.label_disable_processing_cmt, 17, 0, 1, 2)
        self.label_option_disable_processing_cmt = QtWidgets.QLabel("disable_processing_cmt")
        self.label_option_disable_processing_cmt.setFont(font_name)
        self.group_page_layout_1.addWidget(self.label_option_disable_processing_cmt, 18, 0)
        self.option_disable_processing_cmt =  QtWidgets.QLineEdit("UNCRUSTIFY_OFF_TEXT")
        self.group_page_layout_1.addWidget(self.option_disable_processing_cmt, 18, 1)
        #--------------------------------------------
        self.label_enable_processing_cmt = QtWidgets.QLabel(label("<hr>"+self.tr("Specify the marker used in comments to (re)enable processing in a file.", "enable_processing_cmt")))
        self.label_enable_processing_cmt.setWordWrap(True)
        self.group_page_layout_1.addWidget(self.label_enable_processing_cmt, 19, 0, 1, 2)
        self.label_option_enable_processing_cmt = QtWidgets.QLabel("enable_processing_cmt")
        self.label_option_enable_processing_cmt.setFont(font_name)
        self.group_page_layout_1.addWidget(self.label_option_enable_processing_cmt, 20, 0)
        self.option_enable_processing_cmt =  QtWidgets.QLineEdit("UNCRUSTIFY_ON_TEXT")
        self.group_page_layout_1.addWidget(self.option_enable_processing_cmt, 20, 1)
        #--------------------------------------------
        self.label_enable_digraphs = QtWidgets.QLabel(label("<hr>"+self.tr("Enable parsing of digraphs.", "enable_digraphs")))
        self.label_enable_digraphs.setWordWrap(True)
        self.group_page_layout_1.addWidget(self.label_enable_digraphs, 21, 0, 1, 2)
        self.label_option_enable_digraphs = QtWidgets.QLabel("enable_digraphs")
        self.label_option_enable_digraphs.setFont(font_name)
        self.group_page_layout_1.addWidget(self.label_option_enable_digraphs, 22, 0)
        self.option_enable_digraphs =  QtWidgets.QComboBox()
        self.option_enable_digraphs.addItems(['true','false'])
        self.option_enable_digraphs.setCurrentText("false")
        self.group_page_layout_1.addWidget(self.option_enable_digraphs, 22, 1)
        #--------------------------------------------
        self.label_processing_cmt_as_regex = QtWidgets.QLabel(label("<hr>"+self.tr("Option to allow both disable_processing_cmt and enable_processing_cmt\nstrings, if specified, to be interpreted as ECMAScript regular expressions.\nIf true, a regex search will be performed within comments according to the\nspecified patterns in order to disable/enable processing.", "processing_cmt_as_regex")))
        self.label_processing_cmt_as_regex.setWordWrap(True)
        self.group_page_layout_1.addWidget(self.label_processing_cmt_as_regex, 23, 0, 1, 2)
        self.label_option_processing_cmt_as_regex = QtWidgets.QLabel("processing_cmt_as_regex")
        self.label_option_processing_cmt_as_regex.setFont(font_name)
        self.group_page_layout_1.addWidget(self.label_option_processing_cmt_as_regex, 24, 0)
        self.option_processing_cmt_as_regex =  QtWidgets.QComboBox()
        self.option_processing_cmt_as_regex.addItems(['true','false'])
        self.option_processing_cmt_as_regex.setCurrentText("false")
        self.group_page_layout_1.addWidget(self.option_processing_cmt_as_regex, 24, 1)
        #--------------------------------------------
        self.label_utf8_bom = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove the UTF-8 BOM (recommend 'remove').", "utf8_bom")))
        self.label_utf8_bom.setWordWrap(True)
        self.group_page_layout_1.addWidget(self.label_utf8_bom, 25, 0, 1, 2)
        self.label_option_utf8_bom = QtWidgets.QLabel("utf8_bom")
        self.label_option_utf8_bom.setFont(font_name)
        self.group_page_layout_1.addWidget(self.label_option_utf8_bom, 26, 0)
        self.option_utf8_bom =  QtWidgets.QComboBox()
        self.option_utf8_bom.addItems(['ignore','add','remove','force','not_defined'])
        self.option_utf8_bom.setCurrentText("ignore")
        self.group_page_layout_1.addWidget(self.option_utf8_bom, 26, 1)
        #--------------------------------------------
        self.label_utf8_byte = QtWidgets.QLabel(label("<hr>"+self.tr("If the file contains bytes with values between 128 and 255, but is not\nUTF-8, then output as UTF-8.", "utf8_byte")))
        self.label_utf8_byte.setWordWrap(True)
        self.group_page_layout_1.addWidget(self.label_utf8_byte, 27, 0, 1, 2)
        self.label_option_utf8_byte = QtWidgets.QLabel("utf8_byte")
        self.label_option_utf8_byte.setFont(font_name)
        self.group_page_layout_1.addWidget(self.label_option_utf8_byte, 28, 0)
        self.option_utf8_byte =  QtWidgets.QComboBox()
        self.option_utf8_byte.addItems(['true','false'])
        self.option_utf8_byte.setCurrentText("false")
        self.group_page_layout_1.addWidget(self.option_utf8_byte, 28, 1)
        #--------------------------------------------
        self.label_utf8_force = QtWidgets.QLabel(label("<hr>"+self.tr("Force the output encoding to UTF-8.", "utf8_force")))
        self.label_utf8_force.setWordWrap(True)
        self.group_page_layout_1.addWidget(self.label_utf8_force, 29, 0, 1, 2)
        self.label_option_utf8_force = QtWidgets.QLabel("utf8_force")
        self.label_option_utf8_force.setFont(font_name)
        self.group_page_layout_1.addWidget(self.label_option_utf8_force, 30, 0)
        self.option_utf8_force =  QtWidgets.QComboBox()
        self.option_utf8_force.addItems(['true','false'])
        self.option_utf8_force.setCurrentText("false")
        self.group_page_layout_1.addWidget(self.option_utf8_force, 30, 1)
        self.group_page_layout_1.addItem(QtWidgets.QSpacerItem(10, 10, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding), 31,0)
        self.scroll_group_page_1 = QtWidgets.QScrollArea()
        self.scroll_group_page_1.setWidget(self.group_page_1)
        self.scroll_group_page_1.setWidgetResizable(True)
        self.addTab(self.scroll_group_page_1, self.tr("General options"))
        #================== Spacing options =================================================================
        self.group_page_2 = QtWidgets.QWidget()
        self.group_page_layout_2 = QtWidgets.QGridLayout(self.group_page_2)
        self.group_page_layout_2.addWidget(QtWidgets.QLabel(label(self.tr("Spacing options help"))), 0, 0, 1, 2)
        #--------------------------------------------
        self.label_sp_arith = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space around non-assignment symbolic operators ('+', '/', '%',\n'<<', and so forth).", "sp_arith")))
        self.label_sp_arith.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_arith, 1, 0, 1, 2)
        self.label_option_sp_arith = QtWidgets.QLabel("sp_arith")
        self.label_option_sp_arith.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_arith, 2, 0)
        self.option_sp_arith =  QtWidgets.QComboBox()
        self.option_sp_arith.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_arith.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_arith, 2, 1)
        #--------------------------------------------
        self.label_sp_arith_additive = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space around arithmetic operators '+' and '-'.", "sp_arith_additive")+"\n\n"+self.tr("Overrides sp_arith.", "sp_arith_additive")))
        self.label_sp_arith_additive.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_arith_additive, 3, 0, 1, 2)
        self.label_option_sp_arith_additive = QtWidgets.QLabel("sp_arith_additive")
        self.label_option_sp_arith_additive.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_arith_additive, 4, 0)
        self.option_sp_arith_additive =  QtWidgets.QComboBox()
        self.option_sp_arith_additive.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_arith_additive.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_arith_additive, 4, 1)
        #--------------------------------------------
        self.label_sp_assign = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space around assignment operator '=', '+=', etc.", "sp_assign")))
        self.label_sp_assign.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_assign, 5, 0, 1, 2)
        self.label_option_sp_assign = QtWidgets.QLabel("sp_assign")
        self.label_option_sp_assign.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_assign, 6, 0)
        self.option_sp_assign =  QtWidgets.QComboBox()
        self.option_sp_assign.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_assign.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_assign, 6, 1)
        #--------------------------------------------
        self.label_sp_cpp_lambda_assign = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space around '=' in C++11 lambda capture specifications.", "sp_cpp_lambda_assign")+"\n\n"+self.tr("Overrides sp_assign.", "sp_cpp_lambda_assign")))
        self.label_sp_cpp_lambda_assign.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cpp_lambda_assign, 7, 0, 1, 2)
        self.label_option_sp_cpp_lambda_assign = QtWidgets.QLabel("sp_cpp_lambda_assign")
        self.label_option_sp_cpp_lambda_assign.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cpp_lambda_assign, 8, 0)
        self.option_sp_cpp_lambda_assign =  QtWidgets.QComboBox()
        self.option_sp_cpp_lambda_assign.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_cpp_lambda_assign.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_cpp_lambda_assign, 8, 1)
        #--------------------------------------------
        self.label_sp_cpp_lambda_square_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after the capture specification of a C++11 lambda when\nan argument list is present, as in '[] <here> (int x){ ... }'.", "sp_cpp_lambda_square_paren")))
        self.label_sp_cpp_lambda_square_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cpp_lambda_square_paren, 9, 0, 1, 2)
        self.label_option_sp_cpp_lambda_square_paren = QtWidgets.QLabel("sp_cpp_lambda_square_paren")
        self.label_option_sp_cpp_lambda_square_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cpp_lambda_square_paren, 10, 0)
        self.option_sp_cpp_lambda_square_paren =  QtWidgets.QComboBox()
        self.option_sp_cpp_lambda_square_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_cpp_lambda_square_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_cpp_lambda_square_paren, 10, 1)
        #--------------------------------------------
        self.label_sp_cpp_lambda_square_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after the capture specification of a C++11 lambda with\nno argument list is present, as in '[] <here> { ... }'.", "sp_cpp_lambda_square_brace")))
        self.label_sp_cpp_lambda_square_brace.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cpp_lambda_square_brace, 11, 0, 1, 2)
        self.label_option_sp_cpp_lambda_square_brace = QtWidgets.QLabel("sp_cpp_lambda_square_brace")
        self.label_option_sp_cpp_lambda_square_brace.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cpp_lambda_square_brace, 12, 0)
        self.option_sp_cpp_lambda_square_brace =  QtWidgets.QComboBox()
        self.option_sp_cpp_lambda_square_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_cpp_lambda_square_brace.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_cpp_lambda_square_brace, 12, 1)
        #--------------------------------------------
        self.label_sp_cpp_lambda_argument_list_empty = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after the opening parenthesis and before the closing\nparenthesis of a argument list of a C++11 lambda, as in\n'[]( <here> ){ ... }'\nwith an empty list.", "sp_cpp_lambda_argument_list_empty")))
        self.label_sp_cpp_lambda_argument_list_empty.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cpp_lambda_argument_list_empty, 13, 0, 1, 2)
        self.label_option_sp_cpp_lambda_argument_list_empty = QtWidgets.QLabel("sp_cpp_lambda_argument_list_empty")
        self.label_option_sp_cpp_lambda_argument_list_empty.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cpp_lambda_argument_list_empty, 14, 0)
        self.option_sp_cpp_lambda_argument_list_empty =  QtWidgets.QComboBox()
        self.option_sp_cpp_lambda_argument_list_empty.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_cpp_lambda_argument_list_empty.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_cpp_lambda_argument_list_empty, 14, 1)
        #--------------------------------------------
        self.label_sp_cpp_lambda_argument_list = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after the opening parenthesis and before the closing\nparenthesis of a argument list of a C++11 lambda, as in\n'[]( <here> int x <here> ){ ... }'.", "sp_cpp_lambda_argument_list")))
        self.label_sp_cpp_lambda_argument_list.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cpp_lambda_argument_list, 15, 0, 1, 2)
        self.label_option_sp_cpp_lambda_argument_list = QtWidgets.QLabel("sp_cpp_lambda_argument_list")
        self.label_option_sp_cpp_lambda_argument_list.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cpp_lambda_argument_list, 16, 0)
        self.option_sp_cpp_lambda_argument_list =  QtWidgets.QComboBox()
        self.option_sp_cpp_lambda_argument_list.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_cpp_lambda_argument_list.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_cpp_lambda_argument_list, 16, 1)
        #--------------------------------------------
        self.label_sp_cpp_lambda_paren_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after the argument list of a C++11 lambda, as in\n'[](int x) <here> { ... }'.", "sp_cpp_lambda_paren_brace")))
        self.label_sp_cpp_lambda_paren_brace.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cpp_lambda_paren_brace, 17, 0, 1, 2)
        self.label_option_sp_cpp_lambda_paren_brace = QtWidgets.QLabel("sp_cpp_lambda_paren_brace")
        self.label_option_sp_cpp_lambda_paren_brace.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cpp_lambda_paren_brace, 18, 0)
        self.option_sp_cpp_lambda_paren_brace =  QtWidgets.QComboBox()
        self.option_sp_cpp_lambda_paren_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_cpp_lambda_paren_brace.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_cpp_lambda_paren_brace, 18, 1)
        #--------------------------------------------
        self.label_sp_cpp_lambda_fparen = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between a lambda body and its call operator of an\nimmediately invoked lambda, as in '[]( ... ){ ... } <here> ( ... )'.", "sp_cpp_lambda_fparen")))
        self.label_sp_cpp_lambda_fparen.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cpp_lambda_fparen, 19, 0, 1, 2)
        self.label_option_sp_cpp_lambda_fparen = QtWidgets.QLabel("sp_cpp_lambda_fparen")
        self.label_option_sp_cpp_lambda_fparen.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cpp_lambda_fparen, 20, 0)
        self.option_sp_cpp_lambda_fparen =  QtWidgets.QComboBox()
        self.option_sp_cpp_lambda_fparen.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_cpp_lambda_fparen.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_cpp_lambda_fparen, 20, 1)
        #--------------------------------------------
        self.label_sp_assign_default = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space around assignment operator '=' in a prototype.", "sp_assign_default")+"\n\n"+self.tr("If set to ignore, use sp_assign.", "sp_assign_default")))
        self.label_sp_assign_default.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_assign_default, 21, 0, 1, 2)
        self.label_option_sp_assign_default = QtWidgets.QLabel("sp_assign_default")
        self.label_option_sp_assign_default.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_assign_default, 22, 0)
        self.option_sp_assign_default =  QtWidgets.QComboBox()
        self.option_sp_assign_default.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_assign_default.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_assign_default, 22, 1)
        #--------------------------------------------
        self.label_sp_before_assign = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before assignment operator '=', '+=', etc.", "sp_before_assign")+"\n\n"+self.tr("Overrides sp_assign.", "sp_before_assign")))
        self.label_sp_before_assign.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_assign, 23, 0, 1, 2)
        self.label_option_sp_before_assign = QtWidgets.QLabel("sp_before_assign")
        self.label_option_sp_before_assign.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_assign, 24, 0)
        self.option_sp_before_assign =  QtWidgets.QComboBox()
        self.option_sp_before_assign.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_assign.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_assign, 24, 1)
        #--------------------------------------------
        self.label_sp_after_assign = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after assignment operator '=', '+=', etc.", "sp_after_assign")+"\n\n"+self.tr("Overrides sp_assign.", "sp_after_assign")))
        self.label_sp_after_assign.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_assign, 25, 0, 1, 2)
        self.label_option_sp_after_assign = QtWidgets.QLabel("sp_after_assign")
        self.label_option_sp_after_assign.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_assign, 26, 0)
        self.option_sp_after_assign =  QtWidgets.QComboBox()
        self.option_sp_after_assign.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_assign.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_assign, 26, 1)
        #--------------------------------------------
        self.label_sp_enum_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space in 'enum {'.", "sp_enum_brace")))
        self.label_sp_enum_brace.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_enum_brace, 27, 0, 1, 2)
        self.label_option_sp_enum_brace = QtWidgets.QLabel("sp_enum_brace")
        self.label_option_sp_enum_brace.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_enum_brace, 28, 0)
        self.option_sp_enum_brace =  QtWidgets.QComboBox()
        self.option_sp_enum_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_enum_brace.setCurrentText("add")
        self.group_page_layout_2.addWidget(self.option_sp_enum_brace, 28, 1)
        #--------------------------------------------
        self.label_sp_enum_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space in 'NS_ENUM ('.", "sp_enum_paren")))
        self.label_sp_enum_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_enum_paren, 29, 0, 1, 2)
        self.label_option_sp_enum_paren = QtWidgets.QLabel("sp_enum_paren")
        self.label_option_sp_enum_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_enum_paren, 30, 0)
        self.option_sp_enum_paren =  QtWidgets.QComboBox()
        self.option_sp_enum_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_enum_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_enum_paren, 30, 1)
        #--------------------------------------------
        self.label_sp_enum_assign = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space around assignment '=' in enum.", "sp_enum_assign")))
        self.label_sp_enum_assign.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_enum_assign, 31, 0, 1, 2)
        self.label_option_sp_enum_assign = QtWidgets.QLabel("sp_enum_assign")
        self.label_option_sp_enum_assign.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_enum_assign, 32, 0)
        self.option_sp_enum_assign =  QtWidgets.QComboBox()
        self.option_sp_enum_assign.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_enum_assign.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_enum_assign, 32, 1)
        #--------------------------------------------
        self.label_sp_enum_before_assign = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before assignment '=' in enum.", "sp_enum_before_assign")+"\n\n"+self.tr("Overrides sp_enum_assign.", "sp_enum_before_assign")))
        self.label_sp_enum_before_assign.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_enum_before_assign, 33, 0, 1, 2)
        self.label_option_sp_enum_before_assign = QtWidgets.QLabel("sp_enum_before_assign")
        self.label_option_sp_enum_before_assign.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_enum_before_assign, 34, 0)
        self.option_sp_enum_before_assign =  QtWidgets.QComboBox()
        self.option_sp_enum_before_assign.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_enum_before_assign.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_enum_before_assign, 34, 1)
        #--------------------------------------------
        self.label_sp_enum_after_assign = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after assignment '=' in enum.", "sp_enum_after_assign")+"\n\n"+self.tr("Overrides sp_enum_assign.", "sp_enum_after_assign")))
        self.label_sp_enum_after_assign.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_enum_after_assign, 35, 0, 1, 2)
        self.label_option_sp_enum_after_assign = QtWidgets.QLabel("sp_enum_after_assign")
        self.label_option_sp_enum_after_assign.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_enum_after_assign, 36, 0)
        self.option_sp_enum_after_assign =  QtWidgets.QComboBox()
        self.option_sp_enum_after_assign.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_enum_after_assign.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_enum_after_assign, 36, 1)
        #--------------------------------------------
        self.label_sp_enum_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space around assignment ':' in enum.", "sp_enum_colon")))
        self.label_sp_enum_colon.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_enum_colon, 37, 0, 1, 2)
        self.label_option_sp_enum_colon = QtWidgets.QLabel("sp_enum_colon")
        self.label_option_sp_enum_colon.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_enum_colon, 38, 0)
        self.option_sp_enum_colon =  QtWidgets.QComboBox()
        self.option_sp_enum_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_enum_colon.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_enum_colon, 38, 1)
        #--------------------------------------------
        self.label_sp_pp_concat = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space around preprocessor '##' concatenation operator.", "sp_pp_concat")))
        self.label_sp_pp_concat.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_pp_concat, 39, 0, 1, 2)
        self.label_option_sp_pp_concat = QtWidgets.QLabel("sp_pp_concat")
        self.label_option_sp_pp_concat.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_pp_concat, 40, 0)
        self.option_sp_pp_concat =  QtWidgets.QComboBox()
        self.option_sp_pp_concat.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_pp_concat.setCurrentText("add")
        self.group_page_layout_2.addWidget(self.option_sp_pp_concat, 40, 1)
        #--------------------------------------------
        self.label_sp_pp_stringify = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after preprocessor '#' stringify operator.\nAlso affects the '#@' charizing operator.", "sp_pp_stringify")))
        self.label_sp_pp_stringify.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_pp_stringify, 41, 0, 1, 2)
        self.label_option_sp_pp_stringify = QtWidgets.QLabel("sp_pp_stringify")
        self.label_option_sp_pp_stringify.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_pp_stringify, 42, 0)
        self.option_sp_pp_stringify =  QtWidgets.QComboBox()
        self.option_sp_pp_stringify.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_pp_stringify.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_pp_stringify, 42, 1)
        #--------------------------------------------
        self.label_sp_before_pp_stringify = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before preprocessor '#' stringify operator\nas in '#define x(y) L#y'.", "sp_before_pp_stringify")))
        self.label_sp_before_pp_stringify.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_pp_stringify, 43, 0, 1, 2)
        self.label_option_sp_before_pp_stringify = QtWidgets.QLabel("sp_before_pp_stringify")
        self.label_option_sp_before_pp_stringify.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_pp_stringify, 44, 0)
        self.option_sp_before_pp_stringify =  QtWidgets.QComboBox()
        self.option_sp_before_pp_stringify.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_pp_stringify.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_pp_stringify, 44, 1)
        #--------------------------------------------
        self.label_sp_bool = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space around boolean operators '&&' and '||'.", "sp_bool")))
        self.label_sp_bool.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_bool, 45, 0, 1, 2)
        self.label_option_sp_bool = QtWidgets.QLabel("sp_bool")
        self.label_option_sp_bool.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_bool, 46, 0)
        self.option_sp_bool =  QtWidgets.QComboBox()
        self.option_sp_bool.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_bool.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_bool, 46, 1)
        #--------------------------------------------
        self.label_sp_compare = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space around compare operator '<', '>', '==', etc.", "sp_compare")))
        self.label_sp_compare.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_compare, 47, 0, 1, 2)
        self.label_option_sp_compare = QtWidgets.QLabel("sp_compare")
        self.label_option_sp_compare.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_compare, 48, 0)
        self.option_sp_compare =  QtWidgets.QComboBox()
        self.option_sp_compare.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_compare.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_compare, 48, 1)
        #--------------------------------------------
        self.label_sp_inside_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space inside '(' and ')'.", "sp_inside_paren")))
        self.label_sp_inside_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_paren, 49, 0, 1, 2)
        self.label_option_sp_inside_paren = QtWidgets.QLabel("sp_inside_paren")
        self.label_option_sp_inside_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_paren, 50, 0)
        self.option_sp_inside_paren =  QtWidgets.QComboBox()
        self.option_sp_inside_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_paren, 50, 1)
        #--------------------------------------------
        self.label_sp_paren_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between nested parentheses, i.e. '((' vs. ') )'.", "sp_paren_paren")))
        self.label_sp_paren_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_paren_paren, 51, 0, 1, 2)
        self.label_option_sp_paren_paren = QtWidgets.QLabel("sp_paren_paren")
        self.label_option_sp_paren_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_paren_paren, 52, 0)
        self.option_sp_paren_paren =  QtWidgets.QComboBox()
        self.option_sp_paren_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_paren_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_paren_paren, 52, 1)
        #--------------------------------------------
        self.label_sp_cparen_oparen = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between back-to-back parentheses, i.e. ')(' vs. ') ('.", "sp_cparen_oparen")))
        self.label_sp_cparen_oparen.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cparen_oparen, 53, 0, 1, 2)
        self.label_option_sp_cparen_oparen = QtWidgets.QLabel("sp_cparen_oparen")
        self.label_option_sp_cparen_oparen.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cparen_oparen, 54, 0)
        self.option_sp_cparen_oparen =  QtWidgets.QComboBox()
        self.option_sp_cparen_oparen.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_cparen_oparen.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_cparen_oparen, 54, 1)
        #--------------------------------------------
        self.label_sp_paren_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between ')' and '{'.", "sp_paren_brace")))
        self.label_sp_paren_brace.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_paren_brace, 55, 0, 1, 2)
        self.label_option_sp_paren_brace = QtWidgets.QLabel("sp_paren_brace")
        self.label_option_sp_paren_brace.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_paren_brace, 56, 0)
        self.option_sp_paren_brace =  QtWidgets.QComboBox()
        self.option_sp_paren_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_paren_brace.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_paren_brace, 56, 1)
        #--------------------------------------------
        self.label_sp_brace_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between nested braces, i.e. '{{' vs. '{ {'.", "sp_brace_brace")))
        self.label_sp_brace_brace.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_brace_brace, 57, 0, 1, 2)
        self.label_option_sp_brace_brace = QtWidgets.QLabel("sp_brace_brace")
        self.label_option_sp_brace_brace.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_brace_brace, 58, 0)
        self.option_sp_brace_brace =  QtWidgets.QComboBox()
        self.option_sp_brace_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_brace_brace.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_brace_brace, 58, 1)
        #--------------------------------------------
        self.label_sp_before_ptr_star = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before pointer star '*'.", "sp_before_ptr_star")))
        self.label_sp_before_ptr_star.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_ptr_star, 59, 0, 1, 2)
        self.label_option_sp_before_ptr_star = QtWidgets.QLabel("sp_before_ptr_star")
        self.label_option_sp_before_ptr_star.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_ptr_star, 60, 0)
        self.option_sp_before_ptr_star =  QtWidgets.QComboBox()
        self.option_sp_before_ptr_star.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_ptr_star.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_ptr_star, 60, 1)
        #--------------------------------------------
        self.label_sp_before_unnamed_ptr_star = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before pointer star '*' that isn't followed by a\nvariable name. If set to ignore, sp_before_ptr_star is used instead.", "sp_before_unnamed_ptr_star")))
        self.label_sp_before_unnamed_ptr_star.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_unnamed_ptr_star, 61, 0, 1, 2)
        self.label_option_sp_before_unnamed_ptr_star = QtWidgets.QLabel("sp_before_unnamed_ptr_star")
        self.label_option_sp_before_unnamed_ptr_star.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_unnamed_ptr_star, 62, 0)
        self.option_sp_before_unnamed_ptr_star =  QtWidgets.QComboBox()
        self.option_sp_before_unnamed_ptr_star.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_unnamed_ptr_star.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_unnamed_ptr_star, 62, 1)
        #--------------------------------------------
        self.label_sp_before_qualifier_ptr_star = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before pointer star '*' that is followed by a qualifier.\nIf set to ignore, sp_before_unnamed_ptr_star is used instead.", "sp_before_qualifier_ptr_star")))
        self.label_sp_before_qualifier_ptr_star.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_qualifier_ptr_star, 63, 0, 1, 2)
        self.label_option_sp_before_qualifier_ptr_star = QtWidgets.QLabel("sp_before_qualifier_ptr_star")
        self.label_option_sp_before_qualifier_ptr_star.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_qualifier_ptr_star, 64, 0)
        self.option_sp_before_qualifier_ptr_star =  QtWidgets.QComboBox()
        self.option_sp_before_qualifier_ptr_star.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_qualifier_ptr_star.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_qualifier_ptr_star, 64, 1)
        #--------------------------------------------
        self.label_sp_before_operator_ptr_star = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before pointer star '*' that is followed by 'operator' keyword.\nIf set to ignore, sp_before_unnamed_ptr_star is used instead.", "sp_before_operator_ptr_star")))
        self.label_sp_before_operator_ptr_star.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_operator_ptr_star, 65, 0, 1, 2)
        self.label_option_sp_before_operator_ptr_star = QtWidgets.QLabel("sp_before_operator_ptr_star")
        self.label_option_sp_before_operator_ptr_star.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_operator_ptr_star, 66, 0)
        self.option_sp_before_operator_ptr_star =  QtWidgets.QComboBox()
        self.option_sp_before_operator_ptr_star.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_operator_ptr_star.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_operator_ptr_star, 66, 1)
        #--------------------------------------------
        self.label_sp_before_scope_ptr_star = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before pointer star '*' that is followed by\na class scope (as in 'int *MyClass::method()') or namespace scope\n(as in 'int *my_ns::func()').\nIf set to ignore, sp_before_unnamed_ptr_star is used instead.", "sp_before_scope_ptr_star")))
        self.label_sp_before_scope_ptr_star.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_scope_ptr_star, 67, 0, 1, 2)
        self.label_option_sp_before_scope_ptr_star = QtWidgets.QLabel("sp_before_scope_ptr_star")
        self.label_option_sp_before_scope_ptr_star.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_scope_ptr_star, 68, 0)
        self.option_sp_before_scope_ptr_star =  QtWidgets.QComboBox()
        self.option_sp_before_scope_ptr_star.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_scope_ptr_star.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_scope_ptr_star, 68, 1)
        #--------------------------------------------
        self.label_sp_before_global_scope_ptr_star = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before pointer star '*' that is followed by '::',\nas in 'int *::func()'.\nIf set to ignore, sp_before_unnamed_ptr_star is used instead.", "sp_before_global_scope_ptr_star")))
        self.label_sp_before_global_scope_ptr_star.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_global_scope_ptr_star, 69, 0, 1, 2)
        self.label_option_sp_before_global_scope_ptr_star = QtWidgets.QLabel("sp_before_global_scope_ptr_star")
        self.label_option_sp_before_global_scope_ptr_star.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_global_scope_ptr_star, 70, 0)
        self.option_sp_before_global_scope_ptr_star =  QtWidgets.QComboBox()
        self.option_sp_before_global_scope_ptr_star.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_global_scope_ptr_star.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_global_scope_ptr_star, 70, 1)
        #--------------------------------------------
        self.label_sp_qualifier_unnamed_ptr_star = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between a qualifier and a pointer star '*' that isn't\nfollowed by a variable name, as in '(char const *)'. If set to ignore,\nsp_before_ptr_star is used instead.", "sp_qualifier_unnamed_ptr_star")))
        self.label_sp_qualifier_unnamed_ptr_star.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_qualifier_unnamed_ptr_star, 71, 0, 1, 2)
        self.label_option_sp_qualifier_unnamed_ptr_star = QtWidgets.QLabel("sp_qualifier_unnamed_ptr_star")
        self.label_option_sp_qualifier_unnamed_ptr_star.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_qualifier_unnamed_ptr_star, 72, 0)
        self.option_sp_qualifier_unnamed_ptr_star =  QtWidgets.QComboBox()
        self.option_sp_qualifier_unnamed_ptr_star.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_qualifier_unnamed_ptr_star.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_qualifier_unnamed_ptr_star, 72, 1)
        #--------------------------------------------
        self.label_sp_between_ptr_star = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between pointer stars '*', as in 'int ***a;'.", "sp_between_ptr_star")))
        self.label_sp_between_ptr_star.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_between_ptr_star, 73, 0, 1, 2)
        self.label_option_sp_between_ptr_star = QtWidgets.QLabel("sp_between_ptr_star")
        self.label_option_sp_between_ptr_star.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_between_ptr_star, 74, 0)
        self.option_sp_between_ptr_star =  QtWidgets.QComboBox()
        self.option_sp_between_ptr_star.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_between_ptr_star.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_between_ptr_star, 74, 1)
        #--------------------------------------------
        self.label_sp_between_ptr_ref = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between pointer star '*' and reference '&', as in 'int *& a;'.", "sp_between_ptr_ref")))
        self.label_sp_between_ptr_ref.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_between_ptr_ref, 75, 0, 1, 2)
        self.label_option_sp_between_ptr_ref = QtWidgets.QLabel("sp_between_ptr_ref")
        self.label_option_sp_between_ptr_ref.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_between_ptr_ref, 76, 0)
        self.option_sp_between_ptr_ref =  QtWidgets.QComboBox()
        self.option_sp_between_ptr_ref.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_between_ptr_ref.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_between_ptr_ref, 76, 1)
        #--------------------------------------------
        self.label_sp_after_ptr_star = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after pointer star '*', if followed by a word.", "sp_after_ptr_star")+"\n\n"+self.tr("Overrides sp_type_func.", "sp_after_ptr_star")))
        self.label_sp_after_ptr_star.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_ptr_star, 77, 0, 1, 2)
        self.label_option_sp_after_ptr_star = QtWidgets.QLabel("sp_after_ptr_star")
        self.label_option_sp_after_ptr_star.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_ptr_star, 78, 0)
        self.option_sp_after_ptr_star =  QtWidgets.QComboBox()
        self.option_sp_after_ptr_star.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_ptr_star.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_ptr_star, 78, 1)
        #--------------------------------------------
        self.label_sp_after_ptr_block_caret = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after pointer caret '^', if followed by a word.", "sp_after_ptr_block_caret")))
        self.label_sp_after_ptr_block_caret.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_ptr_block_caret, 79, 0, 1, 2)
        self.label_option_sp_after_ptr_block_caret = QtWidgets.QLabel("sp_after_ptr_block_caret")
        self.label_option_sp_after_ptr_block_caret.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_ptr_block_caret, 80, 0)
        self.option_sp_after_ptr_block_caret =  QtWidgets.QComboBox()
        self.option_sp_after_ptr_block_caret.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_ptr_block_caret.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_ptr_block_caret, 80, 1)
        #--------------------------------------------
        self.label_sp_after_ptr_star_qualifier = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after pointer star '*', if followed by a qualifier.", "sp_after_ptr_star_qualifier")))
        self.label_sp_after_ptr_star_qualifier.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_ptr_star_qualifier, 81, 0, 1, 2)
        self.label_option_sp_after_ptr_star_qualifier = QtWidgets.QLabel("sp_after_ptr_star_qualifier")
        self.label_option_sp_after_ptr_star_qualifier.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_ptr_star_qualifier, 82, 0)
        self.option_sp_after_ptr_star_qualifier =  QtWidgets.QComboBox()
        self.option_sp_after_ptr_star_qualifier.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_ptr_star_qualifier.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_ptr_star_qualifier, 82, 1)
        #--------------------------------------------
        self.label_sp_after_ptr_star_func = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after a pointer star '*', if followed by a function\nprototype or function definition.", "sp_after_ptr_star_func")+"\n\n"+self.tr("Overrides sp_after_ptr_star and sp_type_func.", "sp_after_ptr_star_func")))
        self.label_sp_after_ptr_star_func.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_ptr_star_func, 83, 0, 1, 2)
        self.label_option_sp_after_ptr_star_func = QtWidgets.QLabel("sp_after_ptr_star_func")
        self.label_option_sp_after_ptr_star_func.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_ptr_star_func, 84, 0)
        self.option_sp_after_ptr_star_func =  QtWidgets.QComboBox()
        self.option_sp_after_ptr_star_func.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_ptr_star_func.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_ptr_star_func, 84, 1)
        #--------------------------------------------
        self.label_sp_after_ptr_star_trailing = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after a pointer star '*' in the trailing return of a\nfunction prototype or function definition.", "sp_after_ptr_star_trailing")))
        self.label_sp_after_ptr_star_trailing.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_ptr_star_trailing, 85, 0, 1, 2)
        self.label_option_sp_after_ptr_star_trailing = QtWidgets.QLabel("sp_after_ptr_star_trailing")
        self.label_option_sp_after_ptr_star_trailing.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_ptr_star_trailing, 86, 0)
        self.option_sp_after_ptr_star_trailing =  QtWidgets.QComboBox()
        self.option_sp_after_ptr_star_trailing.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_ptr_star_trailing.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_ptr_star_trailing, 86, 1)
        #--------------------------------------------
        self.label_sp_ptr_star_func_var = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between the pointer star '*' and the name of the variable\nin a function pointer definition.", "sp_ptr_star_func_var")))
        self.label_sp_ptr_star_func_var.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_ptr_star_func_var, 87, 0, 1, 2)
        self.label_option_sp_ptr_star_func_var = QtWidgets.QLabel("sp_ptr_star_func_var")
        self.label_option_sp_ptr_star_func_var.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_ptr_star_func_var, 88, 0)
        self.option_sp_ptr_star_func_var =  QtWidgets.QComboBox()
        self.option_sp_ptr_star_func_var.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_ptr_star_func_var.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_ptr_star_func_var, 88, 1)
        #--------------------------------------------
        self.label_sp_ptr_star_func_type = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between the pointer star '*' and the name of the type\nin a function pointer type definition.", "sp_ptr_star_func_type")))
        self.label_sp_ptr_star_func_type.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_ptr_star_func_type, 89, 0, 1, 2)
        self.label_option_sp_ptr_star_func_type = QtWidgets.QLabel("sp_ptr_star_func_type")
        self.label_option_sp_ptr_star_func_type.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_ptr_star_func_type, 90, 0)
        self.option_sp_ptr_star_func_type =  QtWidgets.QComboBox()
        self.option_sp_ptr_star_func_type.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_ptr_star_func_type.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_ptr_star_func_type, 90, 1)
        #--------------------------------------------
        self.label_sp_ptr_star_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after a pointer star '*', if followed by an open\nparenthesis, as in 'void* (*)()'.", "sp_ptr_star_paren")))
        self.label_sp_ptr_star_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_ptr_star_paren, 91, 0, 1, 2)
        self.label_option_sp_ptr_star_paren = QtWidgets.QLabel("sp_ptr_star_paren")
        self.label_option_sp_ptr_star_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_ptr_star_paren, 92, 0)
        self.option_sp_ptr_star_paren =  QtWidgets.QComboBox()
        self.option_sp_ptr_star_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_ptr_star_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_ptr_star_paren, 92, 1)
        #--------------------------------------------
        self.label_sp_before_ptr_star_func = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before a pointer star '*', if followed by a function\nprototype or function definition. If set to ignore, sp_before_ptr_star is\nused instead.", "sp_before_ptr_star_func")))
        self.label_sp_before_ptr_star_func.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_ptr_star_func, 93, 0, 1, 2)
        self.label_option_sp_before_ptr_star_func = QtWidgets.QLabel("sp_before_ptr_star_func")
        self.label_option_sp_before_ptr_star_func.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_ptr_star_func, 94, 0)
        self.option_sp_before_ptr_star_func =  QtWidgets.QComboBox()
        self.option_sp_before_ptr_star_func.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_ptr_star_func.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_ptr_star_func, 94, 1)
        #--------------------------------------------
        self.label_sp_qualifier_ptr_star_func = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between a qualifier and a pointer star '*' followed by\nthe name of the function in a function prototype or definition, as in\n'char const *foo()`. If set to ignore, sp_before_ptr_star is used instead.", "sp_qualifier_ptr_star_func")))
        self.label_sp_qualifier_ptr_star_func.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_qualifier_ptr_star_func, 95, 0, 1, 2)
        self.label_option_sp_qualifier_ptr_star_func = QtWidgets.QLabel("sp_qualifier_ptr_star_func")
        self.label_option_sp_qualifier_ptr_star_func.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_qualifier_ptr_star_func, 96, 0)
        self.option_sp_qualifier_ptr_star_func =  QtWidgets.QComboBox()
        self.option_sp_qualifier_ptr_star_func.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_qualifier_ptr_star_func.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_qualifier_ptr_star_func, 96, 1)
        #--------------------------------------------
        self.label_sp_before_ptr_star_trailing = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before a pointer star '*' in the trailing return of a\nfunction prototype or function definition.", "sp_before_ptr_star_trailing")))
        self.label_sp_before_ptr_star_trailing.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_ptr_star_trailing, 97, 0, 1, 2)
        self.label_option_sp_before_ptr_star_trailing = QtWidgets.QLabel("sp_before_ptr_star_trailing")
        self.label_option_sp_before_ptr_star_trailing.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_ptr_star_trailing, 98, 0)
        self.option_sp_before_ptr_star_trailing =  QtWidgets.QComboBox()
        self.option_sp_before_ptr_star_trailing.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_ptr_star_trailing.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_ptr_star_trailing, 98, 1)
        #--------------------------------------------
        self.label_sp_qualifier_ptr_star_trailing = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between a qualifier and a pointer star '*' in the\ntrailing return of a function prototype or function definition, as in\n'auto foo() -> char const *'.", "sp_qualifier_ptr_star_trailing")))
        self.label_sp_qualifier_ptr_star_trailing.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_qualifier_ptr_star_trailing, 99, 0, 1, 2)
        self.label_option_sp_qualifier_ptr_star_trailing = QtWidgets.QLabel("sp_qualifier_ptr_star_trailing")
        self.label_option_sp_qualifier_ptr_star_trailing.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_qualifier_ptr_star_trailing, 100, 0)
        self.option_sp_qualifier_ptr_star_trailing =  QtWidgets.QComboBox()
        self.option_sp_qualifier_ptr_star_trailing.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_qualifier_ptr_star_trailing.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_qualifier_ptr_star_trailing, 100, 1)
        #--------------------------------------------
        self.label_sp_before_byref = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before a reference sign '&'.", "sp_before_byref")))
        self.label_sp_before_byref.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_byref, 101, 0, 1, 2)
        self.label_option_sp_before_byref = QtWidgets.QLabel("sp_before_byref")
        self.label_option_sp_before_byref.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_byref, 102, 0)
        self.option_sp_before_byref =  QtWidgets.QComboBox()
        self.option_sp_before_byref.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_byref.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_byref, 102, 1)
        #--------------------------------------------
        self.label_sp_before_unnamed_byref = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before a reference sign '&' that isn't followed by a\nvariable name. If set to ignore, sp_before_byref is used instead.", "sp_before_unnamed_byref")))
        self.label_sp_before_unnamed_byref.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_unnamed_byref, 103, 0, 1, 2)
        self.label_option_sp_before_unnamed_byref = QtWidgets.QLabel("sp_before_unnamed_byref")
        self.label_option_sp_before_unnamed_byref.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_unnamed_byref, 104, 0)
        self.option_sp_before_unnamed_byref =  QtWidgets.QComboBox()
        self.option_sp_before_unnamed_byref.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_unnamed_byref.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_unnamed_byref, 104, 1)
        #--------------------------------------------
        self.label_sp_after_byref = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after reference sign '&', if followed by a word.", "sp_after_byref")+"\n\n"+self.tr("Overrides sp_type_func.", "sp_after_byref")))
        self.label_sp_after_byref.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_byref, 105, 0, 1, 2)
        self.label_option_sp_after_byref = QtWidgets.QLabel("sp_after_byref")
        self.label_option_sp_after_byref.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_byref, 106, 0)
        self.option_sp_after_byref =  QtWidgets.QComboBox()
        self.option_sp_after_byref.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_byref.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_byref, 106, 1)
        #--------------------------------------------
        self.label_sp_after_byref_func = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after a reference sign '&', if followed by a function\nprototype or function definition.", "sp_after_byref_func")+"\n\n"+self.tr("Overrides sp_after_byref and sp_type_func.", "sp_after_byref_func")))
        self.label_sp_after_byref_func.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_byref_func, 107, 0, 1, 2)
        self.label_option_sp_after_byref_func = QtWidgets.QLabel("sp_after_byref_func")
        self.label_option_sp_after_byref_func.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_byref_func, 108, 0)
        self.option_sp_after_byref_func =  QtWidgets.QComboBox()
        self.option_sp_after_byref_func.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_byref_func.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_byref_func, 108, 1)
        #--------------------------------------------
        self.label_sp_before_byref_func = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before a reference sign '&', if followed by a function\nprototype or function definition.", "sp_before_byref_func")))
        self.label_sp_before_byref_func.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_byref_func, 109, 0, 1, 2)
        self.label_option_sp_before_byref_func = QtWidgets.QLabel("sp_before_byref_func")
        self.label_option_sp_before_byref_func.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_byref_func, 110, 0)
        self.option_sp_before_byref_func =  QtWidgets.QComboBox()
        self.option_sp_before_byref_func.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_byref_func.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_byref_func, 110, 1)
        #--------------------------------------------
        self.label_sp_byref_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after a reference sign '&', if followed by an open\nparenthesis, as in 'char& (*)()'.", "sp_byref_paren")))
        self.label_sp_byref_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_byref_paren, 111, 0, 1, 2)
        self.label_option_sp_byref_paren = QtWidgets.QLabel("sp_byref_paren")
        self.label_option_sp_byref_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_byref_paren, 112, 0)
        self.option_sp_byref_paren =  QtWidgets.QComboBox()
        self.option_sp_byref_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_byref_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_byref_paren, 112, 1)
        #--------------------------------------------
        self.label_sp_after_type = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between type and word. In cases where total removal of\nwhitespace would be a syntax error, a value of 'remove' is treated the same\nas 'force'.", "sp_after_type")+"\n\n"+self.tr("This also affects some other instances of space following a type that are\nnot covered by other options; for example, between the return type and\nparenthesis of a function type template argument, between the type and\nparenthesis of an array parameter, or between 'decltype(...)' and the\nfollowing word.", "sp_after_type")))
        self.label_sp_after_type.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_type, 113, 0, 1, 2)
        self.label_option_sp_after_type = QtWidgets.QLabel("sp_after_type")
        self.label_option_sp_after_type.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_type, 114, 0)
        self.option_sp_after_type =  QtWidgets.QComboBox()
        self.option_sp_after_type.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_type.setCurrentText("force")
        self.group_page_layout_2.addWidget(self.option_sp_after_type, 114, 1)
        #--------------------------------------------
        self.label_sp_after_decltype = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between 'decltype(...)' and word,\nbrace or function call.", "sp_after_decltype")))
        self.label_sp_after_decltype.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_decltype, 115, 0, 1, 2)
        self.label_option_sp_after_decltype = QtWidgets.QLabel("sp_after_decltype")
        self.label_option_sp_after_decltype.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_decltype, 116, 0)
        self.option_sp_after_decltype =  QtWidgets.QComboBox()
        self.option_sp_after_decltype.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_decltype.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_decltype, 116, 1)
        #--------------------------------------------
        self.label_sp_before_template_paren = QtWidgets.QLabel(label("<hr>"+self.tr("(D) Add or remove space before the parenthesis in the D constructs\n'template Foo(' and 'class Foo('.", "sp_before_template_paren")))
        self.label_sp_before_template_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_template_paren, 117, 0, 1, 2)
        self.label_option_sp_before_template_paren = QtWidgets.QLabel("sp_before_template_paren")
        self.label_option_sp_before_template_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_template_paren, 118, 0)
        self.option_sp_before_template_paren =  QtWidgets.QComboBox()
        self.option_sp_before_template_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_template_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_template_paren, 118, 1)
        #--------------------------------------------
        self.label_sp_template_angle = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between 'template' and '<'.\nIf set to ignore, sp_before_angle is used.", "sp_template_angle")))
        self.label_sp_template_angle.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_template_angle, 119, 0, 1, 2)
        self.label_option_sp_template_angle = QtWidgets.QLabel("sp_template_angle")
        self.label_option_sp_template_angle.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_template_angle, 120, 0)
        self.option_sp_template_angle =  QtWidgets.QComboBox()
        self.option_sp_template_angle.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_template_angle.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_template_angle, 120, 1)
        #--------------------------------------------
        self.label_sp_before_angle = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before '<'.", "sp_before_angle")))
        self.label_sp_before_angle.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_angle, 121, 0, 1, 2)
        self.label_option_sp_before_angle = QtWidgets.QLabel("sp_before_angle")
        self.label_option_sp_before_angle.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_angle, 122, 0)
        self.option_sp_before_angle =  QtWidgets.QComboBox()
        self.option_sp_before_angle.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_angle.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_angle, 122, 1)
        #--------------------------------------------
        self.label_sp_inside_angle = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space inside '<' and '>'.", "sp_inside_angle")))
        self.label_sp_inside_angle.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_angle, 123, 0, 1, 2)
        self.label_option_sp_inside_angle = QtWidgets.QLabel("sp_inside_angle")
        self.label_option_sp_inside_angle.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_angle, 124, 0)
        self.option_sp_inside_angle =  QtWidgets.QComboBox()
        self.option_sp_inside_angle.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_angle.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_angle, 124, 1)
        #--------------------------------------------
        self.label_sp_inside_angle_empty = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space inside '<>'.\nif empty.", "sp_inside_angle_empty")))
        self.label_sp_inside_angle_empty.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_angle_empty, 125, 0, 1, 2)
        self.label_option_sp_inside_angle_empty = QtWidgets.QLabel("sp_inside_angle_empty")
        self.label_option_sp_inside_angle_empty.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_angle_empty, 126, 0)
        self.option_sp_inside_angle_empty =  QtWidgets.QComboBox()
        self.option_sp_inside_angle_empty.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_angle_empty.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_angle_empty, 126, 1)
        #--------------------------------------------
        self.label_sp_angle_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between '>' and ':'.", "sp_angle_colon")))
        self.label_sp_angle_colon.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_angle_colon, 127, 0, 1, 2)
        self.label_option_sp_angle_colon = QtWidgets.QLabel("sp_angle_colon")
        self.label_option_sp_angle_colon.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_angle_colon, 128, 0)
        self.option_sp_angle_colon =  QtWidgets.QComboBox()
        self.option_sp_angle_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_angle_colon.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_angle_colon, 128, 1)
        #--------------------------------------------
        self.label_sp_after_angle = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after '>'.", "sp_after_angle")))
        self.label_sp_after_angle.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_angle, 129, 0, 1, 2)
        self.label_option_sp_after_angle = QtWidgets.QLabel("sp_after_angle")
        self.label_option_sp_after_angle.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_angle, 130, 0)
        self.option_sp_after_angle =  QtWidgets.QComboBox()
        self.option_sp_after_angle.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_angle.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_angle, 130, 1)
        #--------------------------------------------
        self.label_sp_angle_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between '>' and '(' as found in 'new List<byte>(foo);'.", "sp_angle_paren")))
        self.label_sp_angle_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_angle_paren, 131, 0, 1, 2)
        self.label_option_sp_angle_paren = QtWidgets.QLabel("sp_angle_paren")
        self.label_option_sp_angle_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_angle_paren, 132, 0)
        self.option_sp_angle_paren =  QtWidgets.QComboBox()
        self.option_sp_angle_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_angle_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_angle_paren, 132, 1)
        #--------------------------------------------
        self.label_sp_angle_paren_empty = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between '>' and '()' as found in 'new List<byte>();'.", "sp_angle_paren_empty")))
        self.label_sp_angle_paren_empty.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_angle_paren_empty, 133, 0, 1, 2)
        self.label_option_sp_angle_paren_empty = QtWidgets.QLabel("sp_angle_paren_empty")
        self.label_option_sp_angle_paren_empty.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_angle_paren_empty, 134, 0)
        self.option_sp_angle_paren_empty =  QtWidgets.QComboBox()
        self.option_sp_angle_paren_empty.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_angle_paren_empty.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_angle_paren_empty, 134, 1)
        #--------------------------------------------
        self.label_sp_angle_word = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between '>' and a word as in 'List<byte> m;' or\n'template <typename T> static ...'.", "sp_angle_word")))
        self.label_sp_angle_word.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_angle_word, 135, 0, 1, 2)
        self.label_option_sp_angle_word = QtWidgets.QLabel("sp_angle_word")
        self.label_option_sp_angle_word.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_angle_word, 136, 0)
        self.option_sp_angle_word =  QtWidgets.QComboBox()
        self.option_sp_angle_word.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_angle_word.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_angle_word, 136, 1)
        #--------------------------------------------
        self.label_sp_angle_shift = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between '>' and '>' in '>>' (template stuff).", "sp_angle_shift")))
        self.label_sp_angle_shift.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_angle_shift, 137, 0, 1, 2)
        self.label_option_sp_angle_shift = QtWidgets.QLabel("sp_angle_shift")
        self.label_option_sp_angle_shift.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_angle_shift, 138, 0)
        self.option_sp_angle_shift =  QtWidgets.QComboBox()
        self.option_sp_angle_shift.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_angle_shift.setCurrentText("add")
        self.group_page_layout_2.addWidget(self.option_sp_angle_shift, 138, 1)
        #--------------------------------------------
        self.label_sp_permit_cpp11_shift = QtWidgets.QLabel(label("<hr>"+self.tr("(C++11) Permit removal of the space between '>>' in 'foo<bar<int> >'. Note\nthat sp_angle_shift cannot remove the space without this option.", "sp_permit_cpp11_shift")))
        self.label_sp_permit_cpp11_shift.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_permit_cpp11_shift, 139, 0, 1, 2)
        self.label_option_sp_permit_cpp11_shift = QtWidgets.QLabel("sp_permit_cpp11_shift")
        self.label_option_sp_permit_cpp11_shift.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_permit_cpp11_shift, 140, 0)
        self.option_sp_permit_cpp11_shift =  QtWidgets.QComboBox()
        self.option_sp_permit_cpp11_shift.addItems(['true','false'])
        self.option_sp_permit_cpp11_shift.setCurrentText("false")
        self.group_page_layout_2.addWidget(self.option_sp_permit_cpp11_shift, 140, 1)
        #--------------------------------------------
        self.label_sp_before_sparen = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before '(' of control statements ('if', 'for', 'switch',\n'while', etc.).", "sp_before_sparen")))
        self.label_sp_before_sparen.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_sparen, 141, 0, 1, 2)
        self.label_option_sp_before_sparen = QtWidgets.QLabel("sp_before_sparen")
        self.label_option_sp_before_sparen.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_sparen, 142, 0)
        self.option_sp_before_sparen =  QtWidgets.QComboBox()
        self.option_sp_before_sparen.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_sparen.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_sparen, 142, 1)
        #--------------------------------------------
        self.label_sp_inside_sparen = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space inside '(' and ')' of control statements other than\n'for'.", "sp_inside_sparen")))
        self.label_sp_inside_sparen.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_sparen, 143, 0, 1, 2)
        self.label_option_sp_inside_sparen = QtWidgets.QLabel("sp_inside_sparen")
        self.label_option_sp_inside_sparen.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_sparen, 144, 0)
        self.option_sp_inside_sparen =  QtWidgets.QComboBox()
        self.option_sp_inside_sparen.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_sparen.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_sparen, 144, 1)
        #--------------------------------------------
        self.label_sp_inside_sparen_open = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after '(' of control statements other than 'for'.", "sp_inside_sparen_open")+"\n\n"+self.tr("Overrides sp_inside_sparen.", "sp_inside_sparen_open")))
        self.label_sp_inside_sparen_open.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_sparen_open, 145, 0, 1, 2)
        self.label_option_sp_inside_sparen_open = QtWidgets.QLabel("sp_inside_sparen_open")
        self.label_option_sp_inside_sparen_open.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_sparen_open, 146, 0)
        self.option_sp_inside_sparen_open =  QtWidgets.QComboBox()
        self.option_sp_inside_sparen_open.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_sparen_open.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_sparen_open, 146, 1)
        #--------------------------------------------
        self.label_sp_inside_sparen_close = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before ')' of control statements other than 'for'.", "sp_inside_sparen_close")+"\n\n"+self.tr("Overrides sp_inside_sparen.", "sp_inside_sparen_close")))
        self.label_sp_inside_sparen_close.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_sparen_close, 147, 0, 1, 2)
        self.label_option_sp_inside_sparen_close = QtWidgets.QLabel("sp_inside_sparen_close")
        self.label_option_sp_inside_sparen_close.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_sparen_close, 148, 0)
        self.option_sp_inside_sparen_close =  QtWidgets.QComboBox()
        self.option_sp_inside_sparen_close.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_sparen_close.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_sparen_close, 148, 1)
        #--------------------------------------------
        self.label_sp_inside_for = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space inside '(' and ')' of 'for' statements.", "sp_inside_for")))
        self.label_sp_inside_for.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_for, 149, 0, 1, 2)
        self.label_option_sp_inside_for = QtWidgets.QLabel("sp_inside_for")
        self.label_option_sp_inside_for.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_for, 150, 0)
        self.option_sp_inside_for =  QtWidgets.QComboBox()
        self.option_sp_inside_for.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_for.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_for, 150, 1)
        #--------------------------------------------
        self.label_sp_inside_for_open = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after '(' of 'for' statements.", "sp_inside_for_open")+"\n\n"+self.tr("Overrides sp_inside_for.", "sp_inside_for_open")))
        self.label_sp_inside_for_open.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_for_open, 151, 0, 1, 2)
        self.label_option_sp_inside_for_open = QtWidgets.QLabel("sp_inside_for_open")
        self.label_option_sp_inside_for_open.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_for_open, 152, 0)
        self.option_sp_inside_for_open =  QtWidgets.QComboBox()
        self.option_sp_inside_for_open.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_for_open.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_for_open, 152, 1)
        #--------------------------------------------
        self.label_sp_inside_for_close = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before ')' of 'for' statements.", "sp_inside_for_close")+"\n\n"+self.tr("Overrides sp_inside_for.", "sp_inside_for_close")))
        self.label_sp_inside_for_close.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_for_close, 153, 0, 1, 2)
        self.label_option_sp_inside_for_close = QtWidgets.QLabel("sp_inside_for_close")
        self.label_option_sp_inside_for_close.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_for_close, 154, 0)
        self.option_sp_inside_for_close =  QtWidgets.QComboBox()
        self.option_sp_inside_for_close.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_for_close.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_for_close, 154, 1)
        #--------------------------------------------
        self.label_sp_sparen_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between '((' or '))' of control statements.", "sp_sparen_paren")))
        self.label_sp_sparen_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_sparen_paren, 155, 0, 1, 2)
        self.label_option_sp_sparen_paren = QtWidgets.QLabel("sp_sparen_paren")
        self.label_option_sp_sparen_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_sparen_paren, 156, 0)
        self.option_sp_sparen_paren =  QtWidgets.QComboBox()
        self.option_sp_sparen_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_sparen_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_sparen_paren, 156, 1)
        #--------------------------------------------
        self.label_sp_after_sparen = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after ')' of control statements.", "sp_after_sparen")))
        self.label_sp_after_sparen.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_sparen, 157, 0, 1, 2)
        self.label_option_sp_after_sparen = QtWidgets.QLabel("sp_after_sparen")
        self.label_option_sp_after_sparen.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_sparen, 158, 0)
        self.option_sp_after_sparen =  QtWidgets.QComboBox()
        self.option_sp_after_sparen.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_sparen.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_sparen, 158, 1)
        #--------------------------------------------
        self.label_sp_sparen_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between ')' and '{' of control statements.", "sp_sparen_brace")))
        self.label_sp_sparen_brace.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_sparen_brace, 159, 0, 1, 2)
        self.label_option_sp_sparen_brace = QtWidgets.QLabel("sp_sparen_brace")
        self.label_option_sp_sparen_brace.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_sparen_brace, 160, 0)
        self.option_sp_sparen_brace =  QtWidgets.QComboBox()
        self.option_sp_sparen_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_sparen_brace.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_sparen_brace, 160, 1)
        #--------------------------------------------
        self.label_sp_do_brace_open = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between 'do' and '{'.", "sp_do_brace_open")))
        self.label_sp_do_brace_open.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_do_brace_open, 161, 0, 1, 2)
        self.label_option_sp_do_brace_open = QtWidgets.QLabel("sp_do_brace_open")
        self.label_option_sp_do_brace_open.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_do_brace_open, 162, 0)
        self.option_sp_do_brace_open =  QtWidgets.QComboBox()
        self.option_sp_do_brace_open.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_do_brace_open.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_do_brace_open, 162, 1)
        #--------------------------------------------
        self.label_sp_brace_close_while = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between '}' and 'while'.", "sp_brace_close_while")))
        self.label_sp_brace_close_while.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_brace_close_while, 163, 0, 1, 2)
        self.label_option_sp_brace_close_while = QtWidgets.QLabel("sp_brace_close_while")
        self.label_option_sp_brace_close_while.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_brace_close_while, 164, 0)
        self.option_sp_brace_close_while =  QtWidgets.QComboBox()
        self.option_sp_brace_close_while.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_brace_close_while.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_brace_close_while, 164, 1)
        #--------------------------------------------
        self.label_sp_while_paren_open = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between 'while' and '('. Overrides sp_before_sparen.", "sp_while_paren_open")))
        self.label_sp_while_paren_open.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_while_paren_open, 165, 0, 1, 2)
        self.label_option_sp_while_paren_open = QtWidgets.QLabel("sp_while_paren_open")
        self.label_option_sp_while_paren_open.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_while_paren_open, 166, 0)
        self.option_sp_while_paren_open =  QtWidgets.QComboBox()
        self.option_sp_while_paren_open.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_while_paren_open.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_while_paren_open, 166, 1)
        #--------------------------------------------
        self.label_sp_invariant_paren = QtWidgets.QLabel(label("<hr>"+self.tr("(D) Add or remove space between 'invariant' and '('.", "sp_invariant_paren")))
        self.label_sp_invariant_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_invariant_paren, 167, 0, 1, 2)
        self.label_option_sp_invariant_paren = QtWidgets.QLabel("sp_invariant_paren")
        self.label_option_sp_invariant_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_invariant_paren, 168, 0)
        self.option_sp_invariant_paren =  QtWidgets.QComboBox()
        self.option_sp_invariant_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_invariant_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_invariant_paren, 168, 1)
        #--------------------------------------------
        self.label_sp_after_invariant_paren = QtWidgets.QLabel(label("<hr>"+self.tr("(D) Add or remove space after the ')' in 'invariant (C) c'.", "sp_after_invariant_paren")))
        self.label_sp_after_invariant_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_invariant_paren, 169, 0, 1, 2)
        self.label_option_sp_after_invariant_paren = QtWidgets.QLabel("sp_after_invariant_paren")
        self.label_option_sp_after_invariant_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_invariant_paren, 170, 0)
        self.option_sp_after_invariant_paren =  QtWidgets.QComboBox()
        self.option_sp_after_invariant_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_invariant_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_invariant_paren, 170, 1)
        #--------------------------------------------
        self.label_sp_special_semi = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before empty statement ';' on 'if', 'for' and 'while'.\nexamples:\n  if (b) <here> ;\n  for (a=1; a<10; a++) <here> ;\n  while (*p++ = ' ') <here> ;", "sp_special_semi")))
        self.label_sp_special_semi.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_special_semi, 171, 0, 1, 2)
        self.label_option_sp_special_semi = QtWidgets.QLabel("sp_special_semi")
        self.label_option_sp_special_semi.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_special_semi, 172, 0)
        self.option_sp_special_semi =  QtWidgets.QComboBox()
        self.option_sp_special_semi.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_special_semi.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_special_semi, 172, 1)
        #--------------------------------------------
        self.label_sp_before_semi = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before ';'.", "sp_before_semi")))
        self.label_sp_before_semi.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_semi, 173, 0, 1, 2)
        self.label_option_sp_before_semi = QtWidgets.QLabel("sp_before_semi")
        self.label_option_sp_before_semi.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_semi, 174, 0)
        self.option_sp_before_semi =  QtWidgets.QComboBox()
        self.option_sp_before_semi.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_semi.setCurrentText("remove")
        self.group_page_layout_2.addWidget(self.option_sp_before_semi, 174, 1)
        #--------------------------------------------
        self.label_sp_before_semi_for = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before ';' in non-empty 'for' statements.", "sp_before_semi_for")))
        self.label_sp_before_semi_for.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_semi_for, 175, 0, 1, 2)
        self.label_option_sp_before_semi_for = QtWidgets.QLabel("sp_before_semi_for")
        self.label_option_sp_before_semi_for.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_semi_for, 176, 0)
        self.option_sp_before_semi_for =  QtWidgets.QComboBox()
        self.option_sp_before_semi_for.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_semi_for.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_semi_for, 176, 1)
        #--------------------------------------------
        self.label_sp_before_semi_for_empty = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before a semicolon of an empty left part of a for\nstatement, as in 'for ( <here> ; ; )'.", "sp_before_semi_for_empty")))
        self.label_sp_before_semi_for_empty.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_semi_for_empty, 177, 0, 1, 2)
        self.label_option_sp_before_semi_for_empty = QtWidgets.QLabel("sp_before_semi_for_empty")
        self.label_option_sp_before_semi_for_empty.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_semi_for_empty, 178, 0)
        self.option_sp_before_semi_for_empty =  QtWidgets.QComboBox()
        self.option_sp_before_semi_for_empty.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_semi_for_empty.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_semi_for_empty, 178, 1)
        #--------------------------------------------
        self.label_sp_between_semi_for_empty = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between the semicolons of an empty middle part of a for\nstatement, as in 'for ( ; <here> ; )'.", "sp_between_semi_for_empty")))
        self.label_sp_between_semi_for_empty.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_between_semi_for_empty, 179, 0, 1, 2)
        self.label_option_sp_between_semi_for_empty = QtWidgets.QLabel("sp_between_semi_for_empty")
        self.label_option_sp_between_semi_for_empty.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_between_semi_for_empty, 180, 0)
        self.option_sp_between_semi_for_empty =  QtWidgets.QComboBox()
        self.option_sp_between_semi_for_empty.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_between_semi_for_empty.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_between_semi_for_empty, 180, 1)
        #--------------------------------------------
        self.label_sp_after_semi = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after ';', except when followed by a comment.", "sp_after_semi")))
        self.label_sp_after_semi.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_semi, 181, 0, 1, 2)
        self.label_option_sp_after_semi = QtWidgets.QLabel("sp_after_semi")
        self.label_option_sp_after_semi.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_semi, 182, 0)
        self.option_sp_after_semi =  QtWidgets.QComboBox()
        self.option_sp_after_semi.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_semi.setCurrentText("add")
        self.group_page_layout_2.addWidget(self.option_sp_after_semi, 182, 1)
        #--------------------------------------------
        self.label_sp_after_semi_for = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after ';' in non-empty 'for' statements.", "sp_after_semi_for")))
        self.label_sp_after_semi_for.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_semi_for, 183, 0, 1, 2)
        self.label_option_sp_after_semi_for = QtWidgets.QLabel("sp_after_semi_for")
        self.label_option_sp_after_semi_for.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_semi_for, 184, 0)
        self.option_sp_after_semi_for =  QtWidgets.QComboBox()
        self.option_sp_after_semi_for.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_semi_for.setCurrentText("force")
        self.group_page_layout_2.addWidget(self.option_sp_after_semi_for, 184, 1)
        #--------------------------------------------
        self.label_sp_after_semi_for_empty = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after the final semicolon of an empty part of a for\nstatement, as in 'for ( ; ; <here> )'.", "sp_after_semi_for_empty")))
        self.label_sp_after_semi_for_empty.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_semi_for_empty, 185, 0, 1, 2)
        self.label_option_sp_after_semi_for_empty = QtWidgets.QLabel("sp_after_semi_for_empty")
        self.label_option_sp_after_semi_for_empty.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_semi_for_empty, 186, 0)
        self.option_sp_after_semi_for_empty =  QtWidgets.QComboBox()
        self.option_sp_after_semi_for_empty.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_semi_for_empty.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_semi_for_empty, 186, 1)
        #--------------------------------------------
        self.label_sp_before_square = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before '[' (except '[]').", "sp_before_square")))
        self.label_sp_before_square.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_square, 187, 0, 1, 2)
        self.label_option_sp_before_square = QtWidgets.QLabel("sp_before_square")
        self.label_option_sp_before_square.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_square, 188, 0)
        self.option_sp_before_square =  QtWidgets.QComboBox()
        self.option_sp_before_square.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_square.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_square, 188, 1)
        #--------------------------------------------
        self.label_sp_before_vardef_square = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before '[' for a variable definition.", "sp_before_vardef_square")))
        self.label_sp_before_vardef_square.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_vardef_square, 189, 0, 1, 2)
        self.label_option_sp_before_vardef_square = QtWidgets.QLabel("sp_before_vardef_square")
        self.label_option_sp_before_vardef_square.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_vardef_square, 190, 0)
        self.option_sp_before_vardef_square =  QtWidgets.QComboBox()
        self.option_sp_before_vardef_square.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_vardef_square.setCurrentText("remove")
        self.group_page_layout_2.addWidget(self.option_sp_before_vardef_square, 190, 1)
        #--------------------------------------------
        self.label_sp_before_square_asm_block = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before '[' for asm block.", "sp_before_square_asm_block")))
        self.label_sp_before_square_asm_block.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_square_asm_block, 191, 0, 1, 2)
        self.label_option_sp_before_square_asm_block = QtWidgets.QLabel("sp_before_square_asm_block")
        self.label_option_sp_before_square_asm_block.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_square_asm_block, 192, 0)
        self.option_sp_before_square_asm_block =  QtWidgets.QComboBox()
        self.option_sp_before_square_asm_block.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_square_asm_block.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_square_asm_block, 192, 1)
        #--------------------------------------------
        self.label_sp_before_squares = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before '[]'.", "sp_before_squares")))
        self.label_sp_before_squares.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_squares, 193, 0, 1, 2)
        self.label_option_sp_before_squares = QtWidgets.QLabel("sp_before_squares")
        self.label_option_sp_before_squares.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_squares, 194, 0)
        self.option_sp_before_squares =  QtWidgets.QComboBox()
        self.option_sp_before_squares.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_squares.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_squares, 194, 1)
        #--------------------------------------------
        self.label_sp_cpp_before_struct_binding_after_byref = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before C++17 structured bindings\nafter byref.", "sp_cpp_before_struct_binding_after_byref")))
        self.label_sp_cpp_before_struct_binding_after_byref.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cpp_before_struct_binding_after_byref, 195, 0, 1, 2)
        self.label_option_sp_cpp_before_struct_binding_after_byref = QtWidgets.QLabel("sp_cpp_before_struct_binding_after_byref")
        self.label_option_sp_cpp_before_struct_binding_after_byref.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cpp_before_struct_binding_after_byref, 196, 0)
        self.option_sp_cpp_before_struct_binding_after_byref =  QtWidgets.QComboBox()
        self.option_sp_cpp_before_struct_binding_after_byref.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_cpp_before_struct_binding_after_byref.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_cpp_before_struct_binding_after_byref, 196, 1)
        #--------------------------------------------
        self.label_sp_cpp_before_struct_binding = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before C++17 structured bindings.", "sp_cpp_before_struct_binding")))
        self.label_sp_cpp_before_struct_binding.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cpp_before_struct_binding, 197, 0, 1, 2)
        self.label_option_sp_cpp_before_struct_binding = QtWidgets.QLabel("sp_cpp_before_struct_binding")
        self.label_option_sp_cpp_before_struct_binding.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cpp_before_struct_binding, 198, 0)
        self.option_sp_cpp_before_struct_binding =  QtWidgets.QComboBox()
        self.option_sp_cpp_before_struct_binding.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_cpp_before_struct_binding.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_cpp_before_struct_binding, 198, 1)
        #--------------------------------------------
        self.label_sp_inside_square = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space inside a non-empty '[' and ']'.", "sp_inside_square")))
        self.label_sp_inside_square.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_square, 199, 0, 1, 2)
        self.label_option_sp_inside_square = QtWidgets.QLabel("sp_inside_square")
        self.label_option_sp_inside_square.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_square, 200, 0)
        self.option_sp_inside_square =  QtWidgets.QComboBox()
        self.option_sp_inside_square.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_square.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_square, 200, 1)
        #--------------------------------------------
        self.label_sp_inside_square_empty = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space inside '[]'.\nif empty.", "sp_inside_square_empty")))
        self.label_sp_inside_square_empty.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_square_empty, 201, 0, 1, 2)
        self.label_option_sp_inside_square_empty = QtWidgets.QLabel("sp_inside_square_empty")
        self.label_option_sp_inside_square_empty.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_square_empty, 202, 0)
        self.option_sp_inside_square_empty =  QtWidgets.QComboBox()
        self.option_sp_inside_square_empty.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_square_empty.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_square_empty, 202, 1)
        #--------------------------------------------
        self.label_sp_inside_square_oc_array = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space inside a non-empty Objective-C boxed array '@[' and\n']'. If set to ignore, sp_inside_square is used.", "sp_inside_square_oc_array")))
        self.label_sp_inside_square_oc_array.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_square_oc_array, 203, 0, 1, 2)
        self.label_option_sp_inside_square_oc_array = QtWidgets.QLabel("sp_inside_square_oc_array")
        self.label_option_sp_inside_square_oc_array.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_square_oc_array, 204, 0)
        self.option_sp_inside_square_oc_array =  QtWidgets.QComboBox()
        self.option_sp_inside_square_oc_array.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_square_oc_array.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_square_oc_array, 204, 1)
        #--------------------------------------------
        self.label_sp_after_comma = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after ',', i.e. 'a,b' vs. 'a, b'.", "sp_after_comma")))
        self.label_sp_after_comma.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_comma, 205, 0, 1, 2)
        self.label_option_sp_after_comma = QtWidgets.QLabel("sp_after_comma")
        self.label_option_sp_after_comma.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_comma, 206, 0)
        self.option_sp_after_comma =  QtWidgets.QComboBox()
        self.option_sp_after_comma.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_comma.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_comma, 206, 1)
        #--------------------------------------------
        self.label_sp_before_comma = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before ',', i.e. 'a,b' vs. 'a ,b'.", "sp_before_comma")))
        self.label_sp_before_comma.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_comma, 207, 0, 1, 2)
        self.label_option_sp_before_comma = QtWidgets.QLabel("sp_before_comma")
        self.label_option_sp_before_comma.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_comma, 208, 0)
        self.option_sp_before_comma =  QtWidgets.QComboBox()
        self.option_sp_before_comma.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_comma.setCurrentText("remove")
        self.group_page_layout_2.addWidget(self.option_sp_before_comma, 208, 1)
        #--------------------------------------------
        self.label_sp_after_mdatype_commas = QtWidgets.QLabel(label("<hr>"+self.tr("(C#, Vala) Add or remove space between ',' and ']' in multidimensional array type\nlike 'int[,,]'.", "sp_after_mdatype_commas")))
        self.label_sp_after_mdatype_commas.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_mdatype_commas, 209, 0, 1, 2)
        self.label_option_sp_after_mdatype_commas = QtWidgets.QLabel("sp_after_mdatype_commas")
        self.label_option_sp_after_mdatype_commas.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_mdatype_commas, 210, 0)
        self.option_sp_after_mdatype_commas =  QtWidgets.QComboBox()
        self.option_sp_after_mdatype_commas.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_mdatype_commas.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_mdatype_commas, 210, 1)
        #--------------------------------------------
        self.label_sp_before_mdatype_commas = QtWidgets.QLabel(label("<hr>"+self.tr("(C#, Vala) Add or remove space between '[' and ',' in multidimensional array type\nlike 'int[,,]'.", "sp_before_mdatype_commas")))
        self.label_sp_before_mdatype_commas.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_mdatype_commas, 211, 0, 1, 2)
        self.label_option_sp_before_mdatype_commas = QtWidgets.QLabel("sp_before_mdatype_commas")
        self.label_option_sp_before_mdatype_commas.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_mdatype_commas, 212, 0)
        self.option_sp_before_mdatype_commas =  QtWidgets.QComboBox()
        self.option_sp_before_mdatype_commas.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_mdatype_commas.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_mdatype_commas, 212, 1)
        #--------------------------------------------
        self.label_sp_between_mdatype_commas = QtWidgets.QLabel(label("<hr>"+self.tr("(C#, Vala) Add or remove space between ',' in multidimensional array type\nlike 'int[,,]'.", "sp_between_mdatype_commas")))
        self.label_sp_between_mdatype_commas.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_between_mdatype_commas, 213, 0, 1, 2)
        self.label_option_sp_between_mdatype_commas = QtWidgets.QLabel("sp_between_mdatype_commas")
        self.label_option_sp_between_mdatype_commas.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_between_mdatype_commas, 214, 0)
        self.option_sp_between_mdatype_commas =  QtWidgets.QComboBox()
        self.option_sp_between_mdatype_commas.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_between_mdatype_commas.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_between_mdatype_commas, 214, 1)
        #--------------------------------------------
        self.label_sp_paren_comma = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between an open parenthesis and comma,\ni.e. '(,' vs. '( ,'.", "sp_paren_comma")))
        self.label_sp_paren_comma.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_paren_comma, 215, 0, 1, 2)
        self.label_option_sp_paren_comma = QtWidgets.QLabel("sp_paren_comma")
        self.label_option_sp_paren_comma.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_paren_comma, 216, 0)
        self.option_sp_paren_comma =  QtWidgets.QComboBox()
        self.option_sp_paren_comma.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_paren_comma.setCurrentText("force")
        self.group_page_layout_2.addWidget(self.option_sp_paren_comma, 216, 1)
        #--------------------------------------------
        self.label_sp_type_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between a type and ':'.", "sp_type_colon")))
        self.label_sp_type_colon.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_type_colon, 217, 0, 1, 2)
        self.label_option_sp_type_colon = QtWidgets.QLabel("sp_type_colon")
        self.label_option_sp_type_colon.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_type_colon, 218, 0)
        self.option_sp_type_colon =  QtWidgets.QComboBox()
        self.option_sp_type_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_type_colon.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_type_colon, 218, 1)
        #--------------------------------------------
        self.label_sp_after_ellipsis = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after the variadic '...' when preceded by a\nnon-punctuator.\nThe value REMOVE will be overridden with FORCE", "sp_after_ellipsis")))
        self.label_sp_after_ellipsis.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_ellipsis, 219, 0, 1, 2)
        self.label_option_sp_after_ellipsis = QtWidgets.QLabel("sp_after_ellipsis")
        self.label_option_sp_after_ellipsis.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_ellipsis, 220, 0)
        self.option_sp_after_ellipsis =  QtWidgets.QComboBox()
        self.option_sp_after_ellipsis.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_ellipsis.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_ellipsis, 220, 1)
        #--------------------------------------------
        self.label_sp_before_ellipsis = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before the variadic '...' when preceded by a\nnon-punctuator.\nThe value REMOVE will be overridden with FORCE", "sp_before_ellipsis")))
        self.label_sp_before_ellipsis.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_ellipsis, 221, 0, 1, 2)
        self.label_option_sp_before_ellipsis = QtWidgets.QLabel("sp_before_ellipsis")
        self.label_option_sp_before_ellipsis.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_ellipsis, 222, 0)
        self.option_sp_before_ellipsis =  QtWidgets.QComboBox()
        self.option_sp_before_ellipsis.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_ellipsis.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_ellipsis, 222, 1)
        #--------------------------------------------
        self.label_sp_type_ellipsis = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between a type and '...'.", "sp_type_ellipsis")))
        self.label_sp_type_ellipsis.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_type_ellipsis, 223, 0, 1, 2)
        self.label_option_sp_type_ellipsis = QtWidgets.QLabel("sp_type_ellipsis")
        self.label_option_sp_type_ellipsis.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_type_ellipsis, 224, 0)
        self.option_sp_type_ellipsis =  QtWidgets.QComboBox()
        self.option_sp_type_ellipsis.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_type_ellipsis.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_type_ellipsis, 224, 1)
        #--------------------------------------------
        self.label_sp_ptr_type_ellipsis = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between a '*' and '...'.", "sp_ptr_type_ellipsis")))
        self.label_sp_ptr_type_ellipsis.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_ptr_type_ellipsis, 225, 0, 1, 2)
        self.label_option_sp_ptr_type_ellipsis = QtWidgets.QLabel("sp_ptr_type_ellipsis")
        self.label_option_sp_ptr_type_ellipsis.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_ptr_type_ellipsis, 226, 0)
        self.option_sp_ptr_type_ellipsis =  QtWidgets.QComboBox()
        self.option_sp_ptr_type_ellipsis.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_ptr_type_ellipsis.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_ptr_type_ellipsis, 226, 1)
        #--------------------------------------------
        self.label_sp_paren_ellipsis = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between ')' and '...'.", "sp_paren_ellipsis")))
        self.label_sp_paren_ellipsis.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_paren_ellipsis, 227, 0, 1, 2)
        self.label_option_sp_paren_ellipsis = QtWidgets.QLabel("sp_paren_ellipsis")
        self.label_option_sp_paren_ellipsis.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_paren_ellipsis, 228, 0)
        self.option_sp_paren_ellipsis =  QtWidgets.QComboBox()
        self.option_sp_paren_ellipsis.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_paren_ellipsis.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_paren_ellipsis, 228, 1)
        #--------------------------------------------
        self.label_sp_byref_ellipsis = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between '&&' and '...'.", "sp_byref_ellipsis")))
        self.label_sp_byref_ellipsis.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_byref_ellipsis, 229, 0, 1, 2)
        self.label_option_sp_byref_ellipsis = QtWidgets.QLabel("sp_byref_ellipsis")
        self.label_option_sp_byref_ellipsis.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_byref_ellipsis, 230, 0)
        self.option_sp_byref_ellipsis =  QtWidgets.QComboBox()
        self.option_sp_byref_ellipsis.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_byref_ellipsis.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_byref_ellipsis, 230, 1)
        #--------------------------------------------
        self.label_sp_paren_qualifier = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between ')' and a qualifier such as 'const'.", "sp_paren_qualifier")))
        self.label_sp_paren_qualifier.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_paren_qualifier, 231, 0, 1, 2)
        self.label_option_sp_paren_qualifier = QtWidgets.QLabel("sp_paren_qualifier")
        self.label_option_sp_paren_qualifier.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_paren_qualifier, 232, 0)
        self.option_sp_paren_qualifier =  QtWidgets.QComboBox()
        self.option_sp_paren_qualifier.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_paren_qualifier.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_paren_qualifier, 232, 1)
        #--------------------------------------------
        self.label_sp_paren_noexcept = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between ')' and 'noexcept'.", "sp_paren_noexcept")))
        self.label_sp_paren_noexcept.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_paren_noexcept, 233, 0, 1, 2)
        self.label_option_sp_paren_noexcept = QtWidgets.QLabel("sp_paren_noexcept")
        self.label_option_sp_paren_noexcept.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_paren_noexcept, 234, 0)
        self.option_sp_paren_noexcept =  QtWidgets.QComboBox()
        self.option_sp_paren_noexcept.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_paren_noexcept.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_paren_noexcept, 234, 1)
        #--------------------------------------------
        self.label_sp_after_class_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after class ':'.", "sp_after_class_colon")))
        self.label_sp_after_class_colon.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_class_colon, 235, 0, 1, 2)
        self.label_option_sp_after_class_colon = QtWidgets.QLabel("sp_after_class_colon")
        self.label_option_sp_after_class_colon.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_class_colon, 236, 0)
        self.option_sp_after_class_colon =  QtWidgets.QComboBox()
        self.option_sp_after_class_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_class_colon.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_class_colon, 236, 1)
        #--------------------------------------------
        self.label_sp_before_class_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before class ':'.", "sp_before_class_colon")))
        self.label_sp_before_class_colon.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_class_colon, 237, 0, 1, 2)
        self.label_option_sp_before_class_colon = QtWidgets.QLabel("sp_before_class_colon")
        self.label_option_sp_before_class_colon.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_class_colon, 238, 0)
        self.option_sp_before_class_colon =  QtWidgets.QComboBox()
        self.option_sp_before_class_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_class_colon.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_class_colon, 238, 1)
        #--------------------------------------------
        self.label_sp_after_constr_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after class constructor ':'.", "sp_after_constr_colon")))
        self.label_sp_after_constr_colon.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_constr_colon, 239, 0, 1, 2)
        self.label_option_sp_after_constr_colon = QtWidgets.QLabel("sp_after_constr_colon")
        self.label_option_sp_after_constr_colon.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_constr_colon, 240, 0)
        self.option_sp_after_constr_colon =  QtWidgets.QComboBox()
        self.option_sp_after_constr_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_constr_colon.setCurrentText("add")
        self.group_page_layout_2.addWidget(self.option_sp_after_constr_colon, 240, 1)
        #--------------------------------------------
        self.label_sp_before_constr_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before class constructor ':'.", "sp_before_constr_colon")))
        self.label_sp_before_constr_colon.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_constr_colon, 241, 0, 1, 2)
        self.label_option_sp_before_constr_colon = QtWidgets.QLabel("sp_before_constr_colon")
        self.label_option_sp_before_constr_colon.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_constr_colon, 242, 0)
        self.option_sp_before_constr_colon =  QtWidgets.QComboBox()
        self.option_sp_before_constr_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_constr_colon.setCurrentText("add")
        self.group_page_layout_2.addWidget(self.option_sp_before_constr_colon, 242, 1)
        #--------------------------------------------
        self.label_sp_before_case_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before case ':'.", "sp_before_case_colon")))
        self.label_sp_before_case_colon.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_case_colon, 243, 0, 1, 2)
        self.label_option_sp_before_case_colon = QtWidgets.QLabel("sp_before_case_colon")
        self.label_option_sp_before_case_colon.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_case_colon, 244, 0)
        self.option_sp_before_case_colon =  QtWidgets.QComboBox()
        self.option_sp_before_case_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_case_colon.setCurrentText("remove")
        self.group_page_layout_2.addWidget(self.option_sp_before_case_colon, 244, 1)
        #--------------------------------------------
        self.label_sp_after_operator = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between 'operator' and operator sign.", "sp_after_operator")))
        self.label_sp_after_operator.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_operator, 245, 0, 1, 2)
        self.label_option_sp_after_operator = QtWidgets.QLabel("sp_after_operator")
        self.label_option_sp_after_operator.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_operator, 246, 0)
        self.option_sp_after_operator =  QtWidgets.QComboBox()
        self.option_sp_after_operator.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_operator.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_operator, 246, 1)
        #--------------------------------------------
        self.label_sp_after_operator_sym = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between the operator symbol and the open parenthesis, as\nin 'operator ++('.", "sp_after_operator_sym")))
        self.label_sp_after_operator_sym.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_operator_sym, 247, 0, 1, 2)
        self.label_option_sp_after_operator_sym = QtWidgets.QLabel("sp_after_operator_sym")
        self.label_option_sp_after_operator_sym.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_operator_sym, 248, 0)
        self.option_sp_after_operator_sym =  QtWidgets.QComboBox()
        self.option_sp_after_operator_sym.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_operator_sym.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_operator_sym, 248, 1)
        #--------------------------------------------
        self.label_sp_after_operator_sym_empty = QtWidgets.QLabel(label("<hr>"+self.tr("Overrides sp_after_operator_sym when the operator has no arguments, as in\n'operator *()'.", "sp_after_operator_sym_empty")))
        self.label_sp_after_operator_sym_empty.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_operator_sym_empty, 249, 0, 1, 2)
        self.label_option_sp_after_operator_sym_empty = QtWidgets.QLabel("sp_after_operator_sym_empty")
        self.label_option_sp_after_operator_sym_empty.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_operator_sym_empty, 250, 0)
        self.option_sp_after_operator_sym_empty =  QtWidgets.QComboBox()
        self.option_sp_after_operator_sym_empty.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_operator_sym_empty.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_operator_sym_empty, 250, 1)
        #--------------------------------------------
        self.label_sp_after_cast = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after C/D cast, i.e. 'cast(int)a' vs. 'cast(int) a' or\n'(int)a' vs. '(int) a'.", "sp_after_cast")))
        self.label_sp_after_cast.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_cast, 251, 0, 1, 2)
        self.label_option_sp_after_cast = QtWidgets.QLabel("sp_after_cast")
        self.label_option_sp_after_cast.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_cast, 252, 0)
        self.option_sp_after_cast =  QtWidgets.QComboBox()
        self.option_sp_after_cast.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_cast.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_cast, 252, 1)
        #--------------------------------------------
        self.label_sp_inside_paren_cast = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove spaces inside cast parentheses.", "sp_inside_paren_cast")))
        self.label_sp_inside_paren_cast.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_paren_cast, 253, 0, 1, 2)
        self.label_option_sp_inside_paren_cast = QtWidgets.QLabel("sp_inside_paren_cast")
        self.label_option_sp_inside_paren_cast.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_paren_cast, 254, 0)
        self.option_sp_inside_paren_cast =  QtWidgets.QComboBox()
        self.option_sp_inside_paren_cast.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_paren_cast.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_paren_cast, 254, 1)
        #--------------------------------------------
        self.label_sp_cpp_cast_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between the type and open parenthesis in a C++ cast,\ni.e. 'int(exp)' vs. 'int (exp)'.", "sp_cpp_cast_paren")))
        self.label_sp_cpp_cast_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cpp_cast_paren, 255, 0, 1, 2)
        self.label_option_sp_cpp_cast_paren = QtWidgets.QLabel("sp_cpp_cast_paren")
        self.label_option_sp_cpp_cast_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cpp_cast_paren, 256, 0)
        self.option_sp_cpp_cast_paren =  QtWidgets.QComboBox()
        self.option_sp_cpp_cast_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_cpp_cast_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_cpp_cast_paren, 256, 1)
        #--------------------------------------------
        self.label_sp_sizeof_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between 'sizeof' and '('.", "sp_sizeof_paren")))
        self.label_sp_sizeof_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_sizeof_paren, 257, 0, 1, 2)
        self.label_option_sp_sizeof_paren = QtWidgets.QLabel("sp_sizeof_paren")
        self.label_option_sp_sizeof_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_sizeof_paren, 258, 0)
        self.option_sp_sizeof_paren =  QtWidgets.QComboBox()
        self.option_sp_sizeof_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_sizeof_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_sizeof_paren, 258, 1)
        #--------------------------------------------
        self.label_sp_sizeof_ellipsis = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between 'sizeof' and '...'.", "sp_sizeof_ellipsis")))
        self.label_sp_sizeof_ellipsis.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_sizeof_ellipsis, 259, 0, 1, 2)
        self.label_option_sp_sizeof_ellipsis = QtWidgets.QLabel("sp_sizeof_ellipsis")
        self.label_option_sp_sizeof_ellipsis.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_sizeof_ellipsis, 260, 0)
        self.option_sp_sizeof_ellipsis =  QtWidgets.QComboBox()
        self.option_sp_sizeof_ellipsis.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_sizeof_ellipsis.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_sizeof_ellipsis, 260, 1)
        #--------------------------------------------
        self.label_sp_sizeof_ellipsis_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between 'sizeof...' and '('.", "sp_sizeof_ellipsis_paren")))
        self.label_sp_sizeof_ellipsis_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_sizeof_ellipsis_paren, 261, 0, 1, 2)
        self.label_option_sp_sizeof_ellipsis_paren = QtWidgets.QLabel("sp_sizeof_ellipsis_paren")
        self.label_option_sp_sizeof_ellipsis_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_sizeof_ellipsis_paren, 262, 0)
        self.option_sp_sizeof_ellipsis_paren =  QtWidgets.QComboBox()
        self.option_sp_sizeof_ellipsis_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_sizeof_ellipsis_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_sizeof_ellipsis_paren, 262, 1)
        #--------------------------------------------
        self.label_sp_ellipsis_parameter_pack = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between '...' and a parameter pack.", "sp_ellipsis_parameter_pack")))
        self.label_sp_ellipsis_parameter_pack.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_ellipsis_parameter_pack, 263, 0, 1, 2)
        self.label_option_sp_ellipsis_parameter_pack = QtWidgets.QLabel("sp_ellipsis_parameter_pack")
        self.label_option_sp_ellipsis_parameter_pack.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_ellipsis_parameter_pack, 264, 0)
        self.option_sp_ellipsis_parameter_pack =  QtWidgets.QComboBox()
        self.option_sp_ellipsis_parameter_pack.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_ellipsis_parameter_pack.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_ellipsis_parameter_pack, 264, 1)
        #--------------------------------------------
        self.label_sp_parameter_pack_ellipsis = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between a parameter pack and '...'.", "sp_parameter_pack_ellipsis")))
        self.label_sp_parameter_pack_ellipsis.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_parameter_pack_ellipsis, 265, 0, 1, 2)
        self.label_option_sp_parameter_pack_ellipsis = QtWidgets.QLabel("sp_parameter_pack_ellipsis")
        self.label_option_sp_parameter_pack_ellipsis.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_parameter_pack_ellipsis, 266, 0)
        self.option_sp_parameter_pack_ellipsis =  QtWidgets.QComboBox()
        self.option_sp_parameter_pack_ellipsis.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_parameter_pack_ellipsis.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_parameter_pack_ellipsis, 266, 1)
        #--------------------------------------------
        self.label_sp_decltype_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between 'decltype' and '('.", "sp_decltype_paren")))
        self.label_sp_decltype_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_decltype_paren, 267, 0, 1, 2)
        self.label_option_sp_decltype_paren = QtWidgets.QLabel("sp_decltype_paren")
        self.label_option_sp_decltype_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_decltype_paren, 268, 0)
        self.option_sp_decltype_paren =  QtWidgets.QComboBox()
        self.option_sp_decltype_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_decltype_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_decltype_paren, 268, 1)
        #--------------------------------------------
        self.label_sp_after_tag = QtWidgets.QLabel(label("<hr>"+self.tr("(Pawn) Add or remove space after the tag keyword.", "sp_after_tag")))
        self.label_sp_after_tag.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_tag, 269, 0, 1, 2)
        self.label_option_sp_after_tag = QtWidgets.QLabel("sp_after_tag")
        self.label_option_sp_after_tag.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_tag, 270, 0)
        self.option_sp_after_tag =  QtWidgets.QComboBox()
        self.option_sp_after_tag.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_tag.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_tag, 270, 1)
        #--------------------------------------------
        self.label_sp_inside_braces_enum = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space inside enum '{' and '}'.", "sp_inside_braces_enum")))
        self.label_sp_inside_braces_enum.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_braces_enum, 271, 0, 1, 2)
        self.label_option_sp_inside_braces_enum = QtWidgets.QLabel("sp_inside_braces_enum")
        self.label_option_sp_inside_braces_enum.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_braces_enum, 272, 0)
        self.option_sp_inside_braces_enum =  QtWidgets.QComboBox()
        self.option_sp_inside_braces_enum.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_braces_enum.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_braces_enum, 272, 1)
        #--------------------------------------------
        self.label_sp_inside_braces_struct = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space inside struct/union '{' and '}'.", "sp_inside_braces_struct")))
        self.label_sp_inside_braces_struct.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_braces_struct, 273, 0, 1, 2)
        self.label_option_sp_inside_braces_struct = QtWidgets.QLabel("sp_inside_braces_struct")
        self.label_option_sp_inside_braces_struct.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_braces_struct, 274, 0)
        self.option_sp_inside_braces_struct =  QtWidgets.QComboBox()
        self.option_sp_inside_braces_struct.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_braces_struct.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_braces_struct, 274, 1)
        #--------------------------------------------
        self.label_sp_inside_braces_oc_dict = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space inside Objective-C boxed dictionary '{' and '}'", "sp_inside_braces_oc_dict")))
        self.label_sp_inside_braces_oc_dict.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_braces_oc_dict, 275, 0, 1, 2)
        self.label_option_sp_inside_braces_oc_dict = QtWidgets.QLabel("sp_inside_braces_oc_dict")
        self.label_option_sp_inside_braces_oc_dict.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_braces_oc_dict, 276, 0)
        self.option_sp_inside_braces_oc_dict =  QtWidgets.QComboBox()
        self.option_sp_inside_braces_oc_dict.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_braces_oc_dict.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_braces_oc_dict, 276, 1)
        #--------------------------------------------
        self.label_sp_after_type_brace_init_lst_open = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after open brace in an unnamed temporary\ndirect-list-initialization\nif statement is a brace_init_lst\nworks only if sp_brace_brace is set to ignore.", "sp_after_type_brace_init_lst_open")))
        self.label_sp_after_type_brace_init_lst_open.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_type_brace_init_lst_open, 277, 0, 1, 2)
        self.label_option_sp_after_type_brace_init_lst_open = QtWidgets.QLabel("sp_after_type_brace_init_lst_open")
        self.label_option_sp_after_type_brace_init_lst_open.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_type_brace_init_lst_open, 278, 0)
        self.option_sp_after_type_brace_init_lst_open =  QtWidgets.QComboBox()
        self.option_sp_after_type_brace_init_lst_open.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_type_brace_init_lst_open.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_type_brace_init_lst_open, 278, 1)
        #--------------------------------------------
        self.label_sp_before_type_brace_init_lst_close = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before close brace in an unnamed temporary\ndirect-list-initialization\nif statement is a brace_init_lst\nworks only if sp_brace_brace is set to ignore.", "sp_before_type_brace_init_lst_close")))
        self.label_sp_before_type_brace_init_lst_close.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_type_brace_init_lst_close, 279, 0, 1, 2)
        self.label_option_sp_before_type_brace_init_lst_close = QtWidgets.QLabel("sp_before_type_brace_init_lst_close")
        self.label_option_sp_before_type_brace_init_lst_close.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_type_brace_init_lst_close, 280, 0)
        self.option_sp_before_type_brace_init_lst_close =  QtWidgets.QComboBox()
        self.option_sp_before_type_brace_init_lst_close.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_type_brace_init_lst_close.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_type_brace_init_lst_close, 280, 1)
        #--------------------------------------------
        self.label_sp_inside_type_brace_init_lst = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space inside an unnamed temporary direct-list-initialization\nif statement is a brace_init_lst\nworks only if sp_brace_brace is set to ignore\nworks only if sp_before_type_brace_init_lst_close is set to ignore.", "sp_inside_type_brace_init_lst")))
        self.label_sp_inside_type_brace_init_lst.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_type_brace_init_lst, 281, 0, 1, 2)
        self.label_option_sp_inside_type_brace_init_lst = QtWidgets.QLabel("sp_inside_type_brace_init_lst")
        self.label_option_sp_inside_type_brace_init_lst.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_type_brace_init_lst, 282, 0)
        self.option_sp_inside_type_brace_init_lst =  QtWidgets.QComboBox()
        self.option_sp_inside_type_brace_init_lst.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_type_brace_init_lst.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_type_brace_init_lst, 282, 1)
        #--------------------------------------------
        self.label_sp_inside_braces = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space inside '{' and '}'.", "sp_inside_braces")))
        self.label_sp_inside_braces.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_braces, 283, 0, 1, 2)
        self.label_option_sp_inside_braces = QtWidgets.QLabel("sp_inside_braces")
        self.label_option_sp_inside_braces.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_braces, 284, 0)
        self.option_sp_inside_braces =  QtWidgets.QComboBox()
        self.option_sp_inside_braces.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_braces.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_braces, 284, 1)
        #--------------------------------------------
        self.label_sp_inside_braces_empty = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space inside '{}'.\nif empty.", "sp_inside_braces_empty")))
        self.label_sp_inside_braces_empty.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_braces_empty, 285, 0, 1, 2)
        self.label_option_sp_inside_braces_empty = QtWidgets.QLabel("sp_inside_braces_empty")
        self.label_option_sp_inside_braces_empty.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_braces_empty, 286, 0)
        self.option_sp_inside_braces_empty =  QtWidgets.QComboBox()
        self.option_sp_inside_braces_empty.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_braces_empty.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_braces_empty, 286, 1)
        #--------------------------------------------
        self.label_sp_trailing_return = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space around trailing return operator '->'.", "sp_trailing_return")))
        self.label_sp_trailing_return.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_trailing_return, 287, 0, 1, 2)
        self.label_option_sp_trailing_return = QtWidgets.QLabel("sp_trailing_return")
        self.label_option_sp_trailing_return.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_trailing_return, 288, 0)
        self.option_sp_trailing_return =  QtWidgets.QComboBox()
        self.option_sp_trailing_return.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_trailing_return.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_trailing_return, 288, 1)
        #--------------------------------------------
        self.label_sp_type_func = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between return type and function name. A minimum of 1\nis forced except for pointer return types.", "sp_type_func")))
        self.label_sp_type_func.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_type_func, 289, 0, 1, 2)
        self.label_option_sp_type_func = QtWidgets.QLabel("sp_type_func")
        self.label_option_sp_type_func.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_type_func, 290, 0)
        self.option_sp_type_func =  QtWidgets.QComboBox()
        self.option_sp_type_func.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_type_func.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_type_func, 290, 1)
        #--------------------------------------------
        self.label_sp_type_brace_init_lst = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between type and open brace of an unnamed temporary\ndirect-list-initialization.", "sp_type_brace_init_lst")))
        self.label_sp_type_brace_init_lst.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_type_brace_init_lst, 291, 0, 1, 2)
        self.label_option_sp_type_brace_init_lst = QtWidgets.QLabel("sp_type_brace_init_lst")
        self.label_option_sp_type_brace_init_lst.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_type_brace_init_lst, 292, 0)
        self.option_sp_type_brace_init_lst =  QtWidgets.QComboBox()
        self.option_sp_type_brace_init_lst.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_type_brace_init_lst.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_type_brace_init_lst, 292, 1)
        #--------------------------------------------
        self.label_sp_func_proto_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between function name and '(' on function declaration.", "sp_func_proto_paren")))
        self.label_sp_func_proto_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_func_proto_paren, 293, 0, 1, 2)
        self.label_option_sp_func_proto_paren = QtWidgets.QLabel("sp_func_proto_paren")
        self.label_option_sp_func_proto_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_func_proto_paren, 294, 0)
        self.option_sp_func_proto_paren =  QtWidgets.QComboBox()
        self.option_sp_func_proto_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_func_proto_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_func_proto_paren, 294, 1)
        #--------------------------------------------
        self.label_sp_func_proto_paren_empty = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between function name and '()' on function declaration\nif empty.", "sp_func_proto_paren_empty")))
        self.label_sp_func_proto_paren_empty.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_func_proto_paren_empty, 295, 0, 1, 2)
        self.label_option_sp_func_proto_paren_empty = QtWidgets.QLabel("sp_func_proto_paren_empty")
        self.label_option_sp_func_proto_paren_empty.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_func_proto_paren_empty, 296, 0)
        self.option_sp_func_proto_paren_empty =  QtWidgets.QComboBox()
        self.option_sp_func_proto_paren_empty.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_func_proto_paren_empty.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_func_proto_paren_empty, 296, 1)
        #--------------------------------------------
        self.label_sp_func_type_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between function name and '(' with a typedef specifier.", "sp_func_type_paren")))
        self.label_sp_func_type_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_func_type_paren, 297, 0, 1, 2)
        self.label_option_sp_func_type_paren = QtWidgets.QLabel("sp_func_type_paren")
        self.label_option_sp_func_type_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_func_type_paren, 298, 0)
        self.option_sp_func_type_paren =  QtWidgets.QComboBox()
        self.option_sp_func_type_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_func_type_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_func_type_paren, 298, 1)
        #--------------------------------------------
        self.label_sp_func_def_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between alias name and '(' of a non-pointer function type typedef.", "sp_func_def_paren")))
        self.label_sp_func_def_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_func_def_paren, 299, 0, 1, 2)
        self.label_option_sp_func_def_paren = QtWidgets.QLabel("sp_func_def_paren")
        self.label_option_sp_func_def_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_func_def_paren, 300, 0)
        self.option_sp_func_def_paren =  QtWidgets.QComboBox()
        self.option_sp_func_def_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_func_def_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_func_def_paren, 300, 1)
        #--------------------------------------------
        self.label_sp_func_def_paren_empty = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between function name and '()' on function definition\nif empty.", "sp_func_def_paren_empty")))
        self.label_sp_func_def_paren_empty.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_func_def_paren_empty, 301, 0, 1, 2)
        self.label_option_sp_func_def_paren_empty = QtWidgets.QLabel("sp_func_def_paren_empty")
        self.label_option_sp_func_def_paren_empty.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_func_def_paren_empty, 302, 0)
        self.option_sp_func_def_paren_empty =  QtWidgets.QComboBox()
        self.option_sp_func_def_paren_empty.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_func_def_paren_empty.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_func_def_paren_empty, 302, 1)
        #--------------------------------------------
        self.label_sp_inside_fparens = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space inside empty function '()'.\nOverrides sp_after_angle unless use_sp_after_angle_always is set to true.", "sp_inside_fparens")))
        self.label_sp_inside_fparens.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_fparens, 303, 0, 1, 2)
        self.label_option_sp_inside_fparens = QtWidgets.QLabel("sp_inside_fparens")
        self.label_option_sp_inside_fparens.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_fparens, 304, 0)
        self.option_sp_inside_fparens =  QtWidgets.QComboBox()
        self.option_sp_inside_fparens.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_fparens.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_fparens, 304, 1)
        #--------------------------------------------
        self.label_sp_inside_fparen = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space inside function '(' and ')'.", "sp_inside_fparen")))
        self.label_sp_inside_fparen.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_fparen, 305, 0, 1, 2)
        self.label_option_sp_inside_fparen = QtWidgets.QLabel("sp_inside_fparen")
        self.label_option_sp_inside_fparen.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_fparen, 306, 0)
        self.option_sp_inside_fparen =  QtWidgets.QComboBox()
        self.option_sp_inside_fparen.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_fparen.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_fparen, 306, 1)
        #--------------------------------------------
        self.label_sp_func_call_user_inside_rparen = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space inside user functor '(' and ')'.", "sp_func_call_user_inside_rparen")))
        self.label_sp_func_call_user_inside_rparen.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_func_call_user_inside_rparen, 307, 0, 1, 2)
        self.label_option_sp_func_call_user_inside_rparen = QtWidgets.QLabel("sp_func_call_user_inside_rparen")
        self.label_option_sp_func_call_user_inside_rparen.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_func_call_user_inside_rparen, 308, 0)
        self.option_sp_func_call_user_inside_rparen =  QtWidgets.QComboBox()
        self.option_sp_func_call_user_inside_rparen.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_func_call_user_inside_rparen.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_func_call_user_inside_rparen, 308, 1)
        #--------------------------------------------
        self.label_sp_inside_rparens = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space inside empty functor '()'.\nOverrides sp_after_angle unless use_sp_after_angle_always is set to true.", "sp_inside_rparens")))
        self.label_sp_inside_rparens.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_rparens, 309, 0, 1, 2)
        self.label_option_sp_inside_rparens = QtWidgets.QLabel("sp_inside_rparens")
        self.label_option_sp_inside_rparens.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_rparens, 310, 0)
        self.option_sp_inside_rparens =  QtWidgets.QComboBox()
        self.option_sp_inside_rparens.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_rparens.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_rparens, 310, 1)
        #--------------------------------------------
        self.label_sp_inside_rparen = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space inside functor '(' and ')'.", "sp_inside_rparen")))
        self.label_sp_inside_rparen.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_rparen, 311, 0, 1, 2)
        self.label_option_sp_inside_rparen = QtWidgets.QLabel("sp_inside_rparen")
        self.label_option_sp_inside_rparen.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_rparen, 312, 0)
        self.option_sp_inside_rparen =  QtWidgets.QComboBox()
        self.option_sp_inside_rparen.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_rparen.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_rparen, 312, 1)
        #--------------------------------------------
        self.label_sp_inside_tparen = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space inside the first parentheses in a function type, as in\n'void (*x)(...)'.", "sp_inside_tparen")))
        self.label_sp_inside_tparen.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_tparen, 313, 0, 1, 2)
        self.label_option_sp_inside_tparen = QtWidgets.QLabel("sp_inside_tparen")
        self.label_option_sp_inside_tparen.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_tparen, 314, 0)
        self.option_sp_inside_tparen =  QtWidgets.QComboBox()
        self.option_sp_inside_tparen.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_tparen.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_tparen, 314, 1)
        #--------------------------------------------
        self.label_sp_after_tparen_close = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between the ')' and '(' in a function type, as in\n'void (*x)(...)'.", "sp_after_tparen_close")))
        self.label_sp_after_tparen_close.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_tparen_close, 315, 0, 1, 2)
        self.label_option_sp_after_tparen_close = QtWidgets.QLabel("sp_after_tparen_close")
        self.label_option_sp_after_tparen_close.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_tparen_close, 316, 0)
        self.option_sp_after_tparen_close =  QtWidgets.QComboBox()
        self.option_sp_after_tparen_close.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_tparen_close.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_tparen_close, 316, 1)
        #--------------------------------------------
        self.label_sp_square_fparen = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between ']' and '(' when part of a function call.", "sp_square_fparen")))
        self.label_sp_square_fparen.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_square_fparen, 317, 0, 1, 2)
        self.label_option_sp_square_fparen = QtWidgets.QLabel("sp_square_fparen")
        self.label_option_sp_square_fparen.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_square_fparen, 318, 0)
        self.option_sp_square_fparen =  QtWidgets.QComboBox()
        self.option_sp_square_fparen.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_square_fparen.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_square_fparen, 318, 1)
        #--------------------------------------------
        self.label_sp_fparen_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between ')' and '{' of function.", "sp_fparen_brace")))
        self.label_sp_fparen_brace.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_fparen_brace, 319, 0, 1, 2)
        self.label_option_sp_fparen_brace = QtWidgets.QLabel("sp_fparen_brace")
        self.label_option_sp_fparen_brace.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_fparen_brace, 320, 0)
        self.option_sp_fparen_brace =  QtWidgets.QComboBox()
        self.option_sp_fparen_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_fparen_brace.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_fparen_brace, 320, 1)
        #--------------------------------------------
        self.label_sp_fparen_brace_initializer = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between ')' and '{' of a function call in object\ninitialization.", "sp_fparen_brace_initializer")+"\n\n"+self.tr("Overrides sp_fparen_brace.", "sp_fparen_brace_initializer")))
        self.label_sp_fparen_brace_initializer.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_fparen_brace_initializer, 321, 0, 1, 2)
        self.label_option_sp_fparen_brace_initializer = QtWidgets.QLabel("sp_fparen_brace_initializer")
        self.label_option_sp_fparen_brace_initializer.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_fparen_brace_initializer, 322, 0)
        self.option_sp_fparen_brace_initializer =  QtWidgets.QComboBox()
        self.option_sp_fparen_brace_initializer.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_fparen_brace_initializer.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_fparen_brace_initializer, 322, 1)
        #--------------------------------------------
        self.label_sp_fparen_dbrace = QtWidgets.QLabel(label("<hr>"+self.tr("(Java) Add or remove space between ')' and '{{' of double brace initializer.", "sp_fparen_dbrace")))
        self.label_sp_fparen_dbrace.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_fparen_dbrace, 323, 0, 1, 2)
        self.label_option_sp_fparen_dbrace = QtWidgets.QLabel("sp_fparen_dbrace")
        self.label_option_sp_fparen_dbrace.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_fparen_dbrace, 324, 0)
        self.option_sp_fparen_dbrace =  QtWidgets.QComboBox()
        self.option_sp_fparen_dbrace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_fparen_dbrace.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_fparen_dbrace, 324, 1)
        #--------------------------------------------
        self.label_sp_func_call_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between function name and '(' on function calls.", "sp_func_call_paren")))
        self.label_sp_func_call_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_func_call_paren, 325, 0, 1, 2)
        self.label_option_sp_func_call_paren = QtWidgets.QLabel("sp_func_call_paren")
        self.label_option_sp_func_call_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_func_call_paren, 326, 0)
        self.option_sp_func_call_paren =  QtWidgets.QComboBox()
        self.option_sp_func_call_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_func_call_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_func_call_paren, 326, 1)
        #--------------------------------------------
        self.label_sp_func_call_paren_empty = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between function name and '()' on function calls without\nparameters. If set to ignore (the default), sp_func_call_paren is used.", "sp_func_call_paren_empty")))
        self.label_sp_func_call_paren_empty.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_func_call_paren_empty, 327, 0, 1, 2)
        self.label_option_sp_func_call_paren_empty = QtWidgets.QLabel("sp_func_call_paren_empty")
        self.label_option_sp_func_call_paren_empty.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_func_call_paren_empty, 328, 0)
        self.option_sp_func_call_paren_empty =  QtWidgets.QComboBox()
        self.option_sp_func_call_paren_empty.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_func_call_paren_empty.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_func_call_paren_empty, 328, 1)
        #--------------------------------------------
        self.label_sp_func_call_user_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between the user function name and '(' on function\ncalls. You need to set a keyword to be a user function in the config file,\nlike:\n  set func_call_user tr _ i18n", "sp_func_call_user_paren")))
        self.label_sp_func_call_user_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_func_call_user_paren, 329, 0, 1, 2)
        self.label_option_sp_func_call_user_paren = QtWidgets.QLabel("sp_func_call_user_paren")
        self.label_option_sp_func_call_user_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_func_call_user_paren, 330, 0)
        self.option_sp_func_call_user_paren =  QtWidgets.QComboBox()
        self.option_sp_func_call_user_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_func_call_user_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_func_call_user_paren, 330, 1)
        #--------------------------------------------
        self.label_sp_func_call_user_inside_fparen = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space inside user function '(' and ')'.", "sp_func_call_user_inside_fparen")))
        self.label_sp_func_call_user_inside_fparen.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_func_call_user_inside_fparen, 331, 0, 1, 2)
        self.label_option_sp_func_call_user_inside_fparen = QtWidgets.QLabel("sp_func_call_user_inside_fparen")
        self.label_option_sp_func_call_user_inside_fparen.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_func_call_user_inside_fparen, 332, 0)
        self.option_sp_func_call_user_inside_fparen =  QtWidgets.QComboBox()
        self.option_sp_func_call_user_inside_fparen.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_func_call_user_inside_fparen.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_func_call_user_inside_fparen, 332, 1)
        #--------------------------------------------
        self.label_sp_func_call_user_paren_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between nested parentheses with user functions,\ni.e. '((' vs. '( ('.", "sp_func_call_user_paren_paren")))
        self.label_sp_func_call_user_paren_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_func_call_user_paren_paren, 333, 0, 1, 2)
        self.label_option_sp_func_call_user_paren_paren = QtWidgets.QLabel("sp_func_call_user_paren_paren")
        self.label_option_sp_func_call_user_paren_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_func_call_user_paren_paren, 334, 0)
        self.option_sp_func_call_user_paren_paren =  QtWidgets.QComboBox()
        self.option_sp_func_call_user_paren_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_func_call_user_paren_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_func_call_user_paren_paren, 334, 1)
        #--------------------------------------------
        self.label_sp_func_class_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between a constructor/destructor and the open\nparenthesis.", "sp_func_class_paren")))
        self.label_sp_func_class_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_func_class_paren, 335, 0, 1, 2)
        self.label_option_sp_func_class_paren = QtWidgets.QLabel("sp_func_class_paren")
        self.label_option_sp_func_class_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_func_class_paren, 336, 0)
        self.option_sp_func_class_paren =  QtWidgets.QComboBox()
        self.option_sp_func_class_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_func_class_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_func_class_paren, 336, 1)
        #--------------------------------------------
        self.label_sp_func_class_paren_empty = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between a constructor without parameters or destructor\nand '()'.", "sp_func_class_paren_empty")))
        self.label_sp_func_class_paren_empty.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_func_class_paren_empty, 337, 0, 1, 2)
        self.label_option_sp_func_class_paren_empty = QtWidgets.QLabel("sp_func_class_paren_empty")
        self.label_option_sp_func_class_paren_empty.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_func_class_paren_empty, 338, 0)
        self.option_sp_func_class_paren_empty =  QtWidgets.QComboBox()
        self.option_sp_func_class_paren_empty.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_func_class_paren_empty.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_func_class_paren_empty, 338, 1)
        #--------------------------------------------
        self.label_sp_return = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after 'return'.", "sp_return")))
        self.label_sp_return.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_return, 339, 0, 1, 2)
        self.label_option_sp_return = QtWidgets.QLabel("sp_return")
        self.label_option_sp_return.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_return, 340, 0)
        self.option_sp_return =  QtWidgets.QComboBox()
        self.option_sp_return.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_return.setCurrentText("force")
        self.group_page_layout_2.addWidget(self.option_sp_return, 340, 1)
        #--------------------------------------------
        self.label_sp_return_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between 'return' and '('.", "sp_return_paren")))
        self.label_sp_return_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_return_paren, 341, 0, 1, 2)
        self.label_option_sp_return_paren = QtWidgets.QLabel("sp_return_paren")
        self.label_option_sp_return_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_return_paren, 342, 0)
        self.option_sp_return_paren =  QtWidgets.QComboBox()
        self.option_sp_return_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_return_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_return_paren, 342, 1)
        #--------------------------------------------
        self.label_sp_return_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between 'return' and '{'.", "sp_return_brace")))
        self.label_sp_return_brace.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_return_brace, 343, 0, 1, 2)
        self.label_option_sp_return_brace = QtWidgets.QLabel("sp_return_brace")
        self.label_option_sp_return_brace.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_return_brace, 344, 0)
        self.option_sp_return_brace =  QtWidgets.QComboBox()
        self.option_sp_return_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_return_brace.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_return_brace, 344, 1)
        #--------------------------------------------
        self.label_sp_attribute_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between '__attribute__' and '('.", "sp_attribute_paren")))
        self.label_sp_attribute_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_attribute_paren, 345, 0, 1, 2)
        self.label_option_sp_attribute_paren = QtWidgets.QLabel("sp_attribute_paren")
        self.label_option_sp_attribute_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_attribute_paren, 346, 0)
        self.option_sp_attribute_paren =  QtWidgets.QComboBox()
        self.option_sp_attribute_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_attribute_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_attribute_paren, 346, 1)
        #--------------------------------------------
        self.label_sp_defined_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between 'defined' and '(' in '#if defined (FOO)'.", "sp_defined_paren")))
        self.label_sp_defined_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_defined_paren, 347, 0, 1, 2)
        self.label_option_sp_defined_paren = QtWidgets.QLabel("sp_defined_paren")
        self.label_option_sp_defined_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_defined_paren, 348, 0)
        self.option_sp_defined_paren =  QtWidgets.QComboBox()
        self.option_sp_defined_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_defined_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_defined_paren, 348, 1)
        #--------------------------------------------
        self.label_sp_throw_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between 'throw' and '(' in 'throw (something)'.", "sp_throw_paren")))
        self.label_sp_throw_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_throw_paren, 349, 0, 1, 2)
        self.label_option_sp_throw_paren = QtWidgets.QLabel("sp_throw_paren")
        self.label_option_sp_throw_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_throw_paren, 350, 0)
        self.option_sp_throw_paren =  QtWidgets.QComboBox()
        self.option_sp_throw_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_throw_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_throw_paren, 350, 1)
        #--------------------------------------------
        self.label_sp_after_throw = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between 'throw' and anything other than '(' as in\n'@throw [...];'.", "sp_after_throw")))
        self.label_sp_after_throw.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_throw, 351, 0, 1, 2)
        self.label_option_sp_after_throw = QtWidgets.QLabel("sp_after_throw")
        self.label_option_sp_after_throw.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_throw, 352, 0)
        self.option_sp_after_throw =  QtWidgets.QComboBox()
        self.option_sp_after_throw.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_throw.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_throw, 352, 1)
        #--------------------------------------------
        self.label_sp_catch_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between 'catch' and '(' in 'catch (something) { }'.\nIf set to ignore, sp_before_sparen is used.", "sp_catch_paren")))
        self.label_sp_catch_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_catch_paren, 353, 0, 1, 2)
        self.label_option_sp_catch_paren = QtWidgets.QLabel("sp_catch_paren")
        self.label_option_sp_catch_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_catch_paren, 354, 0)
        self.option_sp_catch_paren =  QtWidgets.QComboBox()
        self.option_sp_catch_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_catch_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_catch_paren, 354, 1)
        #--------------------------------------------
        self.label_sp_oc_catch_paren = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space between '@catch' and '('\nin '@catch (something) { }'. If set to ignore, sp_catch_paren is used.", "sp_oc_catch_paren")))
        self.label_sp_oc_catch_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_oc_catch_paren, 355, 0, 1, 2)
        self.label_option_sp_oc_catch_paren = QtWidgets.QLabel("sp_oc_catch_paren")
        self.label_option_sp_oc_catch_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_oc_catch_paren, 356, 0)
        self.option_sp_oc_catch_paren =  QtWidgets.QComboBox()
        self.option_sp_oc_catch_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_oc_catch_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_oc_catch_paren, 356, 1)
        #--------------------------------------------
        self.label_sp_before_oc_proto_list = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space before Objective-C protocol list\nas in '@protocol Protocol<here><Protocol_A>' or '@interface MyClass : NSObject<here><MyProtocol>'.", "sp_before_oc_proto_list")))
        self.label_sp_before_oc_proto_list.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_oc_proto_list, 357, 0, 1, 2)
        self.label_option_sp_before_oc_proto_list = QtWidgets.QLabel("sp_before_oc_proto_list")
        self.label_option_sp_before_oc_proto_list.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_oc_proto_list, 358, 0)
        self.option_sp_before_oc_proto_list =  QtWidgets.QComboBox()
        self.option_sp_before_oc_proto_list.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_oc_proto_list.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_oc_proto_list, 358, 1)
        #--------------------------------------------
        self.label_sp_oc_classname_paren = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space between class name and '('\nin '@interface className(categoryName)<ProtocolName>:BaseClass'", "sp_oc_classname_paren")))
        self.label_sp_oc_classname_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_oc_classname_paren, 359, 0, 1, 2)
        self.label_option_sp_oc_classname_paren = QtWidgets.QLabel("sp_oc_classname_paren")
        self.label_option_sp_oc_classname_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_oc_classname_paren, 360, 0)
        self.option_sp_oc_classname_paren =  QtWidgets.QComboBox()
        self.option_sp_oc_classname_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_oc_classname_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_oc_classname_paren, 360, 1)
        #--------------------------------------------
        self.label_sp_version_paren = QtWidgets.QLabel(label("<hr>"+self.tr("(D) Add or remove space between 'version' and '('\nin 'version (something) { }'. If set to ignore, sp_before_sparen is used.", "sp_version_paren")))
        self.label_sp_version_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_version_paren, 361, 0, 1, 2)
        self.label_option_sp_version_paren = QtWidgets.QLabel("sp_version_paren")
        self.label_option_sp_version_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_version_paren, 362, 0)
        self.option_sp_version_paren =  QtWidgets.QComboBox()
        self.option_sp_version_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_version_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_version_paren, 362, 1)
        #--------------------------------------------
        self.label_sp_scope_paren = QtWidgets.QLabel(label("<hr>"+self.tr("(D) Add or remove space between 'scope' and '('\nin 'scope (something) { }'. If set to ignore, sp_before_sparen is used.", "sp_scope_paren")))
        self.label_sp_scope_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_scope_paren, 363, 0, 1, 2)
        self.label_option_sp_scope_paren = QtWidgets.QLabel("sp_scope_paren")
        self.label_option_sp_scope_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_scope_paren, 364, 0)
        self.option_sp_scope_paren =  QtWidgets.QComboBox()
        self.option_sp_scope_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_scope_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_scope_paren, 364, 1)
        #--------------------------------------------
        self.label_sp_super_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between 'super' and '(' in 'super (something)'.", "sp_super_paren")))
        self.label_sp_super_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_super_paren, 365, 0, 1, 2)
        self.label_option_sp_super_paren = QtWidgets.QLabel("sp_super_paren")
        self.label_option_sp_super_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_super_paren, 366, 0)
        self.option_sp_super_paren =  QtWidgets.QComboBox()
        self.option_sp_super_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_super_paren.setCurrentText("remove")
        self.group_page_layout_2.addWidget(self.option_sp_super_paren, 366, 1)
        #--------------------------------------------
        self.label_sp_this_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between 'this' and '(' in 'this (something)'.", "sp_this_paren")))
        self.label_sp_this_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_this_paren, 367, 0, 1, 2)
        self.label_option_sp_this_paren = QtWidgets.QLabel("sp_this_paren")
        self.label_option_sp_this_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_this_paren, 368, 0)
        self.option_sp_this_paren =  QtWidgets.QComboBox()
        self.option_sp_this_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_this_paren.setCurrentText("remove")
        self.group_page_layout_2.addWidget(self.option_sp_this_paren, 368, 1)
        #--------------------------------------------
        self.label_sp_macro = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between a macro name and its definition.", "sp_macro")))
        self.label_sp_macro.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_macro, 369, 0, 1, 2)
        self.label_option_sp_macro = QtWidgets.QLabel("sp_macro")
        self.label_option_sp_macro.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_macro, 370, 0)
        self.option_sp_macro =  QtWidgets.QComboBox()
        self.option_sp_macro.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_macro.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_macro, 370, 1)
        #--------------------------------------------
        self.label_sp_macro_func = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between a macro function ')' and its definition.", "sp_macro_func")))
        self.label_sp_macro_func.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_macro_func, 371, 0, 1, 2)
        self.label_option_sp_macro_func = QtWidgets.QLabel("sp_macro_func")
        self.label_option_sp_macro_func.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_macro_func, 372, 0)
        self.option_sp_macro_func =  QtWidgets.QComboBox()
        self.option_sp_macro_func.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_macro_func.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_macro_func, 372, 1)
        #--------------------------------------------
        self.label_sp_else_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between 'else' and '{' if on the same line.", "sp_else_brace")))
        self.label_sp_else_brace.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_else_brace, 373, 0, 1, 2)
        self.label_option_sp_else_brace = QtWidgets.QLabel("sp_else_brace")
        self.label_option_sp_else_brace.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_else_brace, 374, 0)
        self.option_sp_else_brace =  QtWidgets.QComboBox()
        self.option_sp_else_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_else_brace.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_else_brace, 374, 1)
        #--------------------------------------------
        self.label_sp_brace_else = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between '}' and 'else' if on the same line.", "sp_brace_else")))
        self.label_sp_brace_else.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_brace_else, 375, 0, 1, 2)
        self.label_option_sp_brace_else = QtWidgets.QLabel("sp_brace_else")
        self.label_option_sp_brace_else.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_brace_else, 376, 0)
        self.option_sp_brace_else =  QtWidgets.QComboBox()
        self.option_sp_brace_else.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_brace_else.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_brace_else, 376, 1)
        #--------------------------------------------
        self.label_sp_brace_typedef = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between '}' and the name of a typedef on the same line.", "sp_brace_typedef")))
        self.label_sp_brace_typedef.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_brace_typedef, 377, 0, 1, 2)
        self.label_option_sp_brace_typedef = QtWidgets.QLabel("sp_brace_typedef")
        self.label_option_sp_brace_typedef.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_brace_typedef, 378, 0)
        self.option_sp_brace_typedef =  QtWidgets.QComboBox()
        self.option_sp_brace_typedef.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_brace_typedef.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_brace_typedef, 378, 1)
        #--------------------------------------------
        self.label_sp_catch_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before the '{' of a 'catch' statement, if the '{' and\n'catch' are on the same line, as in 'catch (decl) <here> {'.", "sp_catch_brace")))
        self.label_sp_catch_brace.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_catch_brace, 379, 0, 1, 2)
        self.label_option_sp_catch_brace = QtWidgets.QLabel("sp_catch_brace")
        self.label_option_sp_catch_brace.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_catch_brace, 380, 0)
        self.option_sp_catch_brace =  QtWidgets.QComboBox()
        self.option_sp_catch_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_catch_brace.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_catch_brace, 380, 1)
        #--------------------------------------------
        self.label_sp_oc_catch_brace = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space before the '{' of a '@catch' statement, if the '{'\nand '@catch' are on the same line, as in '@catch (decl) <here> {'.\nIf set to ignore, sp_catch_brace is used.", "sp_oc_catch_brace")))
        self.label_sp_oc_catch_brace.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_oc_catch_brace, 381, 0, 1, 2)
        self.label_option_sp_oc_catch_brace = QtWidgets.QLabel("sp_oc_catch_brace")
        self.label_option_sp_oc_catch_brace.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_oc_catch_brace, 382, 0)
        self.option_sp_oc_catch_brace =  QtWidgets.QComboBox()
        self.option_sp_oc_catch_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_oc_catch_brace.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_oc_catch_brace, 382, 1)
        #--------------------------------------------
        self.label_sp_brace_catch = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between '}' and 'catch' if on the same line.", "sp_brace_catch")))
        self.label_sp_brace_catch.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_brace_catch, 383, 0, 1, 2)
        self.label_option_sp_brace_catch = QtWidgets.QLabel("sp_brace_catch")
        self.label_option_sp_brace_catch.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_brace_catch, 384, 0)
        self.option_sp_brace_catch =  QtWidgets.QComboBox()
        self.option_sp_brace_catch.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_brace_catch.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_brace_catch, 384, 1)
        #--------------------------------------------
        self.label_sp_oc_brace_catch = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space between '}' and '@catch' if on the same line.\nIf set to ignore, sp_brace_catch is used.", "sp_oc_brace_catch")))
        self.label_sp_oc_brace_catch.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_oc_brace_catch, 385, 0, 1, 2)
        self.label_option_sp_oc_brace_catch = QtWidgets.QLabel("sp_oc_brace_catch")
        self.label_option_sp_oc_brace_catch.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_oc_brace_catch, 386, 0)
        self.option_sp_oc_brace_catch =  QtWidgets.QComboBox()
        self.option_sp_oc_brace_catch.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_oc_brace_catch.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_oc_brace_catch, 386, 1)
        #--------------------------------------------
        self.label_sp_finally_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between 'finally' and '{' if on the same line.", "sp_finally_brace")))
        self.label_sp_finally_brace.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_finally_brace, 387, 0, 1, 2)
        self.label_option_sp_finally_brace = QtWidgets.QLabel("sp_finally_brace")
        self.label_option_sp_finally_brace.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_finally_brace, 388, 0)
        self.option_sp_finally_brace =  QtWidgets.QComboBox()
        self.option_sp_finally_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_finally_brace.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_finally_brace, 388, 1)
        #--------------------------------------------
        self.label_sp_brace_finally = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between '}' and 'finally' if on the same line.", "sp_brace_finally")))
        self.label_sp_brace_finally.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_brace_finally, 389, 0, 1, 2)
        self.label_option_sp_brace_finally = QtWidgets.QLabel("sp_brace_finally")
        self.label_option_sp_brace_finally.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_brace_finally, 390, 0)
        self.option_sp_brace_finally =  QtWidgets.QComboBox()
        self.option_sp_brace_finally.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_brace_finally.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_brace_finally, 390, 1)
        #--------------------------------------------
        self.label_sp_try_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between 'try' and '{' if on the same line.", "sp_try_brace")))
        self.label_sp_try_brace.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_try_brace, 391, 0, 1, 2)
        self.label_option_sp_try_brace = QtWidgets.QLabel("sp_try_brace")
        self.label_option_sp_try_brace.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_try_brace, 392, 0)
        self.option_sp_try_brace =  QtWidgets.QComboBox()
        self.option_sp_try_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_try_brace.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_try_brace, 392, 1)
        #--------------------------------------------
        self.label_sp_getset_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between get/set and '{' if on the same line.", "sp_getset_brace")))
        self.label_sp_getset_brace.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_getset_brace, 393, 0, 1, 2)
        self.label_option_sp_getset_brace = QtWidgets.QLabel("sp_getset_brace")
        self.label_option_sp_getset_brace.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_getset_brace, 394, 0)
        self.option_sp_getset_brace =  QtWidgets.QComboBox()
        self.option_sp_getset_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_getset_brace.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_getset_brace, 394, 1)
        #--------------------------------------------
        self.label_sp_word_brace_init_lst = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between a variable and '{' for C++ uniform\ninitialization.", "sp_word_brace_init_lst")))
        self.label_sp_word_brace_init_lst.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_word_brace_init_lst, 395, 0, 1, 2)
        self.label_option_sp_word_brace_init_lst = QtWidgets.QLabel("sp_word_brace_init_lst")
        self.label_option_sp_word_brace_init_lst.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_word_brace_init_lst, 396, 0)
        self.option_sp_word_brace_init_lst =  QtWidgets.QComboBox()
        self.option_sp_word_brace_init_lst.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_word_brace_init_lst.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_word_brace_init_lst, 396, 1)
        #--------------------------------------------
        self.label_sp_word_brace_ns = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between a variable and '{' for a namespace.", "sp_word_brace_ns")))
        self.label_sp_word_brace_ns.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_word_brace_ns, 397, 0, 1, 2)
        self.label_option_sp_word_brace_ns = QtWidgets.QLabel("sp_word_brace_ns")
        self.label_option_sp_word_brace_ns.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_word_brace_ns, 398, 0)
        self.option_sp_word_brace_ns =  QtWidgets.QComboBox()
        self.option_sp_word_brace_ns.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_word_brace_ns.setCurrentText("add")
        self.group_page_layout_2.addWidget(self.option_sp_word_brace_ns, 398, 1)
        #--------------------------------------------
        self.label_sp_before_dc = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before the '::' operator.", "sp_before_dc")))
        self.label_sp_before_dc.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_dc, 399, 0, 1, 2)
        self.label_option_sp_before_dc = QtWidgets.QLabel("sp_before_dc")
        self.label_option_sp_before_dc.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_dc, 400, 0)
        self.option_sp_before_dc =  QtWidgets.QComboBox()
        self.option_sp_before_dc.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_dc.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_dc, 400, 1)
        #--------------------------------------------
        self.label_sp_after_dc = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after the '::' operator.", "sp_after_dc")))
        self.label_sp_after_dc.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_dc, 401, 0, 1, 2)
        self.label_option_sp_after_dc = QtWidgets.QLabel("sp_after_dc")
        self.label_option_sp_after_dc.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_dc, 402, 0)
        self.option_sp_after_dc =  QtWidgets.QComboBox()
        self.option_sp_after_dc.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_dc.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_dc, 402, 1)
        #--------------------------------------------
        self.label_sp_d_array_colon = QtWidgets.QLabel(label("<hr>"+self.tr("(D) Add or remove around the D named array initializer ':' operator.", "sp_d_array_colon")))
        self.label_sp_d_array_colon.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_d_array_colon, 403, 0, 1, 2)
        self.label_option_sp_d_array_colon = QtWidgets.QLabel("sp_d_array_colon")
        self.label_option_sp_d_array_colon.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_d_array_colon, 404, 0)
        self.option_sp_d_array_colon =  QtWidgets.QComboBox()
        self.option_sp_d_array_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_d_array_colon.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_d_array_colon, 404, 1)
        #--------------------------------------------
        self.label_sp_not = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after the '!' (not) unary operator.", "sp_not")))
        self.label_sp_not.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_not, 405, 0, 1, 2)
        self.label_option_sp_not = QtWidgets.QLabel("sp_not")
        self.label_option_sp_not.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_not, 406, 0)
        self.option_sp_not =  QtWidgets.QComboBox()
        self.option_sp_not.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_not.setCurrentText("remove")
        self.group_page_layout_2.addWidget(self.option_sp_not, 406, 1)
        #--------------------------------------------
        self.label_sp_not_not = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between two '!' (not) unary operators.\nIf set to ignore, sp_not will be used.", "sp_not_not")))
        self.label_sp_not_not.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_not_not, 407, 0, 1, 2)
        self.label_option_sp_not_not = QtWidgets.QLabel("sp_not_not")
        self.label_option_sp_not_not.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_not_not, 408, 0)
        self.option_sp_not_not =  QtWidgets.QComboBox()
        self.option_sp_not_not.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_not_not.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_not_not, 408, 1)
        #--------------------------------------------
        self.label_sp_inv = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after the '~' (invert) unary operator.", "sp_inv")))
        self.label_sp_inv.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inv, 409, 0, 1, 2)
        self.label_option_sp_inv = QtWidgets.QLabel("sp_inv")
        self.label_option_sp_inv.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inv, 410, 0)
        self.option_sp_inv =  QtWidgets.QComboBox()
        self.option_sp_inv.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inv.setCurrentText("remove")
        self.group_page_layout_2.addWidget(self.option_sp_inv, 410, 1)
        #--------------------------------------------
        self.label_sp_addr = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after the '&' (address-of) unary operator. This does not\naffect the spacing after a '&' that is part of a type.", "sp_addr")))
        self.label_sp_addr.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_addr, 411, 0, 1, 2)
        self.label_option_sp_addr = QtWidgets.QLabel("sp_addr")
        self.label_option_sp_addr.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_addr, 412, 0)
        self.option_sp_addr =  QtWidgets.QComboBox()
        self.option_sp_addr.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_addr.setCurrentText("remove")
        self.group_page_layout_2.addWidget(self.option_sp_addr, 412, 1)
        #--------------------------------------------
        self.label_sp_member = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space around the '.' or '->' operators.", "sp_member")))
        self.label_sp_member.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_member, 413, 0, 1, 2)
        self.label_option_sp_member = QtWidgets.QLabel("sp_member")
        self.label_option_sp_member.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_member, 414, 0)
        self.option_sp_member =  QtWidgets.QComboBox()
        self.option_sp_member.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_member.setCurrentText("remove")
        self.group_page_layout_2.addWidget(self.option_sp_member, 414, 1)
        #--------------------------------------------
        self.label_sp_deref = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after the '*' (dereference) unary operator. This does\nnot affect the spacing after a '*' that is part of a type.", "sp_deref")))
        self.label_sp_deref.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_deref, 415, 0, 1, 2)
        self.label_option_sp_deref = QtWidgets.QLabel("sp_deref")
        self.label_option_sp_deref.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_deref, 416, 0)
        self.option_sp_deref =  QtWidgets.QComboBox()
        self.option_sp_deref.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_deref.setCurrentText("remove")
        self.group_page_layout_2.addWidget(self.option_sp_deref, 416, 1)
        #--------------------------------------------
        self.label_sp_sign = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after '+' or '-', as in 'x = -5' or 'y = +7'.", "sp_sign")))
        self.label_sp_sign.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_sign, 417, 0, 1, 2)
        self.label_option_sp_sign = QtWidgets.QLabel("sp_sign")
        self.label_option_sp_sign.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_sign, 418, 0)
        self.option_sp_sign =  QtWidgets.QComboBox()
        self.option_sp_sign.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_sign.setCurrentText("remove")
        self.group_page_layout_2.addWidget(self.option_sp_sign, 418, 1)
        #--------------------------------------------
        self.label_sp_incdec = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between '++' and '--' the word to which it is being\napplied, as in '(--x)' or 'y++;'.", "sp_incdec")))
        self.label_sp_incdec.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_incdec, 419, 0, 1, 2)
        self.label_option_sp_incdec = QtWidgets.QLabel("sp_incdec")
        self.label_option_sp_incdec.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_incdec, 420, 0)
        self.option_sp_incdec =  QtWidgets.QComboBox()
        self.option_sp_incdec.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_incdec.setCurrentText("remove")
        self.group_page_layout_2.addWidget(self.option_sp_incdec, 420, 1)
        #--------------------------------------------
        self.label_sp_before_nl_cont = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before a backslash-newline at the end of a line.", "sp_before_nl_cont")))
        self.label_sp_before_nl_cont.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_nl_cont, 421, 0, 1, 2)
        self.label_option_sp_before_nl_cont = QtWidgets.QLabel("sp_before_nl_cont")
        self.label_option_sp_before_nl_cont.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_nl_cont, 422, 0)
        self.option_sp_before_nl_cont =  QtWidgets.QComboBox()
        self.option_sp_before_nl_cont.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_nl_cont.setCurrentText("add")
        self.group_page_layout_2.addWidget(self.option_sp_before_nl_cont, 422, 1)
        #--------------------------------------------
        self.label_sp_after_oc_scope = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space after the scope '+' or '-', as in '-(void) foo;'\nor '+(int) bar;'.", "sp_after_oc_scope")))
        self.label_sp_after_oc_scope.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_oc_scope, 423, 0, 1, 2)
        self.label_option_sp_after_oc_scope = QtWidgets.QLabel("sp_after_oc_scope")
        self.label_option_sp_after_oc_scope.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_oc_scope, 424, 0)
        self.option_sp_after_oc_scope =  QtWidgets.QComboBox()
        self.option_sp_after_oc_scope.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_oc_scope.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_oc_scope, 424, 1)
        #--------------------------------------------
        self.label_sp_after_oc_colon = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space after the colon in message specs,\ni.e. '-(int) f:(int) x;' vs. '-(int) f: (int) x;'.", "sp_after_oc_colon")))
        self.label_sp_after_oc_colon.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_oc_colon, 425, 0, 1, 2)
        self.label_option_sp_after_oc_colon = QtWidgets.QLabel("sp_after_oc_colon")
        self.label_option_sp_after_oc_colon.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_oc_colon, 426, 0)
        self.option_sp_after_oc_colon =  QtWidgets.QComboBox()
        self.option_sp_after_oc_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_oc_colon.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_oc_colon, 426, 1)
        #--------------------------------------------
        self.label_sp_before_oc_colon = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space before the colon in message specs,\ni.e. '-(int) f: (int) x;' vs. '-(int) f : (int) x;'.", "sp_before_oc_colon")))
        self.label_sp_before_oc_colon.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_oc_colon, 427, 0, 1, 2)
        self.label_option_sp_before_oc_colon = QtWidgets.QLabel("sp_before_oc_colon")
        self.label_option_sp_before_oc_colon.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_oc_colon, 428, 0)
        self.option_sp_before_oc_colon =  QtWidgets.QComboBox()
        self.option_sp_before_oc_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_oc_colon.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_oc_colon, 428, 1)
        #--------------------------------------------
        self.label_sp_after_oc_dict_colon = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space after the colon in immutable dictionary expression\n'NSDictionary *test = @{@\"foo\" :@\"bar\"};'.", "sp_after_oc_dict_colon")))
        self.label_sp_after_oc_dict_colon.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_oc_dict_colon, 429, 0, 1, 2)
        self.label_option_sp_after_oc_dict_colon = QtWidgets.QLabel("sp_after_oc_dict_colon")
        self.label_option_sp_after_oc_dict_colon.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_oc_dict_colon, 430, 0)
        self.option_sp_after_oc_dict_colon =  QtWidgets.QComboBox()
        self.option_sp_after_oc_dict_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_oc_dict_colon.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_oc_dict_colon, 430, 1)
        #--------------------------------------------
        self.label_sp_before_oc_dict_colon = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space before the colon in immutable dictionary expression\n'NSDictionary *test = @{@\"foo\" :@\"bar\"};'.", "sp_before_oc_dict_colon")))
        self.label_sp_before_oc_dict_colon.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_oc_dict_colon, 431, 0, 1, 2)
        self.label_option_sp_before_oc_dict_colon = QtWidgets.QLabel("sp_before_oc_dict_colon")
        self.label_option_sp_before_oc_dict_colon.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_oc_dict_colon, 432, 0)
        self.option_sp_before_oc_dict_colon =  QtWidgets.QComboBox()
        self.option_sp_before_oc_dict_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_oc_dict_colon.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_oc_dict_colon, 432, 1)
        #--------------------------------------------
        self.label_sp_after_send_oc_colon = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space after the colon in message specs,\ni.e. '[object setValue:1];' vs. '[object setValue: 1];'.", "sp_after_send_oc_colon")))
        self.label_sp_after_send_oc_colon.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_send_oc_colon, 433, 0, 1, 2)
        self.label_option_sp_after_send_oc_colon = QtWidgets.QLabel("sp_after_send_oc_colon")
        self.label_option_sp_after_send_oc_colon.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_send_oc_colon, 434, 0)
        self.option_sp_after_send_oc_colon =  QtWidgets.QComboBox()
        self.option_sp_after_send_oc_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_send_oc_colon.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_send_oc_colon, 434, 1)
        #--------------------------------------------
        self.label_sp_before_send_oc_colon = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space before the colon in message specs,\ni.e. '[object setValue:1];' vs. '[object setValue :1];'.", "sp_before_send_oc_colon")))
        self.label_sp_before_send_oc_colon.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_send_oc_colon, 435, 0, 1, 2)
        self.label_option_sp_before_send_oc_colon = QtWidgets.QLabel("sp_before_send_oc_colon")
        self.label_option_sp_before_send_oc_colon.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_send_oc_colon, 436, 0)
        self.option_sp_before_send_oc_colon =  QtWidgets.QComboBox()
        self.option_sp_before_send_oc_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_send_oc_colon.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_send_oc_colon, 436, 1)
        #--------------------------------------------
        self.label_sp_after_oc_type = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space after the (type) in message specs,\ni.e. '-(int)f: (int) x;' vs. '-(int)f: (int)x;'.", "sp_after_oc_type")))
        self.label_sp_after_oc_type.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_oc_type, 437, 0, 1, 2)
        self.label_option_sp_after_oc_type = QtWidgets.QLabel("sp_after_oc_type")
        self.label_option_sp_after_oc_type.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_oc_type, 438, 0)
        self.option_sp_after_oc_type =  QtWidgets.QComboBox()
        self.option_sp_after_oc_type.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_oc_type.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_oc_type, 438, 1)
        #--------------------------------------------
        self.label_sp_after_oc_return_type = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space after the first (type) in message specs,\ni.e. '-(int) f:(int)x;' vs. '-(int)f:(int)x;'.", "sp_after_oc_return_type")))
        self.label_sp_after_oc_return_type.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_oc_return_type, 439, 0, 1, 2)
        self.label_option_sp_after_oc_return_type = QtWidgets.QLabel("sp_after_oc_return_type")
        self.label_option_sp_after_oc_return_type.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_oc_return_type, 440, 0)
        self.option_sp_after_oc_return_type =  QtWidgets.QComboBox()
        self.option_sp_after_oc_return_type.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_oc_return_type.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_oc_return_type, 440, 1)
        #--------------------------------------------
        self.label_sp_after_oc_at_sel = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space between '@selector' and '(',\ni.e. '@selector(msgName)' vs. '@selector (msgName)'.\nAlso applies to '@protocol()' constructs.", "sp_after_oc_at_sel")))
        self.label_sp_after_oc_at_sel.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_oc_at_sel, 441, 0, 1, 2)
        self.label_option_sp_after_oc_at_sel = QtWidgets.QLabel("sp_after_oc_at_sel")
        self.label_option_sp_after_oc_at_sel.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_oc_at_sel, 442, 0)
        self.option_sp_after_oc_at_sel =  QtWidgets.QComboBox()
        self.option_sp_after_oc_at_sel.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_oc_at_sel.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_oc_at_sel, 442, 1)
        #--------------------------------------------
        self.label_sp_after_oc_at_sel_parens = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space between '@selector(x)' and the following word,\ni.e. '@selector(foo) a:' vs. '@selector(foo)a:'.", "sp_after_oc_at_sel_parens")))
        self.label_sp_after_oc_at_sel_parens.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_oc_at_sel_parens, 443, 0, 1, 2)
        self.label_option_sp_after_oc_at_sel_parens = QtWidgets.QLabel("sp_after_oc_at_sel_parens")
        self.label_option_sp_after_oc_at_sel_parens.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_oc_at_sel_parens, 444, 0)
        self.option_sp_after_oc_at_sel_parens =  QtWidgets.QComboBox()
        self.option_sp_after_oc_at_sel_parens.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_oc_at_sel_parens.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_oc_at_sel_parens, 444, 1)
        #--------------------------------------------
        self.label_sp_inside_oc_at_sel_parens = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space inside '@selector' parentheses,\ni.e. '@selector(foo)' vs. '@selector( foo )'.\nAlso applies to '@protocol()' constructs.", "sp_inside_oc_at_sel_parens")))
        self.label_sp_inside_oc_at_sel_parens.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_oc_at_sel_parens, 445, 0, 1, 2)
        self.label_option_sp_inside_oc_at_sel_parens = QtWidgets.QLabel("sp_inside_oc_at_sel_parens")
        self.label_option_sp_inside_oc_at_sel_parens.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_oc_at_sel_parens, 446, 0)
        self.option_sp_inside_oc_at_sel_parens =  QtWidgets.QComboBox()
        self.option_sp_inside_oc_at_sel_parens.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_oc_at_sel_parens.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_oc_at_sel_parens, 446, 1)
        #--------------------------------------------
        self.label_sp_before_oc_block_caret = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space before a block pointer caret,\ni.e. '^int (int arg){...}' vs. ' ^int (int arg){...}'.", "sp_before_oc_block_caret")))
        self.label_sp_before_oc_block_caret.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_oc_block_caret, 447, 0, 1, 2)
        self.label_option_sp_before_oc_block_caret = QtWidgets.QLabel("sp_before_oc_block_caret")
        self.label_option_sp_before_oc_block_caret.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_oc_block_caret, 448, 0)
        self.option_sp_before_oc_block_caret =  QtWidgets.QComboBox()
        self.option_sp_before_oc_block_caret.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_oc_block_caret.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_oc_block_caret, 448, 1)
        #--------------------------------------------
        self.label_sp_after_oc_block_caret = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space after a block pointer caret,\ni.e. '^int (int arg){...}' vs. '^ int (int arg){...}'.", "sp_after_oc_block_caret")))
        self.label_sp_after_oc_block_caret.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_oc_block_caret, 449, 0, 1, 2)
        self.label_option_sp_after_oc_block_caret = QtWidgets.QLabel("sp_after_oc_block_caret")
        self.label_option_sp_after_oc_block_caret.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_oc_block_caret, 450, 0)
        self.option_sp_after_oc_block_caret =  QtWidgets.QComboBox()
        self.option_sp_after_oc_block_caret.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_oc_block_caret.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_oc_block_caret, 450, 1)
        #--------------------------------------------
        self.label_sp_after_oc_msg_receiver = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space between the receiver and selector in a message,\nas in '[receiver selector ...]'.", "sp_after_oc_msg_receiver")))
        self.label_sp_after_oc_msg_receiver.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_oc_msg_receiver, 451, 0, 1, 2)
        self.label_option_sp_after_oc_msg_receiver = QtWidgets.QLabel("sp_after_oc_msg_receiver")
        self.label_option_sp_after_oc_msg_receiver.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_oc_msg_receiver, 452, 0)
        self.option_sp_after_oc_msg_receiver =  QtWidgets.QComboBox()
        self.option_sp_after_oc_msg_receiver.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_oc_msg_receiver.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_oc_msg_receiver, 452, 1)
        #--------------------------------------------
        self.label_sp_after_oc_property = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space after '@property'.", "sp_after_oc_property")))
        self.label_sp_after_oc_property.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_oc_property, 453, 0, 1, 2)
        self.label_option_sp_after_oc_property = QtWidgets.QLabel("sp_after_oc_property")
        self.label_option_sp_after_oc_property.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_oc_property, 454, 0)
        self.option_sp_after_oc_property =  QtWidgets.QComboBox()
        self.option_sp_after_oc_property.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_oc_property.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_oc_property, 454, 1)
        #--------------------------------------------
        self.label_sp_after_oc_synchronized = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove space between '@synchronized' and the open parenthesis,\ni.e. '@synchronized(foo)' vs. '@synchronized (foo)'.", "sp_after_oc_synchronized")))
        self.label_sp_after_oc_synchronized.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_oc_synchronized, 455, 0, 1, 2)
        self.label_option_sp_after_oc_synchronized = QtWidgets.QLabel("sp_after_oc_synchronized")
        self.label_option_sp_after_oc_synchronized.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_oc_synchronized, 456, 0)
        self.option_sp_after_oc_synchronized =  QtWidgets.QComboBox()
        self.option_sp_after_oc_synchronized.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_oc_synchronized.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_oc_synchronized, 456, 1)
        #--------------------------------------------
        self.label_sp_cond_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space around the ':' in 'b ? t : f'.", "sp_cond_colon")))
        self.label_sp_cond_colon.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cond_colon, 457, 0, 1, 2)
        self.label_option_sp_cond_colon = QtWidgets.QLabel("sp_cond_colon")
        self.label_option_sp_cond_colon.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cond_colon, 458, 0)
        self.option_sp_cond_colon =  QtWidgets.QComboBox()
        self.option_sp_cond_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_cond_colon.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_cond_colon, 458, 1)
        #--------------------------------------------
        self.label_sp_cond_colon_before = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before the ':' in 'b ? t : f'.", "sp_cond_colon_before")+"\n\n"+self.tr("Overrides sp_cond_colon.", "sp_cond_colon_before")))
        self.label_sp_cond_colon_before.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cond_colon_before, 459, 0, 1, 2)
        self.label_option_sp_cond_colon_before = QtWidgets.QLabel("sp_cond_colon_before")
        self.label_option_sp_cond_colon_before.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cond_colon_before, 460, 0)
        self.option_sp_cond_colon_before =  QtWidgets.QComboBox()
        self.option_sp_cond_colon_before.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_cond_colon_before.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_cond_colon_before, 460, 1)
        #--------------------------------------------
        self.label_sp_cond_colon_after = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after the ':' in 'b ? t : f'.", "sp_cond_colon_after")+"\n\n"+self.tr("Overrides sp_cond_colon.", "sp_cond_colon_after")))
        self.label_sp_cond_colon_after.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cond_colon_after, 461, 0, 1, 2)
        self.label_option_sp_cond_colon_after = QtWidgets.QLabel("sp_cond_colon_after")
        self.label_option_sp_cond_colon_after.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cond_colon_after, 462, 0)
        self.option_sp_cond_colon_after =  QtWidgets.QComboBox()
        self.option_sp_cond_colon_after.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_cond_colon_after.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_cond_colon_after, 462, 1)
        #--------------------------------------------
        self.label_sp_cond_question = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space around the '?' in 'b ? t : f'.", "sp_cond_question")))
        self.label_sp_cond_question.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cond_question, 463, 0, 1, 2)
        self.label_option_sp_cond_question = QtWidgets.QLabel("sp_cond_question")
        self.label_option_sp_cond_question.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cond_question, 464, 0)
        self.option_sp_cond_question =  QtWidgets.QComboBox()
        self.option_sp_cond_question.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_cond_question.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_cond_question, 464, 1)
        #--------------------------------------------
        self.label_sp_cond_question_before = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before the '?' in 'b ? t : f'.", "sp_cond_question_before")+"\n\n"+self.tr("Overrides sp_cond_question.", "sp_cond_question_before")))
        self.label_sp_cond_question_before.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cond_question_before, 465, 0, 1, 2)
        self.label_option_sp_cond_question_before = QtWidgets.QLabel("sp_cond_question_before")
        self.label_option_sp_cond_question_before.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cond_question_before, 466, 0)
        self.option_sp_cond_question_before =  QtWidgets.QComboBox()
        self.option_sp_cond_question_before.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_cond_question_before.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_cond_question_before, 466, 1)
        #--------------------------------------------
        self.label_sp_cond_question_after = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after the '?' in 'b ? t : f'.", "sp_cond_question_after")+"\n\n"+self.tr("Overrides sp_cond_question.", "sp_cond_question_after")))
        self.label_sp_cond_question_after.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cond_question_after, 467, 0, 1, 2)
        self.label_option_sp_cond_question_after = QtWidgets.QLabel("sp_cond_question_after")
        self.label_option_sp_cond_question_after.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cond_question_after, 468, 0)
        self.option_sp_cond_question_after =  QtWidgets.QComboBox()
        self.option_sp_cond_question_after.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_cond_question_after.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_cond_question_after, 468, 1)
        #--------------------------------------------
        self.label_sp_cond_ternary_short = QtWidgets.QLabel(label("<hr>"+self.tr("In the abbreviated ternary form '(a ?: b)', add or remove space between '?'\nand ':'.", "sp_cond_ternary_short")+"\n\n"+self.tr("Overrides all other sp_cond_* options.", "sp_cond_ternary_short")))
        self.label_sp_cond_ternary_short.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cond_ternary_short, 469, 0, 1, 2)
        self.label_option_sp_cond_ternary_short = QtWidgets.QLabel("sp_cond_ternary_short")
        self.label_option_sp_cond_ternary_short.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cond_ternary_short, 470, 0)
        self.option_sp_cond_ternary_short =  QtWidgets.QComboBox()
        self.option_sp_cond_ternary_short.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_cond_ternary_short.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_cond_ternary_short, 470, 1)
        #--------------------------------------------
        self.label_sp_case_label = QtWidgets.QLabel(label("<hr>"+self.tr("Fix the spacing between 'case' and the label. Only 'ignore' and 'force' make\nsense here.", "sp_case_label")))
        self.label_sp_case_label.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_case_label, 471, 0, 1, 2)
        self.label_option_sp_case_label = QtWidgets.QLabel("sp_case_label")
        self.label_option_sp_case_label.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_case_label, 472, 0)
        self.option_sp_case_label =  QtWidgets.QComboBox()
        self.option_sp_case_label.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_case_label.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_case_label, 472, 1)
        #--------------------------------------------
        self.label_sp_range = QtWidgets.QLabel(label("<hr>"+self.tr("(D) Add or remove space around the D '..' operator.", "sp_range")))
        self.label_sp_range.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_range, 473, 0, 1, 2)
        self.label_option_sp_range = QtWidgets.QLabel("sp_range")
        self.label_option_sp_range.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_range, 474, 0)
        self.option_sp_range =  QtWidgets.QComboBox()
        self.option_sp_range.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_range.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_range, 474, 1)
        #--------------------------------------------
        self.label_sp_after_for_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after ':' in a Java/C++11 range-based 'for',\nas in 'for (Type var : <here> expr)'.", "sp_after_for_colon")))
        self.label_sp_after_for_colon.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_for_colon, 475, 0, 1, 2)
        self.label_option_sp_after_for_colon = QtWidgets.QLabel("sp_after_for_colon")
        self.label_option_sp_after_for_colon.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_for_colon, 476, 0)
        self.option_sp_after_for_colon =  QtWidgets.QComboBox()
        self.option_sp_after_for_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_for_colon.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_for_colon, 476, 1)
        #--------------------------------------------
        self.label_sp_before_for_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before ':' in a Java/C++11 range-based 'for',\nas in 'for (Type var <here> : expr)'.", "sp_before_for_colon")))
        self.label_sp_before_for_colon.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_for_colon, 477, 0, 1, 2)
        self.label_option_sp_before_for_colon = QtWidgets.QLabel("sp_before_for_colon")
        self.label_option_sp_before_for_colon.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_for_colon, 478, 0)
        self.option_sp_before_for_colon =  QtWidgets.QComboBox()
        self.option_sp_before_for_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_for_colon.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_for_colon, 478, 1)
        #--------------------------------------------
        self.label_sp_extern_paren = QtWidgets.QLabel(label("<hr>"+self.tr("(D) Add or remove space between 'extern' and '(' as in 'extern <here> (C)'.", "sp_extern_paren")))
        self.label_sp_extern_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_extern_paren, 479, 0, 1, 2)
        self.label_option_sp_extern_paren = QtWidgets.QLabel("sp_extern_paren")
        self.label_option_sp_extern_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_extern_paren, 480, 0)
        self.option_sp_extern_paren =  QtWidgets.QComboBox()
        self.option_sp_extern_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_extern_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_extern_paren, 480, 1)
        #--------------------------------------------
        self.label_sp_cmt_cpp_start = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after the opening of a C++ comment, as in '// <here> A'.", "sp_cmt_cpp_start")))
        self.label_sp_cmt_cpp_start.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cmt_cpp_start, 481, 0, 1, 2)
        self.label_option_sp_cmt_cpp_start = QtWidgets.QLabel("sp_cmt_cpp_start")
        self.label_option_sp_cmt_cpp_start.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cmt_cpp_start, 482, 0)
        self.option_sp_cmt_cpp_start =  QtWidgets.QComboBox()
        self.option_sp_cmt_cpp_start.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_cmt_cpp_start.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_cmt_cpp_start, 482, 1)
        #--------------------------------------------
        self.label_sp_cmt_cpp_pvs = QtWidgets.QLabel(label("<hr>"+self.tr("remove space after the '//' and the pvs command '-V1234',\nonly works with sp_cmt_cpp_start set to add or force.", "sp_cmt_cpp_pvs")))
        self.label_sp_cmt_cpp_pvs.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cmt_cpp_pvs, 483, 0, 1, 2)
        self.label_option_sp_cmt_cpp_pvs = QtWidgets.QLabel("sp_cmt_cpp_pvs")
        self.label_option_sp_cmt_cpp_pvs.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cmt_cpp_pvs, 484, 0)
        self.option_sp_cmt_cpp_pvs =  QtWidgets.QComboBox()
        self.option_sp_cmt_cpp_pvs.addItems(['true','false'])
        self.option_sp_cmt_cpp_pvs.setCurrentText("false")
        self.group_page_layout_2.addWidget(self.option_sp_cmt_cpp_pvs, 484, 1)
        #--------------------------------------------
        self.label_sp_cmt_cpp_lint = QtWidgets.QLabel(label("<hr>"+self.tr("remove space after the '//' and the command 'lint',\nonly works with sp_cmt_cpp_start set to add or force.", "sp_cmt_cpp_lint")))
        self.label_sp_cmt_cpp_lint.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cmt_cpp_lint, 485, 0, 1, 2)
        self.label_option_sp_cmt_cpp_lint = QtWidgets.QLabel("sp_cmt_cpp_lint")
        self.label_option_sp_cmt_cpp_lint.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cmt_cpp_lint, 486, 0)
        self.option_sp_cmt_cpp_lint =  QtWidgets.QComboBox()
        self.option_sp_cmt_cpp_lint.addItems(['true','false'])
        self.option_sp_cmt_cpp_lint.setCurrentText("false")
        self.group_page_layout_2.addWidget(self.option_sp_cmt_cpp_lint, 486, 1)
        #--------------------------------------------
        self.label_sp_cmt_cpp_region = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space in a C++ region marker comment, as in '// <here> BEGIN'.\nA region marker is defined as a comment which is not preceded by other text\n(i.e. the comment is the first non-whitespace on the line), and which starts\nwith either 'BEGIN' or 'END'.", "sp_cmt_cpp_region")+"\n\n"+self.tr("Overrides sp_cmt_cpp_start.", "sp_cmt_cpp_region")))
        self.label_sp_cmt_cpp_region.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cmt_cpp_region, 487, 0, 1, 2)
        self.label_option_sp_cmt_cpp_region = QtWidgets.QLabel("sp_cmt_cpp_region")
        self.label_option_sp_cmt_cpp_region.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cmt_cpp_region, 488, 0)
        self.option_sp_cmt_cpp_region =  QtWidgets.QComboBox()
        self.option_sp_cmt_cpp_region.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_cmt_cpp_region.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_cmt_cpp_region, 488, 1)
        #--------------------------------------------
        self.label_sp_cmt_cpp_doxygen = QtWidgets.QLabel(label("<hr>"+self.tr("If true, space added with sp_cmt_cpp_start will be added after Doxygen\nsequences like '///', '///<', '//!' and '//!<'.", "sp_cmt_cpp_doxygen")))
        self.label_sp_cmt_cpp_doxygen.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cmt_cpp_doxygen, 489, 0, 1, 2)
        self.label_option_sp_cmt_cpp_doxygen = QtWidgets.QLabel("sp_cmt_cpp_doxygen")
        self.label_option_sp_cmt_cpp_doxygen.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cmt_cpp_doxygen, 490, 0)
        self.option_sp_cmt_cpp_doxygen =  QtWidgets.QComboBox()
        self.option_sp_cmt_cpp_doxygen.addItems(['true','false'])
        self.option_sp_cmt_cpp_doxygen.setCurrentText("false")
        self.group_page_layout_2.addWidget(self.option_sp_cmt_cpp_doxygen, 490, 1)
        #--------------------------------------------
        self.label_sp_cmt_cpp_qttr = QtWidgets.QLabel(label("<hr>"+self.tr("If true, space added with sp_cmt_cpp_start will be added after Qt translator\nor meta-data comments like '//:', '//=', and '//~'.", "sp_cmt_cpp_qttr")))
        self.label_sp_cmt_cpp_qttr.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_cmt_cpp_qttr, 491, 0, 1, 2)
        self.label_option_sp_cmt_cpp_qttr = QtWidgets.QLabel("sp_cmt_cpp_qttr")
        self.label_option_sp_cmt_cpp_qttr.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_cmt_cpp_qttr, 492, 0)
        self.option_sp_cmt_cpp_qttr =  QtWidgets.QComboBox()
        self.option_sp_cmt_cpp_qttr.addItems(['true','false'])
        self.option_sp_cmt_cpp_qttr.setCurrentText("false")
        self.group_page_layout_2.addWidget(self.option_sp_cmt_cpp_qttr, 492, 1)
        #--------------------------------------------
        self.label_sp_endif_cmt = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between #else or #endif and a trailing comment.", "sp_endif_cmt")))
        self.label_sp_endif_cmt.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_endif_cmt, 493, 0, 1, 2)
        self.label_option_sp_endif_cmt = QtWidgets.QLabel("sp_endif_cmt")
        self.label_option_sp_endif_cmt.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_endif_cmt, 494, 0)
        self.option_sp_endif_cmt =  QtWidgets.QComboBox()
        self.option_sp_endif_cmt.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_endif_cmt.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_endif_cmt, 494, 1)
        #--------------------------------------------
        self.label_sp_after_new = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after 'new', 'delete' and 'delete[]'.", "sp_after_new")))
        self.label_sp_after_new.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_new, 495, 0, 1, 2)
        self.label_option_sp_after_new = QtWidgets.QLabel("sp_after_new")
        self.label_option_sp_after_new.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_new, 496, 0)
        self.option_sp_after_new =  QtWidgets.QComboBox()
        self.option_sp_after_new.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_new.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_new, 496, 1)
        #--------------------------------------------
        self.label_sp_between_new_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between 'new' and '(' in 'new()'.", "sp_between_new_paren")))
        self.label_sp_between_new_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_between_new_paren, 497, 0, 1, 2)
        self.label_option_sp_between_new_paren = QtWidgets.QLabel("sp_between_new_paren")
        self.label_option_sp_between_new_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_between_new_paren, 498, 0)
        self.option_sp_between_new_paren =  QtWidgets.QComboBox()
        self.option_sp_between_new_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_between_new_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_between_new_paren, 498, 1)
        #--------------------------------------------
        self.label_sp_after_newop_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between ')' and type in 'new(foo) BAR'.", "sp_after_newop_paren")))
        self.label_sp_after_newop_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_newop_paren, 499, 0, 1, 2)
        self.label_option_sp_after_newop_paren = QtWidgets.QLabel("sp_after_newop_paren")
        self.label_option_sp_after_newop_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_newop_paren, 500, 0)
        self.option_sp_after_newop_paren =  QtWidgets.QComboBox()
        self.option_sp_after_newop_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_newop_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_newop_paren, 500, 1)
        #--------------------------------------------
        self.label_sp_inside_newop_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space inside parentheses of the new operator\nas in 'new(foo) BAR'.", "sp_inside_newop_paren")))
        self.label_sp_inside_newop_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_newop_paren, 501, 0, 1, 2)
        self.label_option_sp_inside_newop_paren = QtWidgets.QLabel("sp_inside_newop_paren")
        self.label_option_sp_inside_newop_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_newop_paren, 502, 0)
        self.option_sp_inside_newop_paren =  QtWidgets.QComboBox()
        self.option_sp_inside_newop_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_newop_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_newop_paren, 502, 1)
        #--------------------------------------------
        self.label_sp_inside_newop_paren_open = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after the open parenthesis of the new operator,\nas in 'new(foo) BAR'.", "sp_inside_newop_paren_open")+"\n\n"+self.tr("Overrides sp_inside_newop_paren.", "sp_inside_newop_paren_open")))
        self.label_sp_inside_newop_paren_open.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_newop_paren_open, 503, 0, 1, 2)
        self.label_option_sp_inside_newop_paren_open = QtWidgets.QLabel("sp_inside_newop_paren_open")
        self.label_option_sp_inside_newop_paren_open.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_newop_paren_open, 504, 0)
        self.option_sp_inside_newop_paren_open =  QtWidgets.QComboBox()
        self.option_sp_inside_newop_paren_open.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_newop_paren_open.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_newop_paren_open, 504, 1)
        #--------------------------------------------
        self.label_sp_inside_newop_paren_close = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before the close parenthesis of the new operator,\nas in 'new(foo) BAR'.", "sp_inside_newop_paren_close")+"\n\n"+self.tr("Overrides sp_inside_newop_paren.", "sp_inside_newop_paren_close")))
        self.label_sp_inside_newop_paren_close.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_inside_newop_paren_close, 505, 0, 1, 2)
        self.label_option_sp_inside_newop_paren_close = QtWidgets.QLabel("sp_inside_newop_paren_close")
        self.label_option_sp_inside_newop_paren_close.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_inside_newop_paren_close, 506, 0)
        self.option_sp_inside_newop_paren_close =  QtWidgets.QComboBox()
        self.option_sp_inside_newop_paren_close.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_inside_newop_paren_close.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_inside_newop_paren_close, 506, 1)
        #--------------------------------------------
        self.label_sp_before_tr_cmt = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before a trailing comment.", "sp_before_tr_cmt")))
        self.label_sp_before_tr_cmt.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_tr_cmt, 507, 0, 1, 2)
        self.label_option_sp_before_tr_cmt = QtWidgets.QLabel("sp_before_tr_cmt")
        self.label_option_sp_before_tr_cmt.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_tr_cmt, 508, 0)
        self.option_sp_before_tr_cmt =  QtWidgets.QComboBox()
        self.option_sp_before_tr_cmt.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_tr_cmt.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_tr_cmt, 508, 1)
        #--------------------------------------------
        self.label_sp_num_before_tr_cmt = QtWidgets.QLabel(label("<hr>"+self.tr("Number of spaces before a trailing comment.", "sp_num_before_tr_cmt")))
        self.label_sp_num_before_tr_cmt.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_num_before_tr_cmt, 509, 0, 1, 2)
        self.label_option_sp_num_before_tr_cmt = QtWidgets.QLabel("sp_num_before_tr_cmt")
        self.label_option_sp_num_before_tr_cmt.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_num_before_tr_cmt, 510, 0)
        self.option_sp_num_before_tr_cmt =  QtWidgets.QSpinBox()
        self.option_sp_num_before_tr_cmt.setMinimum( 0)
        self.option_sp_num_before_tr_cmt.setMaximum( 16)
        self.option_sp_num_before_tr_cmt.setValue(0)
        self.group_page_layout_2.addWidget(self.option_sp_num_before_tr_cmt, 510, 1)
        #--------------------------------------------
        self.label_sp_before_emb_cmt = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before an embedded comment.", "sp_before_emb_cmt")))
        self.label_sp_before_emb_cmt.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_emb_cmt, 511, 0, 1, 2)
        self.label_option_sp_before_emb_cmt = QtWidgets.QLabel("sp_before_emb_cmt")
        self.label_option_sp_before_emb_cmt.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_emb_cmt, 512, 0)
        self.option_sp_before_emb_cmt =  QtWidgets.QComboBox()
        self.option_sp_before_emb_cmt.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_emb_cmt.setCurrentText("force")
        self.group_page_layout_2.addWidget(self.option_sp_before_emb_cmt, 512, 1)
        #--------------------------------------------
        self.label_sp_num_before_emb_cmt = QtWidgets.QLabel(label("<hr>"+self.tr("Number of spaces before an embedded comment.", "sp_num_before_emb_cmt")))
        self.label_sp_num_before_emb_cmt.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_num_before_emb_cmt, 513, 0, 1, 2)
        self.label_option_sp_num_before_emb_cmt = QtWidgets.QLabel("sp_num_before_emb_cmt")
        self.label_option_sp_num_before_emb_cmt.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_num_before_emb_cmt, 514, 0)
        self.option_sp_num_before_emb_cmt =  QtWidgets.QSpinBox()
        self.option_sp_num_before_emb_cmt.setMinimum( 0)
        self.option_sp_num_before_emb_cmt.setMaximum( 16)
        self.option_sp_num_before_emb_cmt.setValue(1)
        self.group_page_layout_2.addWidget(self.option_sp_num_before_emb_cmt, 514, 1)
        #--------------------------------------------
        self.label_sp_after_emb_cmt = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after an embedded comment.", "sp_after_emb_cmt")))
        self.label_sp_after_emb_cmt.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_emb_cmt, 515, 0, 1, 2)
        self.label_option_sp_after_emb_cmt = QtWidgets.QLabel("sp_after_emb_cmt")
        self.label_option_sp_after_emb_cmt.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_emb_cmt, 516, 0)
        self.option_sp_after_emb_cmt =  QtWidgets.QComboBox()
        self.option_sp_after_emb_cmt.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_emb_cmt.setCurrentText("force")
        self.group_page_layout_2.addWidget(self.option_sp_after_emb_cmt, 516, 1)
        #--------------------------------------------
        self.label_sp_num_after_emb_cmt = QtWidgets.QLabel(label("<hr>"+self.tr("Number of spaces after an embedded comment.", "sp_num_after_emb_cmt")))
        self.label_sp_num_after_emb_cmt.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_num_after_emb_cmt, 517, 0, 1, 2)
        self.label_option_sp_num_after_emb_cmt = QtWidgets.QLabel("sp_num_after_emb_cmt")
        self.label_option_sp_num_after_emb_cmt.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_num_after_emb_cmt, 518, 0)
        self.option_sp_num_after_emb_cmt =  QtWidgets.QSpinBox()
        self.option_sp_num_after_emb_cmt.setMinimum( 0)
        self.option_sp_num_after_emb_cmt.setMaximum( 16)
        self.option_sp_num_after_emb_cmt.setValue(1)
        self.group_page_layout_2.addWidget(self.option_sp_num_after_emb_cmt, 518, 1)
        #--------------------------------------------
        self.label_sp_emb_cmt_priority = QtWidgets.QLabel(label("<hr>"+self.tr("Embedded comment spacing options have higher priority (== override)\nthan other spacing options (comma, parenthesis, braces, ...)", "sp_emb_cmt_priority")))
        self.label_sp_emb_cmt_priority.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_emb_cmt_priority, 519, 0, 1, 2)
        self.label_option_sp_emb_cmt_priority = QtWidgets.QLabel("sp_emb_cmt_priority")
        self.label_option_sp_emb_cmt_priority.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_emb_cmt_priority, 520, 0)
        self.option_sp_emb_cmt_priority =  QtWidgets.QComboBox()
        self.option_sp_emb_cmt_priority.addItems(['true','false'])
        self.option_sp_emb_cmt_priority.setCurrentText("false")
        self.group_page_layout_2.addWidget(self.option_sp_emb_cmt_priority, 520, 1)
        #--------------------------------------------
        self.label_sp_annotation_paren = QtWidgets.QLabel(label("<hr>"+self.tr("(Java) Add or remove space between an annotation and the open parenthesis.", "sp_annotation_paren")))
        self.label_sp_annotation_paren.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_annotation_paren, 521, 0, 1, 2)
        self.label_option_sp_annotation_paren = QtWidgets.QLabel("sp_annotation_paren")
        self.label_option_sp_annotation_paren.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_annotation_paren, 522, 0)
        self.option_sp_annotation_paren =  QtWidgets.QComboBox()
        self.option_sp_annotation_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_annotation_paren.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_annotation_paren, 522, 1)
        #--------------------------------------------
        self.label_sp_skip_vbrace_tokens = QtWidgets.QLabel(label("<hr>"+self.tr("If true, vbrace tokens are dropped to the previous token and skipped.", "sp_skip_vbrace_tokens")))
        self.label_sp_skip_vbrace_tokens.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_skip_vbrace_tokens, 523, 0, 1, 2)
        self.label_option_sp_skip_vbrace_tokens = QtWidgets.QLabel("sp_skip_vbrace_tokens")
        self.label_option_sp_skip_vbrace_tokens.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_skip_vbrace_tokens, 524, 0)
        self.option_sp_skip_vbrace_tokens =  QtWidgets.QComboBox()
        self.option_sp_skip_vbrace_tokens.addItems(['true','false'])
        self.option_sp_skip_vbrace_tokens.setCurrentText("false")
        self.group_page_layout_2.addWidget(self.option_sp_skip_vbrace_tokens, 524, 1)
        #--------------------------------------------
        self.label_sp_after_noexcept = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after 'noexcept'.", "sp_after_noexcept")))
        self.label_sp_after_noexcept.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_noexcept, 525, 0, 1, 2)
        self.label_option_sp_after_noexcept = QtWidgets.QLabel("sp_after_noexcept")
        self.label_option_sp_after_noexcept.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_noexcept, 526, 0)
        self.option_sp_after_noexcept =  QtWidgets.QComboBox()
        self.option_sp_after_noexcept.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_noexcept.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_noexcept, 526, 1)
        #--------------------------------------------
        self.label_sp_vala_after_translation = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after '_'.", "sp_vala_after_translation")))
        self.label_sp_vala_after_translation.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_vala_after_translation, 527, 0, 1, 2)
        self.label_option_sp_vala_after_translation = QtWidgets.QLabel("sp_vala_after_translation")
        self.label_option_sp_vala_after_translation.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_vala_after_translation, 528, 0)
        self.option_sp_vala_after_translation =  QtWidgets.QComboBox()
        self.option_sp_vala_after_translation.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_vala_after_translation.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_vala_after_translation, 528, 1)
        #--------------------------------------------
        self.label_sp_before_bit_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space before a bit colon ':'.", "sp_before_bit_colon")))
        self.label_sp_before_bit_colon.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_before_bit_colon, 529, 0, 1, 2)
        self.label_option_sp_before_bit_colon = QtWidgets.QLabel("sp_before_bit_colon")
        self.label_option_sp_before_bit_colon.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_before_bit_colon, 530, 0)
        self.option_sp_before_bit_colon =  QtWidgets.QComboBox()
        self.option_sp_before_bit_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_before_bit_colon.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_before_bit_colon, 530, 1)
        #--------------------------------------------
        self.label_sp_after_bit_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after a bit colon ':'.", "sp_after_bit_colon")))
        self.label_sp_after_bit_colon.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_after_bit_colon, 531, 0, 1, 2)
        self.label_option_sp_after_bit_colon = QtWidgets.QLabel("sp_after_bit_colon")
        self.label_option_sp_after_bit_colon.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_after_bit_colon, 532, 0)
        self.option_sp_after_bit_colon =  QtWidgets.QComboBox()
        self.option_sp_after_bit_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_after_bit_colon.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_after_bit_colon, 532, 1)
        #--------------------------------------------
        self.label_force_tab_after_define = QtWidgets.QLabel(label("<hr>"+self.tr("If true, a <TAB> is inserted after #define.", "force_tab_after_define")))
        self.label_force_tab_after_define.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_force_tab_after_define, 533, 0, 1, 2)
        self.label_option_force_tab_after_define = QtWidgets.QLabel("force_tab_after_define")
        self.label_option_force_tab_after_define.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_force_tab_after_define, 534, 0)
        self.option_force_tab_after_define =  QtWidgets.QComboBox()
        self.option_force_tab_after_define.addItems(['true','false'])
        self.option_force_tab_after_define.setCurrentText("false")
        self.group_page_layout_2.addWidget(self.option_force_tab_after_define, 534, 1)
        #--------------------------------------------
        self.label_sp_string_string = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space between two strings.", "sp_string_string")))
        self.label_sp_string_string.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_string_string, 535, 0, 1, 2)
        self.label_option_sp_string_string = QtWidgets.QLabel("sp_string_string")
        self.label_option_sp_string_string.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_string_string, 536, 0)
        self.option_sp_string_string =  QtWidgets.QComboBox()
        self.option_sp_string_string.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_string_string.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_string_string, 536, 1)
        #--------------------------------------------
        self.label_sp_struct_type = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space 'struct' and a type.", "sp_struct_type")))
        self.label_sp_struct_type.setWordWrap(True)
        self.group_page_layout_2.addWidget(self.label_sp_struct_type, 537, 0, 1, 2)
        self.label_option_sp_struct_type = QtWidgets.QLabel("sp_struct_type")
        self.label_option_sp_struct_type.setFont(font_name)
        self.group_page_layout_2.addWidget(self.label_option_sp_struct_type, 538, 0)
        self.option_sp_struct_type =  QtWidgets.QComboBox()
        self.option_sp_struct_type.addItems(['ignore','add','remove','force','not_defined'])
        self.option_sp_struct_type.setCurrentText("ignore")
        self.group_page_layout_2.addWidget(self.option_sp_struct_type, 538, 1)
        self.group_page_layout_2.addItem(QtWidgets.QSpacerItem(10, 10, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding), 539,0)
        self.scroll_group_page_2 = QtWidgets.QScrollArea()
        self.scroll_group_page_2.setWidget(self.group_page_2)
        self.scroll_group_page_2.setWidgetResizable(True)
        self.addTab(self.scroll_group_page_2, self.tr("Spacing options"))
        #================== Indenting options ===============================================================
        self.group_page_3 = QtWidgets.QWidget()
        self.group_page_layout_3 = QtWidgets.QGridLayout(self.group_page_3)
        self.group_page_layout_3.addWidget(QtWidgets.QLabel(label(self.tr("Indenting options help"))), 0, 0, 1, 2)
        #--------------------------------------------
        self.label_indent_columns = QtWidgets.QLabel(label("<hr>"+self.tr("The number of columns to indent per level. Usually 2, 3, 4, or 8.", "indent_columns")))
        self.label_indent_columns.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_columns, 1, 0, 1, 2)
        self.label_option_indent_columns = QtWidgets.QLabel("indent_columns")
        self.label_option_indent_columns.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_columns, 2, 0)
        self.option_indent_columns =  QtWidgets.QSpinBox()
        self.option_indent_columns.setMinimum( 0)
        self.option_indent_columns.setMaximum( 16)
        self.option_indent_columns.setValue(8)
        self.group_page_layout_3.addWidget(self.option_indent_columns, 2, 1)
        #--------------------------------------------
        self.label_indent_ignore_first_continue = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to ignore indent for the first continuation line. Subsequent\ncontinuation lines will still be indented to match the first.", "indent_ignore_first_continue")))
        self.label_indent_ignore_first_continue.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_ignore_first_continue, 3, 0, 1, 2)
        self.label_option_indent_ignore_first_continue = QtWidgets.QLabel("indent_ignore_first_continue")
        self.label_option_indent_ignore_first_continue.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_ignore_first_continue, 4, 0)
        self.option_indent_ignore_first_continue =  QtWidgets.QComboBox()
        self.option_indent_ignore_first_continue.addItems(['true','false'])
        self.option_indent_ignore_first_continue.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_ignore_first_continue, 4, 1)
        #--------------------------------------------
        self.label_indent_continue = QtWidgets.QLabel(label("<hr>"+self.tr("The continuation indent. If non-zero, this overrides the indent of '(', '['\nand '=' continuation indents. Negative values are OK; negative value is\nabsolute and not increased for each '(' or '[' level.", "indent_continue")+"\n\n"+self.tr("For FreeBSD, this is set to 4.\nRequires indent_ignore_first_continue=false.", "indent_continue")))
        self.label_indent_continue.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_continue, 5, 0, 1, 2)
        self.label_option_indent_continue = QtWidgets.QLabel("indent_continue")
        self.label_option_indent_continue.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_continue, 6, 0)
        self.option_indent_continue =  QtWidgets.QSpinBox()
        self.option_indent_continue.setMinimum( -16)
        self.option_indent_continue.setMaximum( 16)
        self.option_indent_continue.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_continue, 6, 1)
        #--------------------------------------------
        self.label_indent_continue_class_head = QtWidgets.QLabel(label("<hr>"+self.tr("The continuation indent, only for class header line(s). If non-zero, this\noverrides the indent of 'class' continuation indents.\nRequires indent_ignore_first_continue=false.", "indent_continue_class_head")))
        self.label_indent_continue_class_head.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_continue_class_head, 7, 0, 1, 2)
        self.label_option_indent_continue_class_head = QtWidgets.QLabel("indent_continue_class_head")
        self.label_option_indent_continue_class_head.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_continue_class_head, 8, 0)
        self.option_indent_continue_class_head =  QtWidgets.QSpinBox()
        self.option_indent_continue_class_head.setMinimum( 0)
        self.option_indent_continue_class_head.setMaximum( 16)
        self.option_indent_continue_class_head.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_continue_class_head, 8, 1)
        #--------------------------------------------
        self.label_indent_single_newlines = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent empty lines (i.e. lines which contain only spaces before\nthe newline character).", "indent_single_newlines")))
        self.label_indent_single_newlines.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_single_newlines, 9, 0, 1, 2)
        self.label_option_indent_single_newlines = QtWidgets.QLabel("indent_single_newlines")
        self.label_option_indent_single_newlines.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_single_newlines, 10, 0)
        self.option_indent_single_newlines =  QtWidgets.QComboBox()
        self.option_indent_single_newlines.addItems(['true','false'])
        self.option_indent_single_newlines.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_single_newlines, 10, 1)
        #--------------------------------------------
        self.label_indent_param = QtWidgets.QLabel(label("<hr>"+self.tr("The continuation indent for func_*_param if they are true. If non-zero, this\noverrides the indent.", "indent_param")))
        self.label_indent_param.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_param, 11, 0, 1, 2)
        self.label_option_indent_param = QtWidgets.QLabel("indent_param")
        self.label_option_indent_param.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_param, 12, 0)
        self.option_indent_param =  QtWidgets.QSpinBox()
        self.option_indent_param.setMinimum( 0)
        self.option_indent_param.setMaximum( 16)
        self.option_indent_param.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_param, 12, 1)
        #--------------------------------------------
        self.label_indent_with_tabs = QtWidgets.QLabel(label("<hr>"+self.tr("How to use tabs when indenting code.", "indent_with_tabs")+"\n\n"+self.tr("0: Spaces only\n1: Indent with tabs to brace level, align with spaces (default)\n2: Indent and align with tabs, using spaces when not on a tabstop", "indent_with_tabs")))
        self.label_indent_with_tabs.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_with_tabs, 13, 0, 1, 2)
        self.label_option_indent_with_tabs = QtWidgets.QLabel("indent_with_tabs")
        self.label_option_indent_with_tabs.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_with_tabs, 14, 0)
        self.option_indent_with_tabs =  QtWidgets.QSpinBox()
        self.option_indent_with_tabs.setMinimum( 0)
        self.option_indent_with_tabs.setMaximum( 2)
        self.option_indent_with_tabs.setValue(1)
        self.group_page_layout_3.addWidget(self.option_indent_with_tabs, 14, 1)
        #--------------------------------------------
        self.label_indent_cmt_with_tabs = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent comments that are not at a brace level with tabs on a\ntabstop. Requires indent_with_tabs=2. If false, will use spaces.", "indent_cmt_with_tabs")))
        self.label_indent_cmt_with_tabs.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_cmt_with_tabs, 15, 0, 1, 2)
        self.label_option_indent_cmt_with_tabs = QtWidgets.QLabel("indent_cmt_with_tabs")
        self.label_option_indent_cmt_with_tabs.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_cmt_with_tabs, 16, 0)
        self.option_indent_cmt_with_tabs =  QtWidgets.QComboBox()
        self.option_indent_cmt_with_tabs.addItems(['true','false'])
        self.option_indent_cmt_with_tabs.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_cmt_with_tabs, 16, 1)
        #--------------------------------------------
        self.label_indent_align_string = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent strings broken by '\\' so that they line up.", "indent_align_string")))
        self.label_indent_align_string.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_align_string, 17, 0, 1, 2)
        self.label_option_indent_align_string = QtWidgets.QLabel("indent_align_string")
        self.label_option_indent_align_string.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_align_string, 18, 0)
        self.option_indent_align_string =  QtWidgets.QComboBox()
        self.option_indent_align_string.addItems(['true','false'])
        self.option_indent_align_string.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_align_string, 18, 1)
        #--------------------------------------------
        self.label_indent_xml_string = QtWidgets.QLabel(label("<hr>"+self.tr("The number of spaces to indent multi-line XML strings.\nRequires indent_align_string=true.", "indent_xml_string")))
        self.label_indent_xml_string.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_xml_string, 19, 0, 1, 2)
        self.label_option_indent_xml_string = QtWidgets.QLabel("indent_xml_string")
        self.label_option_indent_xml_string.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_xml_string, 20, 0)
        self.option_indent_xml_string =  QtWidgets.QSpinBox()
        self.option_indent_xml_string.setMinimum( 0)
        self.option_indent_xml_string.setMaximum( 16)
        self.option_indent_xml_string.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_xml_string, 20, 1)
        #--------------------------------------------
        self.label_indent_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Spaces to indent '{' from level.", "indent_brace")))
        self.label_indent_brace.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_brace, 21, 0, 1, 2)
        self.label_option_indent_brace = QtWidgets.QLabel("indent_brace")
        self.label_option_indent_brace.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_brace, 22, 0)
        self.option_indent_brace =  QtWidgets.QSpinBox()
        self.option_indent_brace.setMinimum( 0)
        self.option_indent_brace.setMaximum( 16)
        self.option_indent_brace.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_brace, 22, 1)
        #--------------------------------------------
        self.label_indent_braces = QtWidgets.QLabel(label("<hr>"+self.tr("Whether braces are indented to the body level.", "indent_braces")))
        self.label_indent_braces.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_braces, 23, 0, 1, 2)
        self.label_option_indent_braces = QtWidgets.QLabel("indent_braces")
        self.label_option_indent_braces.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_braces, 24, 0)
        self.option_indent_braces =  QtWidgets.QComboBox()
        self.option_indent_braces.addItems(['true','false'])
        self.option_indent_braces.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_braces, 24, 1)
        #--------------------------------------------
        self.label_indent_braces_no_func = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to disable indenting function braces if indent_braces=true.", "indent_braces_no_func")))
        self.label_indent_braces_no_func.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_braces_no_func, 25, 0, 1, 2)
        self.label_option_indent_braces_no_func = QtWidgets.QLabel("indent_braces_no_func")
        self.label_option_indent_braces_no_func.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_braces_no_func, 26, 0)
        self.option_indent_braces_no_func =  QtWidgets.QComboBox()
        self.option_indent_braces_no_func.addItems(['true','false'])
        self.option_indent_braces_no_func.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_braces_no_func, 26, 1)
        #--------------------------------------------
        self.label_indent_braces_no_class = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to disable indenting class braces if indent_braces=true.", "indent_braces_no_class")))
        self.label_indent_braces_no_class.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_braces_no_class, 27, 0, 1, 2)
        self.label_option_indent_braces_no_class = QtWidgets.QLabel("indent_braces_no_class")
        self.label_option_indent_braces_no_class.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_braces_no_class, 28, 0)
        self.option_indent_braces_no_class =  QtWidgets.QComboBox()
        self.option_indent_braces_no_class.addItems(['true','false'])
        self.option_indent_braces_no_class.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_braces_no_class, 28, 1)
        #--------------------------------------------
        self.label_indent_braces_no_struct = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to disable indenting struct braces if indent_braces=true.", "indent_braces_no_struct")))
        self.label_indent_braces_no_struct.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_braces_no_struct, 29, 0, 1, 2)
        self.label_option_indent_braces_no_struct = QtWidgets.QLabel("indent_braces_no_struct")
        self.label_option_indent_braces_no_struct.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_braces_no_struct, 30, 0)
        self.option_indent_braces_no_struct =  QtWidgets.QComboBox()
        self.option_indent_braces_no_struct.addItems(['true','false'])
        self.option_indent_braces_no_struct.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_braces_no_struct, 30, 1)
        #--------------------------------------------
        self.label_indent_brace_parent = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent based on the size of the brace parent,\ni.e. 'if' => 3 spaces, 'for' => 4 spaces, etc.", "indent_brace_parent")))
        self.label_indent_brace_parent.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_brace_parent, 31, 0, 1, 2)
        self.label_option_indent_brace_parent = QtWidgets.QLabel("indent_brace_parent")
        self.label_option_indent_brace_parent.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_brace_parent, 32, 0)
        self.option_indent_brace_parent =  QtWidgets.QComboBox()
        self.option_indent_brace_parent.addItems(['true','false'])
        self.option_indent_brace_parent.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_brace_parent, 32, 1)
        #--------------------------------------------
        self.label_indent_paren_open_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent based on the open parenthesis instead of the open brace\nin '({\\n'.", "indent_paren_open_brace")))
        self.label_indent_paren_open_brace.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_paren_open_brace, 33, 0, 1, 2)
        self.label_option_indent_paren_open_brace = QtWidgets.QLabel("indent_paren_open_brace")
        self.label_option_indent_paren_open_brace.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_paren_open_brace, 34, 0)
        self.option_indent_paren_open_brace =  QtWidgets.QComboBox()
        self.option_indent_paren_open_brace.addItems(['true','false'])
        self.option_indent_paren_open_brace.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_paren_open_brace, 34, 1)
        #--------------------------------------------
        self.label_indent_cs_delegate_brace = QtWidgets.QLabel(label("<hr>"+self.tr("(C#) Whether to indent the brace of a C# delegate by another level.", "indent_cs_delegate_brace")))
        self.label_indent_cs_delegate_brace.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_cs_delegate_brace, 35, 0, 1, 2)
        self.label_option_indent_cs_delegate_brace = QtWidgets.QLabel("indent_cs_delegate_brace")
        self.label_option_indent_cs_delegate_brace.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_cs_delegate_brace, 36, 0)
        self.option_indent_cs_delegate_brace =  QtWidgets.QComboBox()
        self.option_indent_cs_delegate_brace.addItems(['true','false'])
        self.option_indent_cs_delegate_brace.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_cs_delegate_brace, 36, 1)
        #--------------------------------------------
        self.label_indent_cs_delegate_body = QtWidgets.QLabel(label("<hr>"+self.tr("(C#) Whether to indent a C# delegate (to handle delegates with no brace) by\nanother level.", "indent_cs_delegate_body")))
        self.label_indent_cs_delegate_body.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_cs_delegate_body, 37, 0, 1, 2)
        self.label_option_indent_cs_delegate_body = QtWidgets.QLabel("indent_cs_delegate_body")
        self.label_option_indent_cs_delegate_body.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_cs_delegate_body, 38, 0)
        self.option_indent_cs_delegate_body =  QtWidgets.QComboBox()
        self.option_indent_cs_delegate_body.addItems(['true','false'])
        self.option_indent_cs_delegate_body.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_cs_delegate_body, 38, 1)
        #--------------------------------------------
        self.label_indent_namespace = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent the body of a 'namespace'.", "indent_namespace")))
        self.label_indent_namespace.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_namespace, 39, 0, 1, 2)
        self.label_option_indent_namespace = QtWidgets.QLabel("indent_namespace")
        self.label_option_indent_namespace.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_namespace, 40, 0)
        self.option_indent_namespace =  QtWidgets.QComboBox()
        self.option_indent_namespace.addItems(['true','false'])
        self.option_indent_namespace.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_namespace, 40, 1)
        #--------------------------------------------
        self.label_indent_namespace_single_indent = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent only the first namespace, and not any nested namespaces.\nRequires indent_namespace=true.", "indent_namespace_single_indent")))
        self.label_indent_namespace_single_indent.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_namespace_single_indent, 41, 0, 1, 2)
        self.label_option_indent_namespace_single_indent = QtWidgets.QLabel("indent_namespace_single_indent")
        self.label_option_indent_namespace_single_indent.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_namespace_single_indent, 42, 0)
        self.option_indent_namespace_single_indent =  QtWidgets.QComboBox()
        self.option_indent_namespace_single_indent.addItems(['true','false'])
        self.option_indent_namespace_single_indent.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_namespace_single_indent, 42, 1)
        #--------------------------------------------
        self.label_indent_namespace_level = QtWidgets.QLabel(label("<hr>"+self.tr("The number of spaces to indent a namespace block.\nIf set to zero, use the value indent_columns", "indent_namespace_level")))
        self.label_indent_namespace_level.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_namespace_level, 43, 0, 1, 2)
        self.label_option_indent_namespace_level = QtWidgets.QLabel("indent_namespace_level")
        self.label_option_indent_namespace_level.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_namespace_level, 44, 0)
        self.option_indent_namespace_level =  QtWidgets.QSpinBox()
        self.option_indent_namespace_level.setMinimum( 0)
        self.option_indent_namespace_level.setMaximum( 16)
        self.option_indent_namespace_level.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_namespace_level, 44, 1)
        #--------------------------------------------
        self.label_indent_namespace_limit = QtWidgets.QLabel(label("<hr>"+self.tr("If the body of the namespace is longer than this number, it won't be\nindented. Requires indent_namespace=true. 0 means no limit.", "indent_namespace_limit")))
        self.label_indent_namespace_limit.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_namespace_limit, 45, 0, 1, 2)
        self.label_option_indent_namespace_limit = QtWidgets.QLabel("indent_namespace_limit")
        self.label_option_indent_namespace_limit.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_namespace_limit, 46, 0)
        self.option_indent_namespace_limit =  QtWidgets.QSpinBox()
        self.option_indent_namespace_limit.setMinimum( 0)
        self.option_indent_namespace_limit.setMaximum( 255)
        self.option_indent_namespace_limit.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_namespace_limit, 46, 1)
        #--------------------------------------------
        self.label_indent_namespace_inner_only = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent only in inner namespaces (nested in other namespaces).\nRequires indent_namespace=true.", "indent_namespace_inner_only")))
        self.label_indent_namespace_inner_only.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_namespace_inner_only, 47, 0, 1, 2)
        self.label_option_indent_namespace_inner_only = QtWidgets.QLabel("indent_namespace_inner_only")
        self.label_option_indent_namespace_inner_only.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_namespace_inner_only, 48, 0)
        self.option_indent_namespace_inner_only =  QtWidgets.QComboBox()
        self.option_indent_namespace_inner_only.addItems(['true','false'])
        self.option_indent_namespace_inner_only.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_namespace_inner_only, 48, 1)
        #--------------------------------------------
        self.label_indent_extern = QtWidgets.QLabel(label("<hr>"+self.tr("Whether the 'extern \"C\"' body is indented.", "indent_extern")))
        self.label_indent_extern.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_extern, 49, 0, 1, 2)
        self.label_option_indent_extern = QtWidgets.QLabel("indent_extern")
        self.label_option_indent_extern.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_extern, 50, 0)
        self.option_indent_extern =  QtWidgets.QComboBox()
        self.option_indent_extern.addItems(['true','false'])
        self.option_indent_extern.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_extern, 50, 1)
        #--------------------------------------------
        self.label_indent_class = QtWidgets.QLabel(label("<hr>"+self.tr("Whether the 'class' body is indented.", "indent_class")))
        self.label_indent_class.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_class, 51, 0, 1, 2)
        self.label_option_indent_class = QtWidgets.QLabel("indent_class")
        self.label_option_indent_class.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_class, 52, 0)
        self.option_indent_class =  QtWidgets.QComboBox()
        self.option_indent_class.addItems(['true','false'])
        self.option_indent_class.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_class, 52, 1)
        #--------------------------------------------
        self.label_indent_ignore_before_class_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to ignore indent for the leading base class colon.", "indent_ignore_before_class_colon")))
        self.label_indent_ignore_before_class_colon.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_ignore_before_class_colon, 53, 0, 1, 2)
        self.label_option_indent_ignore_before_class_colon = QtWidgets.QLabel("indent_ignore_before_class_colon")
        self.label_option_indent_ignore_before_class_colon.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_ignore_before_class_colon, 54, 0)
        self.option_indent_ignore_before_class_colon =  QtWidgets.QComboBox()
        self.option_indent_ignore_before_class_colon.addItems(['true','false'])
        self.option_indent_ignore_before_class_colon.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_ignore_before_class_colon, 54, 1)
        #--------------------------------------------
        self.label_indent_before_class_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Additional indent before the leading base class colon.\nNegative values decrease indent down to the first column.\nRequires indent_ignore_before_class_colon=false and a newline break before\nthe colon (see pos_class_colon and nl_class_colon)", "indent_before_class_colon")))
        self.label_indent_before_class_colon.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_before_class_colon, 55, 0, 1, 2)
        self.label_option_indent_before_class_colon = QtWidgets.QLabel("indent_before_class_colon")
        self.label_option_indent_before_class_colon.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_before_class_colon, 56, 0)
        self.option_indent_before_class_colon =  QtWidgets.QSpinBox()
        self.option_indent_before_class_colon.setMinimum( -16)
        self.option_indent_before_class_colon.setMaximum( 16)
        self.option_indent_before_class_colon.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_before_class_colon, 56, 1)
        #--------------------------------------------
        self.label_indent_class_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent the stuff after a leading base class colon.", "indent_class_colon")))
        self.label_indent_class_colon.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_class_colon, 57, 0, 1, 2)
        self.label_option_indent_class_colon = QtWidgets.QLabel("indent_class_colon")
        self.label_option_indent_class_colon.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_class_colon, 58, 0)
        self.option_indent_class_colon =  QtWidgets.QComboBox()
        self.option_indent_class_colon.addItems(['true','false'])
        self.option_indent_class_colon.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_class_colon, 58, 1)
        #--------------------------------------------
        self.label_indent_class_on_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent based on a class colon instead of the stuff after the\ncolon. Requires indent_class_colon=true.", "indent_class_on_colon")))
        self.label_indent_class_on_colon.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_class_on_colon, 59, 0, 1, 2)
        self.label_option_indent_class_on_colon = QtWidgets.QLabel("indent_class_on_colon")
        self.label_option_indent_class_on_colon.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_class_on_colon, 60, 0)
        self.option_indent_class_on_colon =  QtWidgets.QComboBox()
        self.option_indent_class_on_colon.addItems(['true','false'])
        self.option_indent_class_on_colon.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_class_on_colon, 60, 1)
        #--------------------------------------------
        self.label_indent_ignore_before_constr_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to ignore indent for a leading class initializer colon.", "indent_ignore_before_constr_colon")))
        self.label_indent_ignore_before_constr_colon.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_ignore_before_constr_colon, 61, 0, 1, 2)
        self.label_option_indent_ignore_before_constr_colon = QtWidgets.QLabel("indent_ignore_before_constr_colon")
        self.label_option_indent_ignore_before_constr_colon.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_ignore_before_constr_colon, 62, 0)
        self.option_indent_ignore_before_constr_colon =  QtWidgets.QComboBox()
        self.option_indent_ignore_before_constr_colon.addItems(['true','false'])
        self.option_indent_ignore_before_constr_colon.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_ignore_before_constr_colon, 62, 1)
        #--------------------------------------------
        self.label_indent_constr_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent the stuff after a leading class initializer colon.", "indent_constr_colon")))
        self.label_indent_constr_colon.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_constr_colon, 63, 0, 1, 2)
        self.label_option_indent_constr_colon = QtWidgets.QLabel("indent_constr_colon")
        self.label_option_indent_constr_colon.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_constr_colon, 64, 0)
        self.option_indent_constr_colon =  QtWidgets.QComboBox()
        self.option_indent_constr_colon.addItems(['true','false'])
        self.option_indent_constr_colon.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_constr_colon, 64, 1)
        #--------------------------------------------
        self.label_indent_ctor_init_leading = QtWidgets.QLabel(label("<hr>"+self.tr("Virtual indent from the ':' for leading member initializers.", "indent_ctor_init_leading")))
        self.label_indent_ctor_init_leading.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_ctor_init_leading, 65, 0, 1, 2)
        self.label_option_indent_ctor_init_leading = QtWidgets.QLabel("indent_ctor_init_leading")
        self.label_option_indent_ctor_init_leading.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_ctor_init_leading, 66, 0)
        self.option_indent_ctor_init_leading =  QtWidgets.QSpinBox()
        self.option_indent_ctor_init_leading.setMinimum( 0)
        self.option_indent_ctor_init_leading.setMaximum( 16)
        self.option_indent_ctor_init_leading.setValue(2)
        self.group_page_layout_3.addWidget(self.option_indent_ctor_init_leading, 66, 1)
        #--------------------------------------------
        self.label_indent_ctor_init_following = QtWidgets.QLabel(label("<hr>"+self.tr("Virtual indent from the ':' for following member initializers.", "indent_ctor_init_following")))
        self.label_indent_ctor_init_following.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_ctor_init_following, 67, 0, 1, 2)
        self.label_option_indent_ctor_init_following = QtWidgets.QLabel("indent_ctor_init_following")
        self.label_option_indent_ctor_init_following.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_ctor_init_following, 68, 0)
        self.option_indent_ctor_init_following =  QtWidgets.QSpinBox()
        self.option_indent_ctor_init_following.setMinimum( 0)
        self.option_indent_ctor_init_following.setMaximum( 16)
        self.option_indent_ctor_init_following.setValue(2)
        self.group_page_layout_3.addWidget(self.option_indent_ctor_init_following, 68, 1)
        #--------------------------------------------
        self.label_indent_ctor_init = QtWidgets.QLabel(label("<hr>"+self.tr("Additional indent for constructor initializer list.\nNegative values decrease indent down to the first column.", "indent_ctor_init")))
        self.label_indent_ctor_init.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_ctor_init, 69, 0, 1, 2)
        self.label_option_indent_ctor_init = QtWidgets.QLabel("indent_ctor_init")
        self.label_option_indent_ctor_init.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_ctor_init, 70, 0)
        self.option_indent_ctor_init =  QtWidgets.QSpinBox()
        self.option_indent_ctor_init.setMinimum( -16)
        self.option_indent_ctor_init.setMaximum( 16)
        self.option_indent_ctor_init.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_ctor_init, 70, 1)
        #--------------------------------------------
        self.label_indent_else_if = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent 'if' following 'else' as a new block under the 'else'.\nIf false, 'else\\nif' is treated as 'else if' for indenting purposes.", "indent_else_if")))
        self.label_indent_else_if.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_else_if, 71, 0, 1, 2)
        self.label_option_indent_else_if = QtWidgets.QLabel("indent_else_if")
        self.label_option_indent_else_if.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_else_if, 72, 0)
        self.option_indent_else_if =  QtWidgets.QComboBox()
        self.option_indent_else_if.addItems(['true','false'])
        self.option_indent_else_if.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_else_if, 72, 1)
        #--------------------------------------------
        self.label_indent_var_def_blk = QtWidgets.QLabel(label("<hr>"+self.tr("Amount to indent variable declarations after a open brace.", "indent_var_def_blk")+"\n\n"+self.tr(" <0: Relative\n>=0: Absolute", "indent_var_def_blk")))
        self.label_indent_var_def_blk.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_var_def_blk, 73, 0, 1, 2)
        self.label_option_indent_var_def_blk = QtWidgets.QLabel("indent_var_def_blk")
        self.label_option_indent_var_def_blk.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_var_def_blk, 74, 0)
        self.option_indent_var_def_blk =  QtWidgets.QSpinBox()
        self.option_indent_var_def_blk.setMinimum( -16)
        self.option_indent_var_def_blk.setMaximum( 16)
        self.option_indent_var_def_blk.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_var_def_blk, 74, 1)
        #--------------------------------------------
        self.label_indent_var_def_cont = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent continued variable declarations instead of aligning.", "indent_var_def_cont")))
        self.label_indent_var_def_cont.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_var_def_cont, 75, 0, 1, 2)
        self.label_option_indent_var_def_cont = QtWidgets.QLabel("indent_var_def_cont")
        self.label_option_indent_var_def_cont.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_var_def_cont, 76, 0)
        self.option_indent_var_def_cont =  QtWidgets.QComboBox()
        self.option_indent_var_def_cont.addItems(['true','false'])
        self.option_indent_var_def_cont.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_var_def_cont, 76, 1)
        #--------------------------------------------
        self.label_indent_shift = QtWidgets.QLabel(label("<hr>"+self.tr("How to indent continued shift expressions ('<<' and '>>').\nSet align_left_shift=false when using this.\n 0: Align shift operators instead of indenting them (default)\n 1: Indent by one level\n-1: Preserve original indentation", "indent_shift")))
        self.label_indent_shift.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_shift, 77, 0, 1, 2)
        self.label_option_indent_shift = QtWidgets.QLabel("indent_shift")
        self.label_option_indent_shift.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_shift, 78, 0)
        self.option_indent_shift =  QtWidgets.QSpinBox()
        self.option_indent_shift.setMinimum( -1)
        self.option_indent_shift.setMaximum( 1)
        self.option_indent_shift.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_shift, 78, 1)
        #--------------------------------------------
        self.label_indent_func_def_force_col1 = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to force indentation of function definitions to start in column 1.", "indent_func_def_force_col1")))
        self.label_indent_func_def_force_col1.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_func_def_force_col1, 79, 0, 1, 2)
        self.label_option_indent_func_def_force_col1 = QtWidgets.QLabel("indent_func_def_force_col1")
        self.label_option_indent_func_def_force_col1.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_func_def_force_col1, 80, 0)
        self.option_indent_func_def_force_col1 =  QtWidgets.QComboBox()
        self.option_indent_func_def_force_col1.addItems(['true','false'])
        self.option_indent_func_def_force_col1.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_func_def_force_col1, 80, 1)
        #--------------------------------------------
        self.label_indent_func_call_param = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent continued function call parameters one indent level,\nrather than aligning parameters under the open parenthesis.", "indent_func_call_param")))
        self.label_indent_func_call_param.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_func_call_param, 81, 0, 1, 2)
        self.label_option_indent_func_call_param = QtWidgets.QLabel("indent_func_call_param")
        self.label_option_indent_func_call_param.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_func_call_param, 82, 0)
        self.option_indent_func_call_param =  QtWidgets.QComboBox()
        self.option_indent_func_call_param.addItems(['true','false'])
        self.option_indent_func_call_param.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_func_call_param, 82, 1)
        #--------------------------------------------
        self.label_indent_func_def_param = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent continued function definition parameters one indent level,\nrather than aligning parameters under the open parenthesis.", "indent_func_def_param")))
        self.label_indent_func_def_param.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_func_def_param, 83, 0, 1, 2)
        self.label_option_indent_func_def_param = QtWidgets.QLabel("indent_func_def_param")
        self.label_option_indent_func_def_param.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_func_def_param, 84, 0)
        self.option_indent_func_def_param =  QtWidgets.QComboBox()
        self.option_indent_func_def_param.addItems(['true','false'])
        self.option_indent_func_def_param.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_func_def_param, 84, 1)
        #--------------------------------------------
        self.label_indent_func_def_param_paren_pos_threshold = QtWidgets.QLabel(label("<hr>"+self.tr("for function definitions, only if indent_func_def_param is false\nAllows to align params when appropriate and indent them when not\nbehave as if it was true if paren position is more than this value\nif paren position is more than the option value", "indent_func_def_param_paren_pos_threshold")))
        self.label_indent_func_def_param_paren_pos_threshold.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_func_def_param_paren_pos_threshold, 85, 0, 1, 2)
        self.label_option_indent_func_def_param_paren_pos_threshold = QtWidgets.QLabel("indent_func_def_param_paren_pos_threshold")
        self.label_option_indent_func_def_param_paren_pos_threshold.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_func_def_param_paren_pos_threshold, 86, 0)
        self.option_indent_func_def_param_paren_pos_threshold =  QtWidgets.QSpinBox()
        self.option_indent_func_def_param_paren_pos_threshold.setMinimum( 0)
        self.option_indent_func_def_param_paren_pos_threshold.setMaximum( 160)
        self.option_indent_func_def_param_paren_pos_threshold.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_func_def_param_paren_pos_threshold, 86, 1)
        #--------------------------------------------
        self.label_indent_func_proto_param = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent continued function call prototype one indent level,\nrather than aligning parameters under the open parenthesis.", "indent_func_proto_param")))
        self.label_indent_func_proto_param.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_func_proto_param, 87, 0, 1, 2)
        self.label_option_indent_func_proto_param = QtWidgets.QLabel("indent_func_proto_param")
        self.label_option_indent_func_proto_param.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_func_proto_param, 88, 0)
        self.option_indent_func_proto_param =  QtWidgets.QComboBox()
        self.option_indent_func_proto_param.addItems(['true','false'])
        self.option_indent_func_proto_param.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_func_proto_param, 88, 1)
        #--------------------------------------------
        self.label_indent_func_class_param = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent continued function call declaration one indent level,\nrather than aligning parameters under the open parenthesis.", "indent_func_class_param")))
        self.label_indent_func_class_param.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_func_class_param, 89, 0, 1, 2)
        self.label_option_indent_func_class_param = QtWidgets.QLabel("indent_func_class_param")
        self.label_option_indent_func_class_param.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_func_class_param, 90, 0)
        self.option_indent_func_class_param =  QtWidgets.QComboBox()
        self.option_indent_func_class_param.addItems(['true','false'])
        self.option_indent_func_class_param.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_func_class_param, 90, 1)
        #--------------------------------------------
        self.label_indent_func_ctor_var_param = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent continued class variable constructors one indent level,\nrather than aligning parameters under the open parenthesis.", "indent_func_ctor_var_param")))
        self.label_indent_func_ctor_var_param.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_func_ctor_var_param, 91, 0, 1, 2)
        self.label_option_indent_func_ctor_var_param = QtWidgets.QLabel("indent_func_ctor_var_param")
        self.label_option_indent_func_ctor_var_param.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_func_ctor_var_param, 92, 0)
        self.option_indent_func_ctor_var_param =  QtWidgets.QComboBox()
        self.option_indent_func_ctor_var_param.addItems(['true','false'])
        self.option_indent_func_ctor_var_param.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_func_ctor_var_param, 92, 1)
        #--------------------------------------------
        self.label_indent_template_param = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent continued template parameter list one indent level,\nrather than aligning parameters under the open parenthesis.", "indent_template_param")))
        self.label_indent_template_param.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_template_param, 93, 0, 1, 2)
        self.label_option_indent_template_param = QtWidgets.QLabel("indent_template_param")
        self.label_option_indent_template_param.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_template_param, 94, 0)
        self.option_indent_template_param =  QtWidgets.QComboBox()
        self.option_indent_template_param.addItems(['true','false'])
        self.option_indent_template_param.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_template_param, 94, 1)
        #--------------------------------------------
        self.label_indent_func_param_double = QtWidgets.QLabel(label("<hr>"+self.tr("Double the indent for indent_func_xxx_param options.\nUse both values of the options indent_columns and indent_param.", "indent_func_param_double")))
        self.label_indent_func_param_double.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_func_param_double, 95, 0, 1, 2)
        self.label_option_indent_func_param_double = QtWidgets.QLabel("indent_func_param_double")
        self.label_option_indent_func_param_double.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_func_param_double, 96, 0)
        self.option_indent_func_param_double =  QtWidgets.QComboBox()
        self.option_indent_func_param_double.addItems(['true','false'])
        self.option_indent_func_param_double.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_func_param_double, 96, 1)
        #--------------------------------------------
        self.label_indent_func_const = QtWidgets.QLabel(label("<hr>"+self.tr("Indentation column for standalone 'const' qualifier on a function\nprototype.", "indent_func_const")))
        self.label_indent_func_const.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_func_const, 97, 0, 1, 2)
        self.label_option_indent_func_const = QtWidgets.QLabel("indent_func_const")
        self.label_option_indent_func_const.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_func_const, 98, 0)
        self.option_indent_func_const =  QtWidgets.QSpinBox()
        self.option_indent_func_const.setMinimum( 0)
        self.option_indent_func_const.setMaximum( 69)
        self.option_indent_func_const.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_func_const, 98, 1)
        #--------------------------------------------
        self.label_indent_func_throw = QtWidgets.QLabel(label("<hr>"+self.tr("Indentation column for standalone 'throw' qualifier on a function\nprototype.", "indent_func_throw")))
        self.label_indent_func_throw.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_func_throw, 99, 0, 1, 2)
        self.label_option_indent_func_throw = QtWidgets.QLabel("indent_func_throw")
        self.label_option_indent_func_throw.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_func_throw, 100, 0)
        self.option_indent_func_throw =  QtWidgets.QSpinBox()
        self.option_indent_func_throw.setMinimum( 0)
        self.option_indent_func_throw.setMaximum( 41)
        self.option_indent_func_throw.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_func_throw, 100, 1)
        #--------------------------------------------
        self.label_indent_macro_brace = QtWidgets.QLabel(label("<hr>"+self.tr("How to indent within a macro followed by a brace on the same line\nThis allows reducing the indent in macros that have (for example)\n`do { ... } while (0)` blocks bracketing them.", "indent_macro_brace")+"\n\n"+self.tr("true:  add an indent for the brace on the same line as the macro\nfalse: do not add an indent for the brace on the same line as the macro", "indent_macro_brace")))
        self.label_indent_macro_brace.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_macro_brace, 101, 0, 1, 2)
        self.label_option_indent_macro_brace = QtWidgets.QLabel("indent_macro_brace")
        self.label_option_indent_macro_brace.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_macro_brace, 102, 0)
        self.option_indent_macro_brace =  QtWidgets.QComboBox()
        self.option_indent_macro_brace.addItems(['true','false'])
        self.option_indent_macro_brace.setCurrentText("true")
        self.group_page_layout_3.addWidget(self.option_indent_macro_brace, 102, 1)
        #--------------------------------------------
        self.label_indent_member = QtWidgets.QLabel(label("<hr>"+self.tr("The number of spaces to indent a continued '->' or '.'.\nUsually set to 0, 1, or indent_columns.", "indent_member")))
        self.label_indent_member.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_member, 103, 0, 1, 2)
        self.label_option_indent_member = QtWidgets.QLabel("indent_member")
        self.label_option_indent_member.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_member, 104, 0)
        self.option_indent_member =  QtWidgets.QSpinBox()
        self.option_indent_member.setMinimum( 0)
        self.option_indent_member.setMaximum( 16)
        self.option_indent_member.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_member, 104, 1)
        #--------------------------------------------
        self.label_indent_member_single = QtWidgets.QLabel(label("<hr>"+self.tr("Whether lines broken at '.' or '->' should be indented by a single indent.\nThe indent_member option will not be effective if this is set to true.", "indent_member_single")))
        self.label_indent_member_single.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_member_single, 105, 0, 1, 2)
        self.label_option_indent_member_single = QtWidgets.QLabel("indent_member_single")
        self.label_option_indent_member_single.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_member_single, 106, 0)
        self.option_indent_member_single =  QtWidgets.QComboBox()
        self.option_indent_member_single.addItems(['true','false'])
        self.option_indent_member_single.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_member_single, 106, 1)
        #--------------------------------------------
        self.label_indent_single_line_comments_before = QtWidgets.QLabel(label("<hr>"+self.tr("Spaces to indent single line ('//') comments on lines before code.", "indent_single_line_comments_before")))
        self.label_indent_single_line_comments_before.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_single_line_comments_before, 107, 0, 1, 2)
        self.label_option_indent_single_line_comments_before = QtWidgets.QLabel("indent_single_line_comments_before")
        self.label_option_indent_single_line_comments_before.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_single_line_comments_before, 108, 0)
        self.option_indent_single_line_comments_before =  QtWidgets.QSpinBox()
        self.option_indent_single_line_comments_before.setMinimum( 0)
        self.option_indent_single_line_comments_before.setMaximum( 16)
        self.option_indent_single_line_comments_before.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_single_line_comments_before, 108, 1)
        #--------------------------------------------
        self.label_indent_single_line_comments_after = QtWidgets.QLabel(label("<hr>"+self.tr("Spaces to indent single line ('//') comments on lines after code.", "indent_single_line_comments_after")))
        self.label_indent_single_line_comments_after.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_single_line_comments_after, 109, 0, 1, 2)
        self.label_option_indent_single_line_comments_after = QtWidgets.QLabel("indent_single_line_comments_after")
        self.label_option_indent_single_line_comments_after.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_single_line_comments_after, 110, 0)
        self.option_indent_single_line_comments_after =  QtWidgets.QSpinBox()
        self.option_indent_single_line_comments_after.setMinimum( 0)
        self.option_indent_single_line_comments_after.setMaximum( 16)
        self.option_indent_single_line_comments_after.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_single_line_comments_after, 110, 1)
        #--------------------------------------------
        self.label_indent_sparen_extra = QtWidgets.QLabel(label("<hr>"+self.tr("When opening a paren for a control statement (if, for, while, etc), increase\nthe indent level by this value. Negative values decrease the indent level.", "indent_sparen_extra")))
        self.label_indent_sparen_extra.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_sparen_extra, 111, 0, 1, 2)
        self.label_option_indent_sparen_extra = QtWidgets.QLabel("indent_sparen_extra")
        self.label_option_indent_sparen_extra.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_sparen_extra, 112, 0)
        self.option_indent_sparen_extra =  QtWidgets.QSpinBox()
        self.option_indent_sparen_extra.setMinimum( -16)
        self.option_indent_sparen_extra.setMaximum( 16)
        self.option_indent_sparen_extra.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_sparen_extra, 112, 1)
        #--------------------------------------------
        self.label_indent_relative_single_line_comments = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent trailing single line ('//') comments relative to the code\ninstead of trying to keep the same absolute column.", "indent_relative_single_line_comments")))
        self.label_indent_relative_single_line_comments.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_relative_single_line_comments, 113, 0, 1, 2)
        self.label_option_indent_relative_single_line_comments = QtWidgets.QLabel("indent_relative_single_line_comments")
        self.label_option_indent_relative_single_line_comments.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_relative_single_line_comments, 114, 0)
        self.option_indent_relative_single_line_comments =  QtWidgets.QComboBox()
        self.option_indent_relative_single_line_comments.addItems(['true','false'])
        self.option_indent_relative_single_line_comments.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_relative_single_line_comments, 114, 1)
        #--------------------------------------------
        self.label_indent_switch_case = QtWidgets.QLabel(label("<hr>"+self.tr("Spaces to indent 'case' from 'switch'. Usually 0 or indent_columns.\nIt might be wise to choose the same value for the option indent_case_brace.", "indent_switch_case")))
        self.label_indent_switch_case.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_switch_case, 115, 0, 1, 2)
        self.label_option_indent_switch_case = QtWidgets.QLabel("indent_switch_case")
        self.label_option_indent_switch_case.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_switch_case, 116, 0)
        self.option_indent_switch_case =  QtWidgets.QSpinBox()
        self.option_indent_switch_case.setMinimum( 0)
        self.option_indent_switch_case.setMaximum( 16)
        self.option_indent_switch_case.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_switch_case, 116, 1)
        #--------------------------------------------
        self.label_indent_switch_body = QtWidgets.QLabel(label("<hr>"+self.tr("Spaces to indent the body of a 'switch' before any 'case'.\nUsually the same as indent_columns or indent_switch_case.", "indent_switch_body")))
        self.label_indent_switch_body.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_switch_body, 117, 0, 1, 2)
        self.label_option_indent_switch_body = QtWidgets.QLabel("indent_switch_body")
        self.label_option_indent_switch_body.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_switch_body, 118, 0)
        self.option_indent_switch_body =  QtWidgets.QSpinBox()
        self.option_indent_switch_body.setMinimum( 0)
        self.option_indent_switch_body.setMaximum( 16)
        self.option_indent_switch_body.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_switch_body, 118, 1)
        #--------------------------------------------
        self.label_indent_ignore_case_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to ignore indent for '{' following 'case'.", "indent_ignore_case_brace")))
        self.label_indent_ignore_case_brace.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_ignore_case_brace, 119, 0, 1, 2)
        self.label_option_indent_ignore_case_brace = QtWidgets.QLabel("indent_ignore_case_brace")
        self.label_option_indent_ignore_case_brace.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_ignore_case_brace, 120, 0)
        self.option_indent_ignore_case_brace =  QtWidgets.QComboBox()
        self.option_indent_ignore_case_brace.addItems(['true','false'])
        self.option_indent_ignore_case_brace.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_ignore_case_brace, 120, 1)
        #--------------------------------------------
        self.label_indent_case_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Spaces to indent '{' from 'case'. By default, the brace will appear under\nthe 'c' in case. Usually set to 0 or indent_columns. Negative values are OK.\nIt might be wise to choose the same value for the option indent_switch_case.", "indent_case_brace")))
        self.label_indent_case_brace.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_case_brace, 121, 0, 1, 2)
        self.label_option_indent_case_brace = QtWidgets.QLabel("indent_case_brace")
        self.label_option_indent_case_brace.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_case_brace, 122, 0)
        self.option_indent_case_brace =  QtWidgets.QSpinBox()
        self.option_indent_case_brace.setMinimum( -16)
        self.option_indent_case_brace.setMaximum( 16)
        self.option_indent_case_brace.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_case_brace, 122, 1)
        #--------------------------------------------
        self.label_indent_switch_break_with_case = QtWidgets.QLabel(label("<hr>"+self.tr("indent 'break' with 'case' from 'switch'.", "indent_switch_break_with_case")))
        self.label_indent_switch_break_with_case.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_switch_break_with_case, 123, 0, 1, 2)
        self.label_option_indent_switch_break_with_case = QtWidgets.QLabel("indent_switch_break_with_case")
        self.label_option_indent_switch_break_with_case.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_switch_break_with_case, 124, 0)
        self.option_indent_switch_break_with_case =  QtWidgets.QComboBox()
        self.option_indent_switch_break_with_case.addItems(['true','false'])
        self.option_indent_switch_break_with_case.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_switch_break_with_case, 124, 1)
        #--------------------------------------------
        self.label_indent_switch_pp = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent preprocessor statements inside of switch statements.", "indent_switch_pp")))
        self.label_indent_switch_pp.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_switch_pp, 125, 0, 1, 2)
        self.label_option_indent_switch_pp = QtWidgets.QLabel("indent_switch_pp")
        self.label_option_indent_switch_pp.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_switch_pp, 126, 0)
        self.option_indent_switch_pp =  QtWidgets.QComboBox()
        self.option_indent_switch_pp.addItems(['true','false'])
        self.option_indent_switch_pp.setCurrentText("true")
        self.group_page_layout_3.addWidget(self.option_indent_switch_pp, 126, 1)
        #--------------------------------------------
        self.label_indent_case_shift = QtWidgets.QLabel(label("<hr>"+self.tr("Spaces to shift the 'case' line, without affecting any other lines.\nUsually 0.", "indent_case_shift")))
        self.label_indent_case_shift.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_case_shift, 127, 0, 1, 2)
        self.label_option_indent_case_shift = QtWidgets.QLabel("indent_case_shift")
        self.label_option_indent_case_shift.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_case_shift, 128, 0)
        self.option_indent_case_shift =  QtWidgets.QSpinBox()
        self.option_indent_case_shift.setMinimum( 0)
        self.option_indent_case_shift.setMaximum( 16)
        self.option_indent_case_shift.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_case_shift, 128, 1)
        #--------------------------------------------
        self.label_indent_case_comment = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to align comments before 'case' with the 'case'.", "indent_case_comment")))
        self.label_indent_case_comment.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_case_comment, 129, 0, 1, 2)
        self.label_option_indent_case_comment = QtWidgets.QLabel("indent_case_comment")
        self.label_option_indent_case_comment.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_case_comment, 130, 0)
        self.option_indent_case_comment =  QtWidgets.QComboBox()
        self.option_indent_case_comment.addItems(['true','false'])
        self.option_indent_case_comment.setCurrentText("true")
        self.group_page_layout_3.addWidget(self.option_indent_case_comment, 130, 1)
        #--------------------------------------------
        self.label_indent_comment = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent comments not found in first column.", "indent_comment")))
        self.label_indent_comment.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_comment, 131, 0, 1, 2)
        self.label_option_indent_comment = QtWidgets.QLabel("indent_comment")
        self.label_option_indent_comment.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_comment, 132, 0)
        self.option_indent_comment =  QtWidgets.QComboBox()
        self.option_indent_comment.addItems(['true','false'])
        self.option_indent_comment.setCurrentText("true")
        self.group_page_layout_3.addWidget(self.option_indent_comment, 132, 1)
        #--------------------------------------------
        self.label_indent_col1_comment = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent comments found in first column.", "indent_col1_comment")))
        self.label_indent_col1_comment.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_col1_comment, 133, 0, 1, 2)
        self.label_option_indent_col1_comment = QtWidgets.QLabel("indent_col1_comment")
        self.label_option_indent_col1_comment.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_col1_comment, 134, 0)
        self.option_indent_col1_comment =  QtWidgets.QComboBox()
        self.option_indent_col1_comment.addItems(['true','false'])
        self.option_indent_col1_comment.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_col1_comment, 134, 1)
        #--------------------------------------------
        self.label_indent_col1_multi_string_literal = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent multi string literal in first column.", "indent_col1_multi_string_literal")))
        self.label_indent_col1_multi_string_literal.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_col1_multi_string_literal, 135, 0, 1, 2)
        self.label_option_indent_col1_multi_string_literal = QtWidgets.QLabel("indent_col1_multi_string_literal")
        self.label_option_indent_col1_multi_string_literal.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_col1_multi_string_literal, 136, 0)
        self.option_indent_col1_multi_string_literal =  QtWidgets.QComboBox()
        self.option_indent_col1_multi_string_literal.addItems(['true','false'])
        self.option_indent_col1_multi_string_literal.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_col1_multi_string_literal, 136, 1)
        #--------------------------------------------
        self.label_indent_comment_align_thresh = QtWidgets.QLabel(label("<hr>"+self.tr("Align comments on adjacent lines that are this many columns apart or less.", "indent_comment_align_thresh")))
        self.label_indent_comment_align_thresh.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_comment_align_thresh, 137, 0, 1, 2)
        self.label_option_indent_comment_align_thresh = QtWidgets.QLabel("indent_comment_align_thresh")
        self.label_option_indent_comment_align_thresh.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_comment_align_thresh, 138, 0)
        self.option_indent_comment_align_thresh =  QtWidgets.QSpinBox()
        self.option_indent_comment_align_thresh.setMinimum( 0)
        self.option_indent_comment_align_thresh.setMaximum( 16)
        self.option_indent_comment_align_thresh.setValue(3)
        self.group_page_layout_3.addWidget(self.option_indent_comment_align_thresh, 138, 1)
        #--------------------------------------------
        self.label_indent_ignore_label = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to ignore indent for goto labels.", "indent_ignore_label")))
        self.label_indent_ignore_label.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_ignore_label, 139, 0, 1, 2)
        self.label_option_indent_ignore_label = QtWidgets.QLabel("indent_ignore_label")
        self.label_option_indent_ignore_label.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_ignore_label, 140, 0)
        self.option_indent_ignore_label =  QtWidgets.QComboBox()
        self.option_indent_ignore_label.addItems(['true','false'])
        self.option_indent_ignore_label.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_ignore_label, 140, 1)
        #--------------------------------------------
        self.label_indent_label = QtWidgets.QLabel(label("<hr>"+self.tr("How to indent goto labels. Requires indent_ignore_label=false.", "indent_label")+"\n\n"+self.tr(" >0: Absolute column where 1 is the leftmost column\n<=0: Subtract from brace indent", "indent_label")))
        self.label_indent_label.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_label, 141, 0, 1, 2)
        self.label_option_indent_label = QtWidgets.QLabel("indent_label")
        self.label_option_indent_label.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_label, 142, 0)
        self.option_indent_label =  QtWidgets.QSpinBox()
        self.option_indent_label.setMinimum( -16)
        self.option_indent_label.setMaximum( 16)
        self.option_indent_label.setValue(1)
        self.group_page_layout_3.addWidget(self.option_indent_label, 142, 1)
        #--------------------------------------------
        self.label_indent_access_spec = QtWidgets.QLabel(label("<hr>"+self.tr("How to indent access specifiers that are followed by a\ncolon.", "indent_access_spec")+"\n\n"+self.tr(" >0: Absolute column where 1 is the leftmost column\n<=0: Subtract from brace indent", "indent_access_spec")))
        self.label_indent_access_spec.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_access_spec, 143, 0, 1, 2)
        self.label_option_indent_access_spec = QtWidgets.QLabel("indent_access_spec")
        self.label_option_indent_access_spec.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_access_spec, 144, 0)
        self.option_indent_access_spec =  QtWidgets.QSpinBox()
        self.option_indent_access_spec.setMinimum( -16)
        self.option_indent_access_spec.setMaximum( 16)
        self.option_indent_access_spec.setValue(1)
        self.group_page_layout_3.addWidget(self.option_indent_access_spec, 144, 1)
        #--------------------------------------------
        self.label_indent_access_spec_body = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent the code after an access specifier by one level.\nIf true, this option forces 'indent_access_spec=0'.", "indent_access_spec_body")))
        self.label_indent_access_spec_body.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_access_spec_body, 145, 0, 1, 2)
        self.label_option_indent_access_spec_body = QtWidgets.QLabel("indent_access_spec_body")
        self.label_option_indent_access_spec_body.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_access_spec_body, 146, 0)
        self.option_indent_access_spec_body =  QtWidgets.QComboBox()
        self.option_indent_access_spec_body.addItems(['true','false'])
        self.option_indent_access_spec_body.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_access_spec_body, 146, 1)
        #--------------------------------------------
        self.label_indent_paren_nl = QtWidgets.QLabel(label("<hr>"+self.tr("If an open parenthesis is followed by a newline, whether to indent the next\nline so that it lines up after the open parenthesis (not recommended).", "indent_paren_nl")))
        self.label_indent_paren_nl.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_paren_nl, 147, 0, 1, 2)
        self.label_option_indent_paren_nl = QtWidgets.QLabel("indent_paren_nl")
        self.label_option_indent_paren_nl.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_paren_nl, 148, 0)
        self.option_indent_paren_nl =  QtWidgets.QComboBox()
        self.option_indent_paren_nl.addItems(['true','false'])
        self.option_indent_paren_nl.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_paren_nl, 148, 1)
        #--------------------------------------------
        self.label_indent_paren_close = QtWidgets.QLabel(label("<hr>"+self.tr("How to indent a close parenthesis after a newline.", "indent_paren_close")+"\n\n"+self.tr(" 0: Indent to body level (default)\n 1: Align under the open parenthesis\n 2: Indent to the brace level\n-1: Preserve original indentation", "indent_paren_close")))
        self.label_indent_paren_close.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_paren_close, 149, 0, 1, 2)
        self.label_option_indent_paren_close = QtWidgets.QLabel("indent_paren_close")
        self.label_option_indent_paren_close.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_paren_close, 150, 0)
        self.option_indent_paren_close =  QtWidgets.QSpinBox()
        self.option_indent_paren_close.setMinimum( -1)
        self.option_indent_paren_close.setMaximum( 2)
        self.option_indent_paren_close.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_paren_close, 150, 1)
        #--------------------------------------------
        self.label_indent_paren_after_func_def = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent the open parenthesis of a function definition,\nif the parenthesis is on its own line.", "indent_paren_after_func_def")))
        self.label_indent_paren_after_func_def.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_paren_after_func_def, 151, 0, 1, 2)
        self.label_option_indent_paren_after_func_def = QtWidgets.QLabel("indent_paren_after_func_def")
        self.label_option_indent_paren_after_func_def.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_paren_after_func_def, 152, 0)
        self.option_indent_paren_after_func_def =  QtWidgets.QComboBox()
        self.option_indent_paren_after_func_def.addItems(['true','false'])
        self.option_indent_paren_after_func_def.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_paren_after_func_def, 152, 1)
        #--------------------------------------------
        self.label_indent_paren_after_func_decl = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent the open parenthesis of a function declaration,\nif the parenthesis is on its own line.", "indent_paren_after_func_decl")))
        self.label_indent_paren_after_func_decl.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_paren_after_func_decl, 153, 0, 1, 2)
        self.label_option_indent_paren_after_func_decl = QtWidgets.QLabel("indent_paren_after_func_decl")
        self.label_option_indent_paren_after_func_decl.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_paren_after_func_decl, 154, 0)
        self.option_indent_paren_after_func_decl =  QtWidgets.QComboBox()
        self.option_indent_paren_after_func_decl.addItems(['true','false'])
        self.option_indent_paren_after_func_decl.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_paren_after_func_decl, 154, 1)
        #--------------------------------------------
        self.label_indent_paren_after_func_call = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent the open parenthesis of a function call,\nif the parenthesis is on its own line.", "indent_paren_after_func_call")))
        self.label_indent_paren_after_func_call.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_paren_after_func_call, 155, 0, 1, 2)
        self.label_option_indent_paren_after_func_call = QtWidgets.QLabel("indent_paren_after_func_call")
        self.label_option_indent_paren_after_func_call.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_paren_after_func_call, 156, 0)
        self.option_indent_paren_after_func_call =  QtWidgets.QComboBox()
        self.option_indent_paren_after_func_call.addItems(['true','false'])
        self.option_indent_paren_after_func_call.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_paren_after_func_call, 156, 1)
        #--------------------------------------------
        self.label_indent_comma_brace = QtWidgets.QLabel(label("<hr>"+self.tr("How to indent a comma when inside braces.\n 0: Indent by one level (default)\n 1: Align under the open brace\n-1: Preserve original indentation", "indent_comma_brace")))
        self.label_indent_comma_brace.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_comma_brace, 157, 0, 1, 2)
        self.label_option_indent_comma_brace = QtWidgets.QLabel("indent_comma_brace")
        self.label_option_indent_comma_brace.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_comma_brace, 158, 0)
        self.option_indent_comma_brace =  QtWidgets.QSpinBox()
        self.option_indent_comma_brace.setMinimum( -1)
        self.option_indent_comma_brace.setMaximum( 1)
        self.option_indent_comma_brace.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_comma_brace, 158, 1)
        #--------------------------------------------
        self.label_indent_comma_paren = QtWidgets.QLabel(label("<hr>"+self.tr("How to indent a comma when inside parentheses.\n 0: Indent by one level (default)\n 1: Align under the open parenthesis\n-1: Preserve original indentation", "indent_comma_paren")))
        self.label_indent_comma_paren.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_comma_paren, 159, 0, 1, 2)
        self.label_option_indent_comma_paren = QtWidgets.QLabel("indent_comma_paren")
        self.label_option_indent_comma_paren.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_comma_paren, 160, 0)
        self.option_indent_comma_paren =  QtWidgets.QSpinBox()
        self.option_indent_comma_paren.setMinimum( -1)
        self.option_indent_comma_paren.setMaximum( 1)
        self.option_indent_comma_paren.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_comma_paren, 160, 1)
        #--------------------------------------------
        self.label_indent_bool_paren = QtWidgets.QLabel(label("<hr>"+self.tr("How to indent a Boolean operator when inside parentheses.\n 0: Indent by one level (default)\n 1: Align under the open parenthesis\n-1: Preserve original indentation", "indent_bool_paren")))
        self.label_indent_bool_paren.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_bool_paren, 161, 0, 1, 2)
        self.label_option_indent_bool_paren = QtWidgets.QLabel("indent_bool_paren")
        self.label_option_indent_bool_paren.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_bool_paren, 162, 0)
        self.option_indent_bool_paren =  QtWidgets.QSpinBox()
        self.option_indent_bool_paren.setMinimum( -1)
        self.option_indent_bool_paren.setMaximum( 1)
        self.option_indent_bool_paren.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_bool_paren, 162, 1)
        #--------------------------------------------
        self.label_indent_ignore_bool = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to ignore the indentation of a Boolean operator when outside\nparentheses.", "indent_ignore_bool")))
        self.label_indent_ignore_bool.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_ignore_bool, 163, 0, 1, 2)
        self.label_option_indent_ignore_bool = QtWidgets.QLabel("indent_ignore_bool")
        self.label_option_indent_ignore_bool.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_ignore_bool, 164, 0)
        self.option_indent_ignore_bool =  QtWidgets.QComboBox()
        self.option_indent_ignore_bool.addItems(['true','false'])
        self.option_indent_ignore_bool.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_ignore_bool, 164, 1)
        #--------------------------------------------
        self.label_indent_ignore_arith = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to ignore the indentation of an arithmetic operator.", "indent_ignore_arith")))
        self.label_indent_ignore_arith.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_ignore_arith, 165, 0, 1, 2)
        self.label_option_indent_ignore_arith = QtWidgets.QLabel("indent_ignore_arith")
        self.label_option_indent_ignore_arith.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_ignore_arith, 166, 0)
        self.option_indent_ignore_arith =  QtWidgets.QComboBox()
        self.option_indent_ignore_arith.addItems(['true','false'])
        self.option_indent_ignore_arith.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_ignore_arith, 166, 1)
        #--------------------------------------------
        self.label_indent_semicolon_for_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent a semicolon when inside a for parenthesis.\nIf true, aligns under the open for parenthesis.", "indent_semicolon_for_paren")))
        self.label_indent_semicolon_for_paren.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_semicolon_for_paren, 167, 0, 1, 2)
        self.label_option_indent_semicolon_for_paren = QtWidgets.QLabel("indent_semicolon_for_paren")
        self.label_option_indent_semicolon_for_paren.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_semicolon_for_paren, 168, 0)
        self.option_indent_semicolon_for_paren =  QtWidgets.QComboBox()
        self.option_indent_semicolon_for_paren.addItems(['true','false'])
        self.option_indent_semicolon_for_paren.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_semicolon_for_paren, 168, 1)
        #--------------------------------------------
        self.label_indent_ignore_semicolon = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to ignore the indentation of a semicolon outside of a 'for'\nstatement.", "indent_ignore_semicolon")))
        self.label_indent_ignore_semicolon.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_ignore_semicolon, 169, 0, 1, 2)
        self.label_option_indent_ignore_semicolon = QtWidgets.QLabel("indent_ignore_semicolon")
        self.label_option_indent_ignore_semicolon.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_ignore_semicolon, 170, 0)
        self.option_indent_ignore_semicolon =  QtWidgets.QComboBox()
        self.option_indent_ignore_semicolon.addItems(['true','false'])
        self.option_indent_ignore_semicolon.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_ignore_semicolon, 170, 1)
        #--------------------------------------------
        self.label_indent_first_bool_expr = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to align the first expression to following ones\nif indent_bool_paren=1.", "indent_first_bool_expr")))
        self.label_indent_first_bool_expr.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_first_bool_expr, 171, 0, 1, 2)
        self.label_option_indent_first_bool_expr = QtWidgets.QLabel("indent_first_bool_expr")
        self.label_option_indent_first_bool_expr.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_first_bool_expr, 172, 0)
        self.option_indent_first_bool_expr =  QtWidgets.QComboBox()
        self.option_indent_first_bool_expr.addItems(['true','false'])
        self.option_indent_first_bool_expr.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_first_bool_expr, 172, 1)
        #--------------------------------------------
        self.label_indent_first_for_expr = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to align the first expression to following ones\nif indent_semicolon_for_paren=true.", "indent_first_for_expr")))
        self.label_indent_first_for_expr.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_first_for_expr, 173, 0, 1, 2)
        self.label_option_indent_first_for_expr = QtWidgets.QLabel("indent_first_for_expr")
        self.label_option_indent_first_for_expr.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_first_for_expr, 174, 0)
        self.option_indent_first_for_expr =  QtWidgets.QComboBox()
        self.option_indent_first_for_expr.addItems(['true','false'])
        self.option_indent_first_for_expr.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_first_for_expr, 174, 1)
        #--------------------------------------------
        self.label_indent_square_nl = QtWidgets.QLabel(label("<hr>"+self.tr("If an open square is followed by a newline, whether to indent the next line\nso that it lines up after the open square (not recommended).", "indent_square_nl")))
        self.label_indent_square_nl.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_square_nl, 175, 0, 1, 2)
        self.label_option_indent_square_nl = QtWidgets.QLabel("indent_square_nl")
        self.label_option_indent_square_nl.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_square_nl, 176, 0)
        self.option_indent_square_nl =  QtWidgets.QComboBox()
        self.option_indent_square_nl.addItems(['true','false'])
        self.option_indent_square_nl.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_square_nl, 176, 1)
        #--------------------------------------------
        self.label_indent_preserve_sql = QtWidgets.QLabel(label("<hr>"+self.tr("(ESQL/C) Whether to preserve the relative indent of 'EXEC SQL' bodies.", "indent_preserve_sql")))
        self.label_indent_preserve_sql.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_preserve_sql, 177, 0, 1, 2)
        self.label_option_indent_preserve_sql = QtWidgets.QLabel("indent_preserve_sql")
        self.label_option_indent_preserve_sql.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_preserve_sql, 178, 0)
        self.option_indent_preserve_sql =  QtWidgets.QComboBox()
        self.option_indent_preserve_sql.addItems(['true','false'])
        self.option_indent_preserve_sql.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_preserve_sql, 178, 1)
        #--------------------------------------------
        self.label_indent_ignore_assign = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to ignore the indentation of an assignment operator.", "indent_ignore_assign")))
        self.label_indent_ignore_assign.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_ignore_assign, 179, 0, 1, 2)
        self.label_option_indent_ignore_assign = QtWidgets.QLabel("indent_ignore_assign")
        self.label_option_indent_ignore_assign.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_ignore_assign, 180, 0)
        self.option_indent_ignore_assign =  QtWidgets.QComboBox()
        self.option_indent_ignore_assign.addItems(['true','false'])
        self.option_indent_ignore_assign.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_ignore_assign, 180, 1)
        #--------------------------------------------
        self.label_indent_align_assign = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to align continued statements at the '='. If false or if the '=' is\nfollowed by a newline, the next line is indent one tab.", "indent_align_assign")))
        self.label_indent_align_assign.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_align_assign, 181, 0, 1, 2)
        self.label_option_indent_align_assign = QtWidgets.QLabel("indent_align_assign")
        self.label_option_indent_align_assign.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_align_assign, 182, 0)
        self.option_indent_align_assign =  QtWidgets.QComboBox()
        self.option_indent_align_assign.addItems(['true','false'])
        self.option_indent_align_assign.setCurrentText("true")
        self.group_page_layout_3.addWidget(self.option_indent_align_assign, 182, 1)
        #--------------------------------------------
        self.label_indent_off_after_assign = QtWidgets.QLabel(label("<hr>"+self.tr("If true, the indentation of the chunks after a '=' sequence will be set at\nLHS token indentation column before '='.", "indent_off_after_assign")))
        self.label_indent_off_after_assign.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_off_after_assign, 183, 0, 1, 2)
        self.label_option_indent_off_after_assign = QtWidgets.QLabel("indent_off_after_assign")
        self.label_option_indent_off_after_assign.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_off_after_assign, 184, 0)
        self.option_indent_off_after_assign =  QtWidgets.QComboBox()
        self.option_indent_off_after_assign.addItems(['true','false'])
        self.option_indent_off_after_assign.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_off_after_assign, 184, 1)
        #--------------------------------------------
        self.label_indent_align_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to align continued statements at the '('. If false or the '(' is\nfollowed by a newline, the next line indent is one tab.", "indent_align_paren")))
        self.label_indent_align_paren.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_align_paren, 185, 0, 1, 2)
        self.label_option_indent_align_paren = QtWidgets.QLabel("indent_align_paren")
        self.label_option_indent_align_paren.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_align_paren, 186, 0)
        self.option_indent_align_paren =  QtWidgets.QComboBox()
        self.option_indent_align_paren.addItems(['true','false'])
        self.option_indent_align_paren.setCurrentText("true")
        self.group_page_layout_3.addWidget(self.option_indent_align_paren, 186, 1)
        #--------------------------------------------
        self.label_indent_oc_inside_msg_sel = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Whether to indent Objective-C code inside message selectors.", "indent_oc_inside_msg_sel")))
        self.label_indent_oc_inside_msg_sel.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_oc_inside_msg_sel, 187, 0, 1, 2)
        self.label_option_indent_oc_inside_msg_sel = QtWidgets.QLabel("indent_oc_inside_msg_sel")
        self.label_option_indent_oc_inside_msg_sel.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_oc_inside_msg_sel, 188, 0)
        self.option_indent_oc_inside_msg_sel =  QtWidgets.QComboBox()
        self.option_indent_oc_inside_msg_sel.addItems(['true','false'])
        self.option_indent_oc_inside_msg_sel.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_oc_inside_msg_sel, 188, 1)
        #--------------------------------------------
        self.label_indent_oc_block = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Whether to indent Objective-C blocks at brace level instead of usual\nrules.", "indent_oc_block")))
        self.label_indent_oc_block.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_oc_block, 189, 0, 1, 2)
        self.label_option_indent_oc_block = QtWidgets.QLabel("indent_oc_block")
        self.label_option_indent_oc_block.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_oc_block, 190, 0)
        self.option_indent_oc_block =  QtWidgets.QComboBox()
        self.option_indent_oc_block.addItems(['true','false'])
        self.option_indent_oc_block.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_oc_block, 190, 1)
        #--------------------------------------------
        self.label_indent_oc_block_msg = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Indent for Objective-C blocks in a message relative to the parameter\nname.", "indent_oc_block_msg")+"\n\n"+self.tr("=0: Use indent_oc_block rules\n>0: Use specified number of spaces to indent", "indent_oc_block_msg")))
        self.label_indent_oc_block_msg.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_oc_block_msg, 191, 0, 1, 2)
        self.label_option_indent_oc_block_msg = QtWidgets.QLabel("indent_oc_block_msg")
        self.label_option_indent_oc_block_msg.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_oc_block_msg, 192, 0)
        self.option_indent_oc_block_msg =  QtWidgets.QSpinBox()
        self.option_indent_oc_block_msg.setMinimum( 0)
        self.option_indent_oc_block_msg.setMaximum( 16)
        self.option_indent_oc_block_msg.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_oc_block_msg, 192, 1)
        #--------------------------------------------
        self.label_indent_oc_msg_colon = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Minimum indent for subsequent parameters", "indent_oc_msg_colon")))
        self.label_indent_oc_msg_colon.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_oc_msg_colon, 193, 0, 1, 2)
        self.label_option_indent_oc_msg_colon = QtWidgets.QLabel("indent_oc_msg_colon")
        self.label_option_indent_oc_msg_colon.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_oc_msg_colon, 194, 0)
        self.option_indent_oc_msg_colon =  QtWidgets.QSpinBox()
        self.option_indent_oc_msg_colon.setMinimum( 0)
        self.option_indent_oc_msg_colon.setMaximum( 5000)
        self.option_indent_oc_msg_colon.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_oc_msg_colon, 194, 1)
        #--------------------------------------------
        self.label_indent_oc_msg_prioritize_first_colon = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Whether to prioritize aligning with initial colon (and stripping spaces\nfrom lines, if necessary).", "indent_oc_msg_prioritize_first_colon")))
        self.label_indent_oc_msg_prioritize_first_colon.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_oc_msg_prioritize_first_colon, 195, 0, 1, 2)
        self.label_option_indent_oc_msg_prioritize_first_colon = QtWidgets.QLabel("indent_oc_msg_prioritize_first_colon")
        self.label_option_indent_oc_msg_prioritize_first_colon.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_oc_msg_prioritize_first_colon, 196, 0)
        self.option_indent_oc_msg_prioritize_first_colon =  QtWidgets.QComboBox()
        self.option_indent_oc_msg_prioritize_first_colon.addItems(['true','false'])
        self.option_indent_oc_msg_prioritize_first_colon.setCurrentText("true")
        self.group_page_layout_3.addWidget(self.option_indent_oc_msg_prioritize_first_colon, 196, 1)
        #--------------------------------------------
        self.label_indent_oc_block_msg_xcode_style = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Whether to indent blocks the way that Xcode does by default\n(from the keyword if the parameter is on its own line; otherwise, from the\nprevious indentation level). Requires indent_oc_block_msg=true.", "indent_oc_block_msg_xcode_style")))
        self.label_indent_oc_block_msg_xcode_style.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_oc_block_msg_xcode_style, 197, 0, 1, 2)
        self.label_option_indent_oc_block_msg_xcode_style = QtWidgets.QLabel("indent_oc_block_msg_xcode_style")
        self.label_option_indent_oc_block_msg_xcode_style.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_oc_block_msg_xcode_style, 198, 0)
        self.option_indent_oc_block_msg_xcode_style =  QtWidgets.QComboBox()
        self.option_indent_oc_block_msg_xcode_style.addItems(['true','false'])
        self.option_indent_oc_block_msg_xcode_style.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_oc_block_msg_xcode_style, 198, 1)
        #--------------------------------------------
        self.label_indent_oc_block_msg_from_keyword = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Whether to indent blocks from where the brace is, relative to a\nmessage keyword. Requires indent_oc_block_msg=true.", "indent_oc_block_msg_from_keyword")))
        self.label_indent_oc_block_msg_from_keyword.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_oc_block_msg_from_keyword, 199, 0, 1, 2)
        self.label_option_indent_oc_block_msg_from_keyword = QtWidgets.QLabel("indent_oc_block_msg_from_keyword")
        self.label_option_indent_oc_block_msg_from_keyword.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_oc_block_msg_from_keyword, 200, 0)
        self.option_indent_oc_block_msg_from_keyword =  QtWidgets.QComboBox()
        self.option_indent_oc_block_msg_from_keyword.addItems(['true','false'])
        self.option_indent_oc_block_msg_from_keyword.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_oc_block_msg_from_keyword, 200, 1)
        #--------------------------------------------
        self.label_indent_oc_block_msg_from_colon = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Whether to indent blocks from where the brace is, relative to a message\ncolon. Requires indent_oc_block_msg=true.", "indent_oc_block_msg_from_colon")))
        self.label_indent_oc_block_msg_from_colon.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_oc_block_msg_from_colon, 201, 0, 1, 2)
        self.label_option_indent_oc_block_msg_from_colon = QtWidgets.QLabel("indent_oc_block_msg_from_colon")
        self.label_option_indent_oc_block_msg_from_colon.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_oc_block_msg_from_colon, 202, 0)
        self.option_indent_oc_block_msg_from_colon =  QtWidgets.QComboBox()
        self.option_indent_oc_block_msg_from_colon.addItems(['true','false'])
        self.option_indent_oc_block_msg_from_colon.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_oc_block_msg_from_colon, 202, 1)
        #--------------------------------------------
        self.label_indent_oc_block_msg_from_caret = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Whether to indent blocks from where the block caret is.\nRequires indent_oc_block_msg=true.", "indent_oc_block_msg_from_caret")))
        self.label_indent_oc_block_msg_from_caret.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_oc_block_msg_from_caret, 203, 0, 1, 2)
        self.label_option_indent_oc_block_msg_from_caret = QtWidgets.QLabel("indent_oc_block_msg_from_caret")
        self.label_option_indent_oc_block_msg_from_caret.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_oc_block_msg_from_caret, 204, 0)
        self.option_indent_oc_block_msg_from_caret =  QtWidgets.QComboBox()
        self.option_indent_oc_block_msg_from_caret.addItems(['true','false'])
        self.option_indent_oc_block_msg_from_caret.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_oc_block_msg_from_caret, 204, 1)
        #--------------------------------------------
        self.label_indent_oc_block_msg_from_brace = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Whether to indent blocks from where the brace caret is.\nRequires indent_oc_block_msg=true.", "indent_oc_block_msg_from_brace")))
        self.label_indent_oc_block_msg_from_brace.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_oc_block_msg_from_brace, 205, 0, 1, 2)
        self.label_option_indent_oc_block_msg_from_brace = QtWidgets.QLabel("indent_oc_block_msg_from_brace")
        self.label_option_indent_oc_block_msg_from_brace.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_oc_block_msg_from_brace, 206, 0)
        self.option_indent_oc_block_msg_from_brace =  QtWidgets.QComboBox()
        self.option_indent_oc_block_msg_from_brace.addItems(['true','false'])
        self.option_indent_oc_block_msg_from_brace.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_oc_block_msg_from_brace, 206, 1)
        #--------------------------------------------
        self.label_indent_min_vbrace_open = QtWidgets.QLabel(label("<hr>"+self.tr("When indenting after virtual brace open and newline add further spaces to\nreach this minimum indent.", "indent_min_vbrace_open")))
        self.label_indent_min_vbrace_open.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_min_vbrace_open, 207, 0, 1, 2)
        self.label_option_indent_min_vbrace_open = QtWidgets.QLabel("indent_min_vbrace_open")
        self.label_option_indent_min_vbrace_open.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_min_vbrace_open, 208, 0)
        self.option_indent_min_vbrace_open =  QtWidgets.QSpinBox()
        self.option_indent_min_vbrace_open.setMinimum( 0)
        self.option_indent_min_vbrace_open.setMaximum( 16)
        self.option_indent_min_vbrace_open.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_min_vbrace_open, 208, 1)
        #--------------------------------------------
        self.label_indent_vbrace_open_on_tabstop = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add further spaces after regular indent to reach next tabstop\nwhen indenting after virtual brace open and newline.", "indent_vbrace_open_on_tabstop")))
        self.label_indent_vbrace_open_on_tabstop.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_vbrace_open_on_tabstop, 209, 0, 1, 2)
        self.label_option_indent_vbrace_open_on_tabstop = QtWidgets.QLabel("indent_vbrace_open_on_tabstop")
        self.label_option_indent_vbrace_open_on_tabstop.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_vbrace_open_on_tabstop, 210, 0)
        self.option_indent_vbrace_open_on_tabstop =  QtWidgets.QComboBox()
        self.option_indent_vbrace_open_on_tabstop.addItems(['true','false'])
        self.option_indent_vbrace_open_on_tabstop.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_vbrace_open_on_tabstop, 210, 1)
        #--------------------------------------------
        self.label_indent_token_after_brace = QtWidgets.QLabel(label("<hr>"+self.tr("How to indent after a brace followed by another token (not a newline).\ntrue:  indent all contained lines to match the token\nfalse: indent all contained lines to match the brace", "indent_token_after_brace")))
        self.label_indent_token_after_brace.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_token_after_brace, 211, 0, 1, 2)
        self.label_option_indent_token_after_brace = QtWidgets.QLabel("indent_token_after_brace")
        self.label_option_indent_token_after_brace.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_token_after_brace, 212, 0)
        self.option_indent_token_after_brace =  QtWidgets.QComboBox()
        self.option_indent_token_after_brace.addItems(['true','false'])
        self.option_indent_token_after_brace.setCurrentText("true")
        self.group_page_layout_3.addWidget(self.option_indent_token_after_brace, 212, 1)
        #--------------------------------------------
        self.label_indent_cpp_lambda_body = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent the body of a C++11 lambda.", "indent_cpp_lambda_body")))
        self.label_indent_cpp_lambda_body.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_cpp_lambda_body, 213, 0, 1, 2)
        self.label_option_indent_cpp_lambda_body = QtWidgets.QLabel("indent_cpp_lambda_body")
        self.label_option_indent_cpp_lambda_body.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_cpp_lambda_body, 214, 0)
        self.option_indent_cpp_lambda_body =  QtWidgets.QComboBox()
        self.option_indent_cpp_lambda_body.addItems(['true','false'])
        self.option_indent_cpp_lambda_body.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_cpp_lambda_body, 214, 1)
        #--------------------------------------------
        self.label_indent_compound_literal_return = QtWidgets.QLabel(label("<hr>"+self.tr("How to indent compound literals that are being returned.\ntrue: add both the indent from return & the compound literal open brace\n      (i.e. 2 indent levels)\nfalse: only indent 1 level, don't add the indent for the open brace, only\n       add the indent for the return.", "indent_compound_literal_return")))
        self.label_indent_compound_literal_return.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_compound_literal_return, 215, 0, 1, 2)
        self.label_option_indent_compound_literal_return = QtWidgets.QLabel("indent_compound_literal_return")
        self.label_option_indent_compound_literal_return.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_compound_literal_return, 216, 0)
        self.option_indent_compound_literal_return =  QtWidgets.QComboBox()
        self.option_indent_compound_literal_return.addItems(['true','false'])
        self.option_indent_compound_literal_return.setCurrentText("true")
        self.group_page_layout_3.addWidget(self.option_indent_compound_literal_return, 216, 1)
        #--------------------------------------------
        self.label_indent_using_block = QtWidgets.QLabel(label("<hr>"+self.tr("(C#) Whether to indent a 'using' block if no braces are used.", "indent_using_block")))
        self.label_indent_using_block.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_using_block, 217, 0, 1, 2)
        self.label_option_indent_using_block = QtWidgets.QLabel("indent_using_block")
        self.label_option_indent_using_block.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_using_block, 218, 0)
        self.option_indent_using_block =  QtWidgets.QComboBox()
        self.option_indent_using_block.addItems(['true','false'])
        self.option_indent_using_block.setCurrentText("true")
        self.group_page_layout_3.addWidget(self.option_indent_using_block, 218, 1)
        #--------------------------------------------
        self.label_indent_ternary_operator = QtWidgets.QLabel(label("<hr>"+self.tr("How to indent the continuation of ternary operator.", "indent_ternary_operator")+"\n\n"+self.tr("0: Off (default)\n1: When the `if_false` is a continuation, indent it under the `if_true` branch\n2: When the `:` is a continuation, indent it under `?`", "indent_ternary_operator")))
        self.label_indent_ternary_operator.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_ternary_operator, 219, 0, 1, 2)
        self.label_option_indent_ternary_operator = QtWidgets.QLabel("indent_ternary_operator")
        self.label_option_indent_ternary_operator.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_ternary_operator, 220, 0)
        self.option_indent_ternary_operator =  QtWidgets.QSpinBox()
        self.option_indent_ternary_operator.setMinimum( 0)
        self.option_indent_ternary_operator.setMaximum( 2)
        self.option_indent_ternary_operator.setValue(0)
        self.group_page_layout_3.addWidget(self.option_indent_ternary_operator, 220, 1)
        #--------------------------------------------
        self.label_indent_inside_ternary_operator = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent the statements inside ternary operator.", "indent_inside_ternary_operator")))
        self.label_indent_inside_ternary_operator.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_inside_ternary_operator, 221, 0, 1, 2)
        self.label_option_indent_inside_ternary_operator = QtWidgets.QLabel("indent_inside_ternary_operator")
        self.label_option_indent_inside_ternary_operator.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_inside_ternary_operator, 222, 0)
        self.option_indent_inside_ternary_operator =  QtWidgets.QComboBox()
        self.option_indent_inside_ternary_operator.addItems(['true','false'])
        self.option_indent_inside_ternary_operator.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_inside_ternary_operator, 222, 1)
        #--------------------------------------------
        self.label_indent_off_after_return = QtWidgets.QLabel(label("<hr>"+self.tr("If true, the indentation of the chunks after a `return` sequence will be set at return indentation column.", "indent_off_after_return")))
        self.label_indent_off_after_return.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_off_after_return, 223, 0, 1, 2)
        self.label_option_indent_off_after_return = QtWidgets.QLabel("indent_off_after_return")
        self.label_option_indent_off_after_return.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_off_after_return, 224, 0)
        self.option_indent_off_after_return =  QtWidgets.QComboBox()
        self.option_indent_off_after_return.addItems(['true','false'])
        self.option_indent_off_after_return.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_off_after_return, 224, 1)
        #--------------------------------------------
        self.label_indent_off_after_return_new = QtWidgets.QLabel(label("<hr>"+self.tr("If true, the indentation of the chunks after a `return new` sequence will be set at return indentation column.", "indent_off_after_return_new")))
        self.label_indent_off_after_return_new.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_off_after_return_new, 225, 0, 1, 2)
        self.label_option_indent_off_after_return_new = QtWidgets.QLabel("indent_off_after_return_new")
        self.label_option_indent_off_after_return_new.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_off_after_return_new, 226, 0)
        self.option_indent_off_after_return_new =  QtWidgets.QComboBox()
        self.option_indent_off_after_return_new.addItems(['true','false'])
        self.option_indent_off_after_return_new.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_off_after_return_new, 226, 1)
        #--------------------------------------------
        self.label_indent_single_after_return = QtWidgets.QLabel(label("<hr>"+self.tr("If true, the tokens after return are indented with regular single indentation. By default (false) the indentation is after the return token.", "indent_single_after_return")))
        self.label_indent_single_after_return.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_single_after_return, 227, 0, 1, 2)
        self.label_option_indent_single_after_return = QtWidgets.QLabel("indent_single_after_return")
        self.label_option_indent_single_after_return.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_single_after_return, 228, 0)
        self.option_indent_single_after_return =  QtWidgets.QComboBox()
        self.option_indent_single_after_return.addItems(['true','false'])
        self.option_indent_single_after_return.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_single_after_return, 228, 1)
        #--------------------------------------------
        self.label_indent_ignore_asm_block = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to ignore indent and alignment for 'asm' blocks (i.e. assume they\nhave their own indentation).", "indent_ignore_asm_block")))
        self.label_indent_ignore_asm_block.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_indent_ignore_asm_block, 229, 0, 1, 2)
        self.label_option_indent_ignore_asm_block = QtWidgets.QLabel("indent_ignore_asm_block")
        self.label_option_indent_ignore_asm_block.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_indent_ignore_asm_block, 230, 0)
        self.option_indent_ignore_asm_block =  QtWidgets.QComboBox()
        self.option_indent_ignore_asm_block.addItems(['true','false'])
        self.option_indent_ignore_asm_block.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_indent_ignore_asm_block, 230, 1)
        #--------------------------------------------
        self.label_donot_indent_func_def_close_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Don't indent the close parenthesis of a function definition,\nif the parenthesis is on its own line.", "donot_indent_func_def_close_paren")))
        self.label_donot_indent_func_def_close_paren.setWordWrap(True)
        self.group_page_layout_3.addWidget(self.label_donot_indent_func_def_close_paren, 231, 0, 1, 2)
        self.label_option_donot_indent_func_def_close_paren = QtWidgets.QLabel("donot_indent_func_def_close_paren")
        self.label_option_donot_indent_func_def_close_paren.setFont(font_name)
        self.group_page_layout_3.addWidget(self.label_option_donot_indent_func_def_close_paren, 232, 0)
        self.option_donot_indent_func_def_close_paren =  QtWidgets.QComboBox()
        self.option_donot_indent_func_def_close_paren.addItems(['true','false'])
        self.option_donot_indent_func_def_close_paren.setCurrentText("false")
        self.group_page_layout_3.addWidget(self.option_donot_indent_func_def_close_paren, 232, 1)
        self.group_page_layout_3.addItem(QtWidgets.QSpacerItem(10, 10, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding), 233,0)
        self.scroll_group_page_3 = QtWidgets.QScrollArea()
        self.scroll_group_page_3.setWidget(self.group_page_3)
        self.scroll_group_page_3.setWidgetResizable(True)
        self.addTab(self.scroll_group_page_3, self.tr("Indenting options"))
        #================== Newline adding and removing options =============================================
        self.group_page_4 = QtWidgets.QWidget()
        self.group_page_layout_4 = QtWidgets.QGridLayout(self.group_page_4)
        self.group_page_layout_4.addWidget(QtWidgets.QLabel(label(self.tr("Newline adding and removing options help"))), 0, 0, 1, 2)
        #--------------------------------------------
        self.label_nl_collapse_empty_body = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to collapse empty blocks between '{' and '}' except for functions.\nUse nl_collapse_empty_body_functions to specify how empty function braces\nshould be formatted.", "nl_collapse_empty_body")))
        self.label_nl_collapse_empty_body.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_collapse_empty_body, 1, 0, 1, 2)
        self.label_option_nl_collapse_empty_body = QtWidgets.QLabel("nl_collapse_empty_body")
        self.label_option_nl_collapse_empty_body.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_collapse_empty_body, 2, 0)
        self.option_nl_collapse_empty_body =  QtWidgets.QComboBox()
        self.option_nl_collapse_empty_body.addItems(['true','false'])
        self.option_nl_collapse_empty_body.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_collapse_empty_body, 2, 1)
        #--------------------------------------------
        self.label_nl_collapse_empty_body_functions = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to collapse empty blocks between '{' and '}' for functions only.\nIf true, overrides nl_inside_empty_func.", "nl_collapse_empty_body_functions")))
        self.label_nl_collapse_empty_body_functions.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_collapse_empty_body_functions, 3, 0, 1, 2)
        self.label_option_nl_collapse_empty_body_functions = QtWidgets.QLabel("nl_collapse_empty_body_functions")
        self.label_option_nl_collapse_empty_body_functions.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_collapse_empty_body_functions, 4, 0)
        self.option_nl_collapse_empty_body_functions =  QtWidgets.QComboBox()
        self.option_nl_collapse_empty_body_functions.addItems(['true','false'])
        self.option_nl_collapse_empty_body_functions.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_collapse_empty_body_functions, 4, 1)
        #--------------------------------------------
        self.label_nl_assign_leave_one_liners = QtWidgets.QLabel(label("<hr>"+self.tr("Don't split one-line braced assignments, as in 'foo_t f = { 1, 2 };'.", "nl_assign_leave_one_liners")))
        self.label_nl_assign_leave_one_liners.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_assign_leave_one_liners, 5, 0, 1, 2)
        self.label_option_nl_assign_leave_one_liners = QtWidgets.QLabel("nl_assign_leave_one_liners")
        self.label_option_nl_assign_leave_one_liners.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_assign_leave_one_liners, 6, 0)
        self.option_nl_assign_leave_one_liners =  QtWidgets.QComboBox()
        self.option_nl_assign_leave_one_liners.addItems(['true','false'])
        self.option_nl_assign_leave_one_liners.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_assign_leave_one_liners, 6, 1)
        #--------------------------------------------
        self.label_nl_class_leave_one_liners = QtWidgets.QLabel(label("<hr>"+self.tr("Don't split one-line braced statements inside a 'class xx { }' body.", "nl_class_leave_one_liners")))
        self.label_nl_class_leave_one_liners.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_class_leave_one_liners, 7, 0, 1, 2)
        self.label_option_nl_class_leave_one_liners = QtWidgets.QLabel("nl_class_leave_one_liners")
        self.label_option_nl_class_leave_one_liners.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_class_leave_one_liners, 8, 0)
        self.option_nl_class_leave_one_liners =  QtWidgets.QComboBox()
        self.option_nl_class_leave_one_liners.addItems(['true','false'])
        self.option_nl_class_leave_one_liners.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_class_leave_one_liners, 8, 1)
        #--------------------------------------------
        self.label_nl_enum_leave_one_liners = QtWidgets.QLabel(label("<hr>"+self.tr("Don't split one-line enums, as in 'enum foo { BAR = 15 };'", "nl_enum_leave_one_liners")))
        self.label_nl_enum_leave_one_liners.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_enum_leave_one_liners, 9, 0, 1, 2)
        self.label_option_nl_enum_leave_one_liners = QtWidgets.QLabel("nl_enum_leave_one_liners")
        self.label_option_nl_enum_leave_one_liners.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_enum_leave_one_liners, 10, 0)
        self.option_nl_enum_leave_one_liners =  QtWidgets.QComboBox()
        self.option_nl_enum_leave_one_liners.addItems(['true','false'])
        self.option_nl_enum_leave_one_liners.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_enum_leave_one_liners, 10, 1)
        #--------------------------------------------
        self.label_nl_getset_leave_one_liners = QtWidgets.QLabel(label("<hr>"+self.tr("Don't split one-line get or set functions.", "nl_getset_leave_one_liners")))
        self.label_nl_getset_leave_one_liners.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_getset_leave_one_liners, 11, 0, 1, 2)
        self.label_option_nl_getset_leave_one_liners = QtWidgets.QLabel("nl_getset_leave_one_liners")
        self.label_option_nl_getset_leave_one_liners.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_getset_leave_one_liners, 12, 0)
        self.option_nl_getset_leave_one_liners =  QtWidgets.QComboBox()
        self.option_nl_getset_leave_one_liners.addItems(['true','false'])
        self.option_nl_getset_leave_one_liners.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_getset_leave_one_liners, 12, 1)
        #--------------------------------------------
        self.label_nl_cs_property_leave_one_liners = QtWidgets.QLabel(label("<hr>"+self.tr("(C#) Don't split one-line property get or set functions.", "nl_cs_property_leave_one_liners")))
        self.label_nl_cs_property_leave_one_liners.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_cs_property_leave_one_liners, 13, 0, 1, 2)
        self.label_option_nl_cs_property_leave_one_liners = QtWidgets.QLabel("nl_cs_property_leave_one_liners")
        self.label_option_nl_cs_property_leave_one_liners.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_cs_property_leave_one_liners, 14, 0)
        self.option_nl_cs_property_leave_one_liners =  QtWidgets.QComboBox()
        self.option_nl_cs_property_leave_one_liners.addItems(['true','false'])
        self.option_nl_cs_property_leave_one_liners.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_cs_property_leave_one_liners, 14, 1)
        #--------------------------------------------
        self.label_nl_func_leave_one_liners = QtWidgets.QLabel(label("<hr>"+self.tr("Don't split one-line function definitions, as in 'int foo() { return 0; }'.\nmight modify nl_func_type_name", "nl_func_leave_one_liners")))
        self.label_nl_func_leave_one_liners.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_leave_one_liners, 15, 0, 1, 2)
        self.label_option_nl_func_leave_one_liners = QtWidgets.QLabel("nl_func_leave_one_liners")
        self.label_option_nl_func_leave_one_liners.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_leave_one_liners, 16, 0)
        self.option_nl_func_leave_one_liners =  QtWidgets.QComboBox()
        self.option_nl_func_leave_one_liners.addItems(['true','false'])
        self.option_nl_func_leave_one_liners.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_func_leave_one_liners, 16, 1)
        #--------------------------------------------
        self.label_nl_cpp_lambda_leave_one_liners = QtWidgets.QLabel(label("<hr>"+self.tr("Don't split one-line C++11 lambdas, as in '[]() { return 0; }'.", "nl_cpp_lambda_leave_one_liners")))
        self.label_nl_cpp_lambda_leave_one_liners.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_cpp_lambda_leave_one_liners, 17, 0, 1, 2)
        self.label_option_nl_cpp_lambda_leave_one_liners = QtWidgets.QLabel("nl_cpp_lambda_leave_one_liners")
        self.label_option_nl_cpp_lambda_leave_one_liners.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_cpp_lambda_leave_one_liners, 18, 0)
        self.option_nl_cpp_lambda_leave_one_liners =  QtWidgets.QComboBox()
        self.option_nl_cpp_lambda_leave_one_liners.addItems(['true','false'])
        self.option_nl_cpp_lambda_leave_one_liners.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_cpp_lambda_leave_one_liners, 18, 1)
        #--------------------------------------------
        self.label_nl_if_leave_one_liners = QtWidgets.QLabel(label("<hr>"+self.tr("Don't split one-line if/else statements, as in 'if(...) b++;'.", "nl_if_leave_one_liners")))
        self.label_nl_if_leave_one_liners.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_if_leave_one_liners, 19, 0, 1, 2)
        self.label_option_nl_if_leave_one_liners = QtWidgets.QLabel("nl_if_leave_one_liners")
        self.label_option_nl_if_leave_one_liners.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_if_leave_one_liners, 20, 0)
        self.option_nl_if_leave_one_liners =  QtWidgets.QComboBox()
        self.option_nl_if_leave_one_liners.addItems(['true','false'])
        self.option_nl_if_leave_one_liners.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_if_leave_one_liners, 20, 1)
        #--------------------------------------------
        self.label_nl_while_leave_one_liners = QtWidgets.QLabel(label("<hr>"+self.tr("Don't split one-line while statements, as in 'while(...) b++;'.", "nl_while_leave_one_liners")))
        self.label_nl_while_leave_one_liners.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_while_leave_one_liners, 21, 0, 1, 2)
        self.label_option_nl_while_leave_one_liners = QtWidgets.QLabel("nl_while_leave_one_liners")
        self.label_option_nl_while_leave_one_liners.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_while_leave_one_liners, 22, 0)
        self.option_nl_while_leave_one_liners =  QtWidgets.QComboBox()
        self.option_nl_while_leave_one_liners.addItems(['true','false'])
        self.option_nl_while_leave_one_liners.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_while_leave_one_liners, 22, 1)
        #--------------------------------------------
        self.label_nl_do_leave_one_liners = QtWidgets.QLabel(label("<hr>"+self.tr("Don't split one-line do statements, as in 'do { b++; } while(...);'.", "nl_do_leave_one_liners")))
        self.label_nl_do_leave_one_liners.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_do_leave_one_liners, 23, 0, 1, 2)
        self.label_option_nl_do_leave_one_liners = QtWidgets.QLabel("nl_do_leave_one_liners")
        self.label_option_nl_do_leave_one_liners.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_do_leave_one_liners, 24, 0)
        self.option_nl_do_leave_one_liners =  QtWidgets.QComboBox()
        self.option_nl_do_leave_one_liners.addItems(['true','false'])
        self.option_nl_do_leave_one_liners.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_do_leave_one_liners, 24, 1)
        #--------------------------------------------
        self.label_nl_for_leave_one_liners = QtWidgets.QLabel(label("<hr>"+self.tr("Don't split one-line for statements, as in 'for(...) b++;'.", "nl_for_leave_one_liners")))
        self.label_nl_for_leave_one_liners.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_for_leave_one_liners, 25, 0, 1, 2)
        self.label_option_nl_for_leave_one_liners = QtWidgets.QLabel("nl_for_leave_one_liners")
        self.label_option_nl_for_leave_one_liners.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_for_leave_one_liners, 26, 0)
        self.option_nl_for_leave_one_liners =  QtWidgets.QComboBox()
        self.option_nl_for_leave_one_liners.addItems(['true','false'])
        self.option_nl_for_leave_one_liners.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_for_leave_one_liners, 26, 1)
        #--------------------------------------------
        self.label_nl_oc_msg_leave_one_liner = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Don't split one-line Objective-C messages.", "nl_oc_msg_leave_one_liner")))
        self.label_nl_oc_msg_leave_one_liner.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_oc_msg_leave_one_liner, 27, 0, 1, 2)
        self.label_option_nl_oc_msg_leave_one_liner = QtWidgets.QLabel("nl_oc_msg_leave_one_liner")
        self.label_option_nl_oc_msg_leave_one_liner.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_oc_msg_leave_one_liner, 28, 0)
        self.option_nl_oc_msg_leave_one_liner =  QtWidgets.QComboBox()
        self.option_nl_oc_msg_leave_one_liner.addItems(['true','false'])
        self.option_nl_oc_msg_leave_one_liner.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_oc_msg_leave_one_liner, 28, 1)
        #--------------------------------------------
        self.label_nl_oc_mdef_brace = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove newline between method declaration and '{'.", "nl_oc_mdef_brace")))
        self.label_nl_oc_mdef_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_oc_mdef_brace, 29, 0, 1, 2)
        self.label_option_nl_oc_mdef_brace = QtWidgets.QLabel("nl_oc_mdef_brace")
        self.label_option_nl_oc_mdef_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_oc_mdef_brace, 30, 0)
        self.option_nl_oc_mdef_brace =  QtWidgets.QComboBox()
        self.option_nl_oc_mdef_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_oc_mdef_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_oc_mdef_brace, 30, 1)
        #--------------------------------------------
        self.label_nl_oc_block_brace = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove newline between Objective-C block signature and '{'.", "nl_oc_block_brace")))
        self.label_nl_oc_block_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_oc_block_brace, 31, 0, 1, 2)
        self.label_option_nl_oc_block_brace = QtWidgets.QLabel("nl_oc_block_brace")
        self.label_option_nl_oc_block_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_oc_block_brace, 32, 0)
        self.option_nl_oc_block_brace =  QtWidgets.QComboBox()
        self.option_nl_oc_block_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_oc_block_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_oc_block_brace, 32, 1)
        #--------------------------------------------
        self.label_nl_oc_before_interface = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove blank line before '@interface' statement.", "nl_oc_before_interface")))
        self.label_nl_oc_before_interface.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_oc_before_interface, 33, 0, 1, 2)
        self.label_option_nl_oc_before_interface = QtWidgets.QLabel("nl_oc_before_interface")
        self.label_option_nl_oc_before_interface.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_oc_before_interface, 34, 0)
        self.option_nl_oc_before_interface =  QtWidgets.QComboBox()
        self.option_nl_oc_before_interface.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_oc_before_interface.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_oc_before_interface, 34, 1)
        #--------------------------------------------
        self.label_nl_oc_before_implementation = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove blank line before '@implementation' statement.", "nl_oc_before_implementation")))
        self.label_nl_oc_before_implementation.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_oc_before_implementation, 35, 0, 1, 2)
        self.label_option_nl_oc_before_implementation = QtWidgets.QLabel("nl_oc_before_implementation")
        self.label_option_nl_oc_before_implementation.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_oc_before_implementation, 36, 0)
        self.option_nl_oc_before_implementation =  QtWidgets.QComboBox()
        self.option_nl_oc_before_implementation.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_oc_before_implementation.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_oc_before_implementation, 36, 1)
        #--------------------------------------------
        self.label_nl_oc_before_end = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove blank line before '@end' statement.", "nl_oc_before_end")))
        self.label_nl_oc_before_end.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_oc_before_end, 37, 0, 1, 2)
        self.label_option_nl_oc_before_end = QtWidgets.QLabel("nl_oc_before_end")
        self.label_option_nl_oc_before_end.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_oc_before_end, 38, 0)
        self.option_nl_oc_before_end =  QtWidgets.QComboBox()
        self.option_nl_oc_before_end.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_oc_before_end.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_oc_before_end, 38, 1)
        #--------------------------------------------
        self.label_nl_oc_interface_brace = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove newline between '@interface' and '{'.", "nl_oc_interface_brace")))
        self.label_nl_oc_interface_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_oc_interface_brace, 39, 0, 1, 2)
        self.label_option_nl_oc_interface_brace = QtWidgets.QLabel("nl_oc_interface_brace")
        self.label_option_nl_oc_interface_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_oc_interface_brace, 40, 0)
        self.option_nl_oc_interface_brace =  QtWidgets.QComboBox()
        self.option_nl_oc_interface_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_oc_interface_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_oc_interface_brace, 40, 1)
        #--------------------------------------------
        self.label_nl_oc_implementation_brace = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove newline between '@implementation' and '{'.", "nl_oc_implementation_brace")))
        self.label_nl_oc_implementation_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_oc_implementation_brace, 41, 0, 1, 2)
        self.label_option_nl_oc_implementation_brace = QtWidgets.QLabel("nl_oc_implementation_brace")
        self.label_option_nl_oc_implementation_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_oc_implementation_brace, 42, 0)
        self.option_nl_oc_implementation_brace =  QtWidgets.QComboBox()
        self.option_nl_oc_implementation_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_oc_implementation_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_oc_implementation_brace, 42, 1)
        #--------------------------------------------
        self.label_nl_start_of_file = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newlines at the start of the file.", "nl_start_of_file")))
        self.label_nl_start_of_file.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_start_of_file, 43, 0, 1, 2)
        self.label_option_nl_start_of_file = QtWidgets.QLabel("nl_start_of_file")
        self.label_option_nl_start_of_file.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_start_of_file, 44, 0)
        self.option_nl_start_of_file =  QtWidgets.QComboBox()
        self.option_nl_start_of_file.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_start_of_file.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_start_of_file, 44, 1)
        #--------------------------------------------
        self.label_nl_start_of_file_min = QtWidgets.QLabel(label("<hr>"+self.tr("The minimum number of newlines at the start of the file (only used if\nnl_start_of_file is 'add' or 'force').", "nl_start_of_file_min")))
        self.label_nl_start_of_file_min.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_start_of_file_min, 45, 0, 1, 2)
        self.label_option_nl_start_of_file_min = QtWidgets.QLabel("nl_start_of_file_min")
        self.label_option_nl_start_of_file_min.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_start_of_file_min, 46, 0)
        self.option_nl_start_of_file_min =  QtWidgets.QSpinBox()
        self.option_nl_start_of_file_min.setMinimum( 0)
        self.option_nl_start_of_file_min.setMaximum( 16)
        self.option_nl_start_of_file_min.setValue(0)
        self.group_page_layout_4.addWidget(self.option_nl_start_of_file_min, 46, 1)
        #--------------------------------------------
        self.label_nl_end_of_file = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline at the end of the file.", "nl_end_of_file")))
        self.label_nl_end_of_file.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_end_of_file, 47, 0, 1, 2)
        self.label_option_nl_end_of_file = QtWidgets.QLabel("nl_end_of_file")
        self.label_option_nl_end_of_file.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_end_of_file, 48, 0)
        self.option_nl_end_of_file =  QtWidgets.QComboBox()
        self.option_nl_end_of_file.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_end_of_file.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_end_of_file, 48, 1)
        #--------------------------------------------
        self.label_nl_end_of_file_min = QtWidgets.QLabel(label("<hr>"+self.tr("The minimum number of newlines at the end of the file (only used if\nnl_end_of_file is 'add' or 'force').", "nl_end_of_file_min")))
        self.label_nl_end_of_file_min.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_end_of_file_min, 49, 0, 1, 2)
        self.label_option_nl_end_of_file_min = QtWidgets.QLabel("nl_end_of_file_min")
        self.label_option_nl_end_of_file_min.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_end_of_file_min, 50, 0)
        self.option_nl_end_of_file_min =  QtWidgets.QSpinBox()
        self.option_nl_end_of_file_min.setMinimum( 0)
        self.option_nl_end_of_file_min.setMaximum( 16)
        self.option_nl_end_of_file_min.setValue(0)
        self.group_page_layout_4.addWidget(self.option_nl_end_of_file_min, 50, 1)
        #--------------------------------------------
        self.label_nl_assign_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between '=' and '{'.", "nl_assign_brace")))
        self.label_nl_assign_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_assign_brace, 51, 0, 1, 2)
        self.label_option_nl_assign_brace = QtWidgets.QLabel("nl_assign_brace")
        self.label_option_nl_assign_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_assign_brace, 52, 0)
        self.option_nl_assign_brace =  QtWidgets.QComboBox()
        self.option_nl_assign_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_assign_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_assign_brace, 52, 1)
        #--------------------------------------------
        self.label_nl_assign_square = QtWidgets.QLabel(label("<hr>"+self.tr("(D) Add or remove newline between '=' and '['.", "nl_assign_square")))
        self.label_nl_assign_square.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_assign_square, 53, 0, 1, 2)
        self.label_option_nl_assign_square = QtWidgets.QLabel("nl_assign_square")
        self.label_option_nl_assign_square.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_assign_square, 54, 0)
        self.option_nl_assign_square =  QtWidgets.QComboBox()
        self.option_nl_assign_square.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_assign_square.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_assign_square, 54, 1)
        #--------------------------------------------
        self.label_nl_tsquare_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between '[]' and '{'.", "nl_tsquare_brace")))
        self.label_nl_tsquare_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_tsquare_brace, 55, 0, 1, 2)
        self.label_option_nl_tsquare_brace = QtWidgets.QLabel("nl_tsquare_brace")
        self.label_option_nl_tsquare_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_tsquare_brace, 56, 0)
        self.option_nl_tsquare_brace =  QtWidgets.QComboBox()
        self.option_nl_tsquare_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_tsquare_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_tsquare_brace, 56, 1)
        #--------------------------------------------
        self.label_nl_after_square_assign = QtWidgets.QLabel(label("<hr>"+self.tr("(D) Add or remove newline after '= ['. Will also affect the newline before\nthe ']'.", "nl_after_square_assign")))
        self.label_nl_after_square_assign.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_after_square_assign, 57, 0, 1, 2)
        self.label_option_nl_after_square_assign = QtWidgets.QLabel("nl_after_square_assign")
        self.label_option_nl_after_square_assign.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_after_square_assign, 58, 0)
        self.option_nl_after_square_assign =  QtWidgets.QComboBox()
        self.option_nl_after_square_assign.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_after_square_assign.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_after_square_assign, 58, 1)
        #--------------------------------------------
        self.label_nl_fcall_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between a function call's ')' and '{', as in\n'list_for_each(item, &list) { }'.", "nl_fcall_brace")))
        self.label_nl_fcall_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_fcall_brace, 59, 0, 1, 2)
        self.label_option_nl_fcall_brace = QtWidgets.QLabel("nl_fcall_brace")
        self.label_option_nl_fcall_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_fcall_brace, 60, 0)
        self.option_nl_fcall_brace =  QtWidgets.QComboBox()
        self.option_nl_fcall_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_fcall_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_fcall_brace, 60, 1)
        #--------------------------------------------
        self.label_nl_enum_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'enum' and '{'.", "nl_enum_brace")))
        self.label_nl_enum_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_enum_brace, 61, 0, 1, 2)
        self.label_option_nl_enum_brace = QtWidgets.QLabel("nl_enum_brace")
        self.label_option_nl_enum_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_enum_brace, 62, 0)
        self.option_nl_enum_brace =  QtWidgets.QComboBox()
        self.option_nl_enum_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_enum_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_enum_brace, 62, 1)
        #--------------------------------------------
        self.label_nl_enum_class = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'enum' and 'class'.", "nl_enum_class")))
        self.label_nl_enum_class.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_enum_class, 63, 0, 1, 2)
        self.label_option_nl_enum_class = QtWidgets.QLabel("nl_enum_class")
        self.label_option_nl_enum_class.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_enum_class, 64, 0)
        self.option_nl_enum_class =  QtWidgets.QComboBox()
        self.option_nl_enum_class.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_enum_class.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_enum_class, 64, 1)
        #--------------------------------------------
        self.label_nl_enum_class_identifier = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'enum class' and the identifier.", "nl_enum_class_identifier")))
        self.label_nl_enum_class_identifier.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_enum_class_identifier, 65, 0, 1, 2)
        self.label_option_nl_enum_class_identifier = QtWidgets.QLabel("nl_enum_class_identifier")
        self.label_option_nl_enum_class_identifier.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_enum_class_identifier, 66, 0)
        self.option_nl_enum_class_identifier =  QtWidgets.QComboBox()
        self.option_nl_enum_class_identifier.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_enum_class_identifier.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_enum_class_identifier, 66, 1)
        #--------------------------------------------
        self.label_nl_enum_identifier_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'enum class' type and ':'.", "nl_enum_identifier_colon")))
        self.label_nl_enum_identifier_colon.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_enum_identifier_colon, 67, 0, 1, 2)
        self.label_option_nl_enum_identifier_colon = QtWidgets.QLabel("nl_enum_identifier_colon")
        self.label_option_nl_enum_identifier_colon.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_enum_identifier_colon, 68, 0)
        self.option_nl_enum_identifier_colon =  QtWidgets.QComboBox()
        self.option_nl_enum_identifier_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_enum_identifier_colon.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_enum_identifier_colon, 68, 1)
        #--------------------------------------------
        self.label_nl_enum_colon_type = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'enum class identifier :' and type.", "nl_enum_colon_type")))
        self.label_nl_enum_colon_type.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_enum_colon_type, 69, 0, 1, 2)
        self.label_option_nl_enum_colon_type = QtWidgets.QLabel("nl_enum_colon_type")
        self.label_option_nl_enum_colon_type.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_enum_colon_type, 70, 0)
        self.option_nl_enum_colon_type =  QtWidgets.QComboBox()
        self.option_nl_enum_colon_type.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_enum_colon_type.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_enum_colon_type, 70, 1)
        #--------------------------------------------
        self.label_nl_struct_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'struct and '{'.", "nl_struct_brace")))
        self.label_nl_struct_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_struct_brace, 71, 0, 1, 2)
        self.label_option_nl_struct_brace = QtWidgets.QLabel("nl_struct_brace")
        self.label_option_nl_struct_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_struct_brace, 72, 0)
        self.option_nl_struct_brace =  QtWidgets.QComboBox()
        self.option_nl_struct_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_struct_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_struct_brace, 72, 1)
        #--------------------------------------------
        self.label_nl_union_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'union' and '{'.", "nl_union_brace")))
        self.label_nl_union_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_union_brace, 73, 0, 1, 2)
        self.label_option_nl_union_brace = QtWidgets.QLabel("nl_union_brace")
        self.label_option_nl_union_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_union_brace, 74, 0)
        self.option_nl_union_brace =  QtWidgets.QComboBox()
        self.option_nl_union_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_union_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_union_brace, 74, 1)
        #--------------------------------------------
        self.label_nl_if_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'if' and '{'.", "nl_if_brace")))
        self.label_nl_if_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_if_brace, 75, 0, 1, 2)
        self.label_option_nl_if_brace = QtWidgets.QLabel("nl_if_brace")
        self.label_option_nl_if_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_if_brace, 76, 0)
        self.option_nl_if_brace =  QtWidgets.QComboBox()
        self.option_nl_if_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_if_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_if_brace, 76, 1)
        #--------------------------------------------
        self.label_nl_brace_else = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between '}' and 'else'.", "nl_brace_else")))
        self.label_nl_brace_else.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_brace_else, 77, 0, 1, 2)
        self.label_option_nl_brace_else = QtWidgets.QLabel("nl_brace_else")
        self.label_option_nl_brace_else.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_brace_else, 78, 0)
        self.option_nl_brace_else =  QtWidgets.QComboBox()
        self.option_nl_brace_else.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_brace_else.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_brace_else, 78, 1)
        #--------------------------------------------
        self.label_nl_elseif_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'else if' and '{'. If set to ignore,\nnl_if_brace is used instead.", "nl_elseif_brace")))
        self.label_nl_elseif_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_elseif_brace, 79, 0, 1, 2)
        self.label_option_nl_elseif_brace = QtWidgets.QLabel("nl_elseif_brace")
        self.label_option_nl_elseif_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_elseif_brace, 80, 0)
        self.option_nl_elseif_brace =  QtWidgets.QComboBox()
        self.option_nl_elseif_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_elseif_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_elseif_brace, 80, 1)
        #--------------------------------------------
        self.label_nl_else_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'else' and '{'.", "nl_else_brace")))
        self.label_nl_else_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_else_brace, 81, 0, 1, 2)
        self.label_option_nl_else_brace = QtWidgets.QLabel("nl_else_brace")
        self.label_option_nl_else_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_else_brace, 82, 0)
        self.option_nl_else_brace =  QtWidgets.QComboBox()
        self.option_nl_else_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_else_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_else_brace, 82, 1)
        #--------------------------------------------
        self.label_nl_else_if = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'else' and 'if'.", "nl_else_if")))
        self.label_nl_else_if.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_else_if, 83, 0, 1, 2)
        self.label_option_nl_else_if = QtWidgets.QLabel("nl_else_if")
        self.label_option_nl_else_if.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_else_if, 84, 0)
        self.option_nl_else_if =  QtWidgets.QComboBox()
        self.option_nl_else_if.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_else_if.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_else_if, 84, 1)
        #--------------------------------------------
        self.label_nl_before_opening_brace_func_class_def = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline before '{' opening brace", "nl_before_opening_brace_func_class_def")))
        self.label_nl_before_opening_brace_func_class_def.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_before_opening_brace_func_class_def, 85, 0, 1, 2)
        self.label_option_nl_before_opening_brace_func_class_def = QtWidgets.QLabel("nl_before_opening_brace_func_class_def")
        self.label_option_nl_before_opening_brace_func_class_def.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_before_opening_brace_func_class_def, 86, 0)
        self.option_nl_before_opening_brace_func_class_def =  QtWidgets.QComboBox()
        self.option_nl_before_opening_brace_func_class_def.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_before_opening_brace_func_class_def.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_before_opening_brace_func_class_def, 86, 1)
        #--------------------------------------------
        self.label_nl_before_if_closing_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline before 'if'/'else if' closing parenthesis.", "nl_before_if_closing_paren")))
        self.label_nl_before_if_closing_paren.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_before_if_closing_paren, 87, 0, 1, 2)
        self.label_option_nl_before_if_closing_paren = QtWidgets.QLabel("nl_before_if_closing_paren")
        self.label_option_nl_before_if_closing_paren.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_before_if_closing_paren, 88, 0)
        self.option_nl_before_if_closing_paren =  QtWidgets.QComboBox()
        self.option_nl_before_if_closing_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_before_if_closing_paren.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_before_if_closing_paren, 88, 1)
        #--------------------------------------------
        self.label_nl_brace_finally = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between '}' and 'finally'.", "nl_brace_finally")))
        self.label_nl_brace_finally.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_brace_finally, 89, 0, 1, 2)
        self.label_option_nl_brace_finally = QtWidgets.QLabel("nl_brace_finally")
        self.label_option_nl_brace_finally.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_brace_finally, 90, 0)
        self.option_nl_brace_finally =  QtWidgets.QComboBox()
        self.option_nl_brace_finally.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_brace_finally.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_brace_finally, 90, 1)
        #--------------------------------------------
        self.label_nl_finally_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'finally' and '{'.", "nl_finally_brace")))
        self.label_nl_finally_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_finally_brace, 91, 0, 1, 2)
        self.label_option_nl_finally_brace = QtWidgets.QLabel("nl_finally_brace")
        self.label_option_nl_finally_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_finally_brace, 92, 0)
        self.option_nl_finally_brace =  QtWidgets.QComboBox()
        self.option_nl_finally_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_finally_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_finally_brace, 92, 1)
        #--------------------------------------------
        self.label_nl_try_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'try' and '{'.", "nl_try_brace")))
        self.label_nl_try_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_try_brace, 93, 0, 1, 2)
        self.label_option_nl_try_brace = QtWidgets.QLabel("nl_try_brace")
        self.label_option_nl_try_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_try_brace, 94, 0)
        self.option_nl_try_brace =  QtWidgets.QComboBox()
        self.option_nl_try_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_try_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_try_brace, 94, 1)
        #--------------------------------------------
        self.label_nl_getset_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between get/set and '{'.", "nl_getset_brace")))
        self.label_nl_getset_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_getset_brace, 95, 0, 1, 2)
        self.label_option_nl_getset_brace = QtWidgets.QLabel("nl_getset_brace")
        self.label_option_nl_getset_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_getset_brace, 96, 0)
        self.option_nl_getset_brace =  QtWidgets.QComboBox()
        self.option_nl_getset_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_getset_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_getset_brace, 96, 1)
        #--------------------------------------------
        self.label_nl_for_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'for' and '{'.", "nl_for_brace")))
        self.label_nl_for_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_for_brace, 97, 0, 1, 2)
        self.label_option_nl_for_brace = QtWidgets.QLabel("nl_for_brace")
        self.label_option_nl_for_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_for_brace, 98, 0)
        self.option_nl_for_brace =  QtWidgets.QComboBox()
        self.option_nl_for_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_for_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_for_brace, 98, 1)
        #--------------------------------------------
        self.label_nl_catch_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline before the '{' of a 'catch' statement, as in\n'catch (decl) <here> {'.", "nl_catch_brace")))
        self.label_nl_catch_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_catch_brace, 99, 0, 1, 2)
        self.label_option_nl_catch_brace = QtWidgets.QLabel("nl_catch_brace")
        self.label_option_nl_catch_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_catch_brace, 100, 0)
        self.option_nl_catch_brace =  QtWidgets.QComboBox()
        self.option_nl_catch_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_catch_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_catch_brace, 100, 1)
        #--------------------------------------------
        self.label_nl_oc_catch_brace = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove newline before the '{' of a '@catch' statement, as in\n'@catch (decl) <here> {'. If set to ignore, nl_catch_brace is used.", "nl_oc_catch_brace")))
        self.label_nl_oc_catch_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_oc_catch_brace, 101, 0, 1, 2)
        self.label_option_nl_oc_catch_brace = QtWidgets.QLabel("nl_oc_catch_brace")
        self.label_option_nl_oc_catch_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_oc_catch_brace, 102, 0)
        self.option_nl_oc_catch_brace =  QtWidgets.QComboBox()
        self.option_nl_oc_catch_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_oc_catch_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_oc_catch_brace, 102, 1)
        #--------------------------------------------
        self.label_nl_brace_catch = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between '}' and 'catch'.", "nl_brace_catch")))
        self.label_nl_brace_catch.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_brace_catch, 103, 0, 1, 2)
        self.label_option_nl_brace_catch = QtWidgets.QLabel("nl_brace_catch")
        self.label_option_nl_brace_catch.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_brace_catch, 104, 0)
        self.option_nl_brace_catch =  QtWidgets.QComboBox()
        self.option_nl_brace_catch.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_brace_catch.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_brace_catch, 104, 1)
        #--------------------------------------------
        self.label_nl_oc_brace_catch = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Add or remove newline between '}' and '@catch'. If set to ignore,\nnl_brace_catch is used.", "nl_oc_brace_catch")))
        self.label_nl_oc_brace_catch.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_oc_brace_catch, 105, 0, 1, 2)
        self.label_option_nl_oc_brace_catch = QtWidgets.QLabel("nl_oc_brace_catch")
        self.label_option_nl_oc_brace_catch.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_oc_brace_catch, 106, 0)
        self.option_nl_oc_brace_catch =  QtWidgets.QComboBox()
        self.option_nl_oc_brace_catch.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_oc_brace_catch.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_oc_brace_catch, 106, 1)
        #--------------------------------------------
        self.label_nl_brace_square = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between '}' and ']'.", "nl_brace_square")))
        self.label_nl_brace_square.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_brace_square, 107, 0, 1, 2)
        self.label_option_nl_brace_square = QtWidgets.QLabel("nl_brace_square")
        self.label_option_nl_brace_square.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_brace_square, 108, 0)
        self.option_nl_brace_square =  QtWidgets.QComboBox()
        self.option_nl_brace_square.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_brace_square.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_brace_square, 108, 1)
        #--------------------------------------------
        self.label_nl_brace_fparen = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between '}' and ')' in a function invocation.", "nl_brace_fparen")))
        self.label_nl_brace_fparen.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_brace_fparen, 109, 0, 1, 2)
        self.label_option_nl_brace_fparen = QtWidgets.QLabel("nl_brace_fparen")
        self.label_option_nl_brace_fparen.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_brace_fparen, 110, 0)
        self.option_nl_brace_fparen =  QtWidgets.QComboBox()
        self.option_nl_brace_fparen.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_brace_fparen.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_brace_fparen, 110, 1)
        #--------------------------------------------
        self.label_nl_while_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'while' and '{'.", "nl_while_brace")))
        self.label_nl_while_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_while_brace, 111, 0, 1, 2)
        self.label_option_nl_while_brace = QtWidgets.QLabel("nl_while_brace")
        self.label_option_nl_while_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_while_brace, 112, 0)
        self.option_nl_while_brace =  QtWidgets.QComboBox()
        self.option_nl_while_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_while_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_while_brace, 112, 1)
        #--------------------------------------------
        self.label_nl_scope_brace = QtWidgets.QLabel(label("<hr>"+self.tr("(D) Add or remove newline between 'scope (x)' and '{'.", "nl_scope_brace")))
        self.label_nl_scope_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_scope_brace, 113, 0, 1, 2)
        self.label_option_nl_scope_brace = QtWidgets.QLabel("nl_scope_brace")
        self.label_option_nl_scope_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_scope_brace, 114, 0)
        self.option_nl_scope_brace =  QtWidgets.QComboBox()
        self.option_nl_scope_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_scope_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_scope_brace, 114, 1)
        #--------------------------------------------
        self.label_nl_unittest_brace = QtWidgets.QLabel(label("<hr>"+self.tr("(D) Add or remove newline between 'unittest' and '{'.", "nl_unittest_brace")))
        self.label_nl_unittest_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_unittest_brace, 115, 0, 1, 2)
        self.label_option_nl_unittest_brace = QtWidgets.QLabel("nl_unittest_brace")
        self.label_option_nl_unittest_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_unittest_brace, 116, 0)
        self.option_nl_unittest_brace =  QtWidgets.QComboBox()
        self.option_nl_unittest_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_unittest_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_unittest_brace, 116, 1)
        #--------------------------------------------
        self.label_nl_version_brace = QtWidgets.QLabel(label("<hr>"+self.tr("(D) Add or remove newline between 'version (x)' and '{'.", "nl_version_brace")))
        self.label_nl_version_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_version_brace, 117, 0, 1, 2)
        self.label_option_nl_version_brace = QtWidgets.QLabel("nl_version_brace")
        self.label_option_nl_version_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_version_brace, 118, 0)
        self.option_nl_version_brace =  QtWidgets.QComboBox()
        self.option_nl_version_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_version_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_version_brace, 118, 1)
        #--------------------------------------------
        self.label_nl_using_brace = QtWidgets.QLabel(label("<hr>"+self.tr("(C#) Add or remove newline between 'using' and '{'.", "nl_using_brace")))
        self.label_nl_using_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_using_brace, 119, 0, 1, 2)
        self.label_option_nl_using_brace = QtWidgets.QLabel("nl_using_brace")
        self.label_option_nl_using_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_using_brace, 120, 0)
        self.option_nl_using_brace =  QtWidgets.QComboBox()
        self.option_nl_using_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_using_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_using_brace, 120, 1)
        #--------------------------------------------
        self.label_nl_brace_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between two open or close braces. Due to general\nnewline/brace handling, REMOVE may not work.", "nl_brace_brace")))
        self.label_nl_brace_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_brace_brace, 121, 0, 1, 2)
        self.label_option_nl_brace_brace = QtWidgets.QLabel("nl_brace_brace")
        self.label_option_nl_brace_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_brace_brace, 122, 0)
        self.option_nl_brace_brace =  QtWidgets.QComboBox()
        self.option_nl_brace_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_brace_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_brace_brace, 122, 1)
        #--------------------------------------------
        self.label_nl_do_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'do' and '{'.", "nl_do_brace")))
        self.label_nl_do_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_do_brace, 123, 0, 1, 2)
        self.label_option_nl_do_brace = QtWidgets.QLabel("nl_do_brace")
        self.label_option_nl_do_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_do_brace, 124, 0)
        self.option_nl_do_brace =  QtWidgets.QComboBox()
        self.option_nl_do_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_do_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_do_brace, 124, 1)
        #--------------------------------------------
        self.label_nl_brace_while = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between '}' and 'while' of 'do' statement.", "nl_brace_while")))
        self.label_nl_brace_while.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_brace_while, 125, 0, 1, 2)
        self.label_option_nl_brace_while = QtWidgets.QLabel("nl_brace_while")
        self.label_option_nl_brace_while.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_brace_while, 126, 0)
        self.option_nl_brace_while =  QtWidgets.QComboBox()
        self.option_nl_brace_while.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_brace_while.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_brace_while, 126, 1)
        #--------------------------------------------
        self.label_nl_switch_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'switch' and '{'.", "nl_switch_brace")))
        self.label_nl_switch_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_switch_brace, 127, 0, 1, 2)
        self.label_option_nl_switch_brace = QtWidgets.QLabel("nl_switch_brace")
        self.label_option_nl_switch_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_switch_brace, 128, 0)
        self.option_nl_switch_brace =  QtWidgets.QComboBox()
        self.option_nl_switch_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_switch_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_switch_brace, 128, 1)
        #--------------------------------------------
        self.label_nl_synchronized_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'synchronized' and '{'.", "nl_synchronized_brace")))
        self.label_nl_synchronized_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_synchronized_brace, 129, 0, 1, 2)
        self.label_option_nl_synchronized_brace = QtWidgets.QLabel("nl_synchronized_brace")
        self.label_option_nl_synchronized_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_synchronized_brace, 130, 0)
        self.option_nl_synchronized_brace =  QtWidgets.QComboBox()
        self.option_nl_synchronized_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_synchronized_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_synchronized_brace, 130, 1)
        #--------------------------------------------
        self.label_nl_multi_line_cond = QtWidgets.QLabel(label("<hr>"+self.tr("Add a newline between ')' and '{' if the ')' is on a different line than the\nif/for/etc.", "nl_multi_line_cond")+"\n\n"+self.tr("Overrides nl_for_brace, nl_if_brace, nl_switch_brace, nl_while_switch and\nnl_catch_brace.", "nl_multi_line_cond")))
        self.label_nl_multi_line_cond.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_multi_line_cond, 131, 0, 1, 2)
        self.label_option_nl_multi_line_cond = QtWidgets.QLabel("nl_multi_line_cond")
        self.label_option_nl_multi_line_cond.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_multi_line_cond, 132, 0)
        self.option_nl_multi_line_cond =  QtWidgets.QComboBox()
        self.option_nl_multi_line_cond.addItems(['true','false'])
        self.option_nl_multi_line_cond.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_multi_line_cond, 132, 1)
        #--------------------------------------------
        self.label_nl_multi_line_sparen_open = QtWidgets.QLabel(label("<hr>"+self.tr("Add a newline after '(' if an if/for/while/switch condition spans multiple\nlines", "nl_multi_line_sparen_open")))
        self.label_nl_multi_line_sparen_open.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_multi_line_sparen_open, 133, 0, 1, 2)
        self.label_option_nl_multi_line_sparen_open = QtWidgets.QLabel("nl_multi_line_sparen_open")
        self.label_option_nl_multi_line_sparen_open.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_multi_line_sparen_open, 134, 0)
        self.option_nl_multi_line_sparen_open =  QtWidgets.QComboBox()
        self.option_nl_multi_line_sparen_open.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_multi_line_sparen_open.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_multi_line_sparen_open, 134, 1)
        #--------------------------------------------
        self.label_nl_multi_line_sparen_close = QtWidgets.QLabel(label("<hr>"+self.tr("Add a newline before ')' if an if/for/while/switch condition spans multiple\nlines. Overrides nl_before_if_closing_paren if both are specified.", "nl_multi_line_sparen_close")))
        self.label_nl_multi_line_sparen_close.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_multi_line_sparen_close, 135, 0, 1, 2)
        self.label_option_nl_multi_line_sparen_close = QtWidgets.QLabel("nl_multi_line_sparen_close")
        self.label_option_nl_multi_line_sparen_close.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_multi_line_sparen_close, 136, 0)
        self.option_nl_multi_line_sparen_close =  QtWidgets.QComboBox()
        self.option_nl_multi_line_sparen_close.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_multi_line_sparen_close.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_multi_line_sparen_close, 136, 1)
        #--------------------------------------------
        self.label_nl_multi_line_define = QtWidgets.QLabel(label("<hr>"+self.tr("Force a newline in a define after the macro name for multi-line defines.", "nl_multi_line_define")))
        self.label_nl_multi_line_define.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_multi_line_define, 137, 0, 1, 2)
        self.label_option_nl_multi_line_define = QtWidgets.QLabel("nl_multi_line_define")
        self.label_option_nl_multi_line_define.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_multi_line_define, 138, 0)
        self.option_nl_multi_line_define =  QtWidgets.QComboBox()
        self.option_nl_multi_line_define.addItems(['true','false'])
        self.option_nl_multi_line_define.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_multi_line_define, 138, 1)
        #--------------------------------------------
        self.label_nl_before_case = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline before 'case', and a blank line before a 'case'\nstatement that follows a ';' or '}'.", "nl_before_case")))
        self.label_nl_before_case.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_before_case, 139, 0, 1, 2)
        self.label_option_nl_before_case = QtWidgets.QLabel("nl_before_case")
        self.label_option_nl_before_case.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_before_case, 140, 0)
        self.option_nl_before_case =  QtWidgets.QComboBox()
        self.option_nl_before_case.addItems(['true','false'])
        self.option_nl_before_case.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_before_case, 140, 1)
        #--------------------------------------------
        self.label_nl_after_case = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline after a 'case' statement.", "nl_after_case")))
        self.label_nl_after_case.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_after_case, 141, 0, 1, 2)
        self.label_option_nl_after_case = QtWidgets.QLabel("nl_after_case")
        self.label_option_nl_after_case.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_after_case, 142, 0)
        self.option_nl_after_case =  QtWidgets.QComboBox()
        self.option_nl_after_case.addItems(['true','false'])
        self.option_nl_after_case.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_after_case, 142, 1)
        #--------------------------------------------
        self.label_nl_case_colon_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between a case ':' and '{'.", "nl_case_colon_brace")+"\n\n"+self.tr("Overrides nl_after_case.", "nl_case_colon_brace")))
        self.label_nl_case_colon_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_case_colon_brace, 143, 0, 1, 2)
        self.label_option_nl_case_colon_brace = QtWidgets.QLabel("nl_case_colon_brace")
        self.label_option_nl_case_colon_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_case_colon_brace, 144, 0)
        self.option_nl_case_colon_brace =  QtWidgets.QComboBox()
        self.option_nl_case_colon_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_case_colon_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_case_colon_brace, 144, 1)
        #--------------------------------------------
        self.label_nl_before_throw = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between ')' and 'throw'.", "nl_before_throw")))
        self.label_nl_before_throw.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_before_throw, 145, 0, 1, 2)
        self.label_option_nl_before_throw = QtWidgets.QLabel("nl_before_throw")
        self.label_option_nl_before_throw.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_before_throw, 146, 0)
        self.option_nl_before_throw =  QtWidgets.QComboBox()
        self.option_nl_before_throw.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_before_throw.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_before_throw, 146, 1)
        #--------------------------------------------
        self.label_nl_namespace_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'namespace' and '{'.", "nl_namespace_brace")))
        self.label_nl_namespace_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_namespace_brace, 147, 0, 1, 2)
        self.label_option_nl_namespace_brace = QtWidgets.QLabel("nl_namespace_brace")
        self.label_option_nl_namespace_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_namespace_brace, 148, 0)
        self.option_nl_namespace_brace =  QtWidgets.QComboBox()
        self.option_nl_namespace_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_namespace_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_namespace_brace, 148, 1)
        #--------------------------------------------
        self.label_nl_template_class = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline after 'template<...>' of a template class.", "nl_template_class")))
        self.label_nl_template_class.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_template_class, 149, 0, 1, 2)
        self.label_option_nl_template_class = QtWidgets.QLabel("nl_template_class")
        self.label_option_nl_template_class.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_template_class, 150, 0)
        self.option_nl_template_class =  QtWidgets.QComboBox()
        self.option_nl_template_class.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_template_class.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_template_class, 150, 1)
        #--------------------------------------------
        self.label_nl_template_class_decl = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline after 'template<...>' of a template class declaration.", "nl_template_class_decl")+"\n\n"+self.tr("Overrides nl_template_class.", "nl_template_class_decl")))
        self.label_nl_template_class_decl.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_template_class_decl, 151, 0, 1, 2)
        self.label_option_nl_template_class_decl = QtWidgets.QLabel("nl_template_class_decl")
        self.label_option_nl_template_class_decl.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_template_class_decl, 152, 0)
        self.option_nl_template_class_decl =  QtWidgets.QComboBox()
        self.option_nl_template_class_decl.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_template_class_decl.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_template_class_decl, 152, 1)
        #--------------------------------------------
        self.label_nl_template_class_decl_special = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline after 'template<>' of a specialized class declaration.", "nl_template_class_decl_special")+"\n\n"+self.tr("Overrides nl_template_class_decl.", "nl_template_class_decl_special")))
        self.label_nl_template_class_decl_special.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_template_class_decl_special, 153, 0, 1, 2)
        self.label_option_nl_template_class_decl_special = QtWidgets.QLabel("nl_template_class_decl_special")
        self.label_option_nl_template_class_decl_special.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_template_class_decl_special, 154, 0)
        self.option_nl_template_class_decl_special =  QtWidgets.QComboBox()
        self.option_nl_template_class_decl_special.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_template_class_decl_special.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_template_class_decl_special, 154, 1)
        #--------------------------------------------
        self.label_nl_template_class_def = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline after 'template<...>' of a template class definition.", "nl_template_class_def")+"\n\n"+self.tr("Overrides nl_template_class.", "nl_template_class_def")))
        self.label_nl_template_class_def.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_template_class_def, 155, 0, 1, 2)
        self.label_option_nl_template_class_def = QtWidgets.QLabel("nl_template_class_def")
        self.label_option_nl_template_class_def.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_template_class_def, 156, 0)
        self.option_nl_template_class_def =  QtWidgets.QComboBox()
        self.option_nl_template_class_def.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_template_class_def.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_template_class_def, 156, 1)
        #--------------------------------------------
        self.label_nl_template_class_def_special = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline after 'template<>' of a specialized class definition.", "nl_template_class_def_special")+"\n\n"+self.tr("Overrides nl_template_class_def.", "nl_template_class_def_special")))
        self.label_nl_template_class_def_special.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_template_class_def_special, 157, 0, 1, 2)
        self.label_option_nl_template_class_def_special = QtWidgets.QLabel("nl_template_class_def_special")
        self.label_option_nl_template_class_def_special.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_template_class_def_special, 158, 0)
        self.option_nl_template_class_def_special =  QtWidgets.QComboBox()
        self.option_nl_template_class_def_special.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_template_class_def_special.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_template_class_def_special, 158, 1)
        #--------------------------------------------
        self.label_nl_template_func = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline after 'template<...>' of a template function.", "nl_template_func")))
        self.label_nl_template_func.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_template_func, 159, 0, 1, 2)
        self.label_option_nl_template_func = QtWidgets.QLabel("nl_template_func")
        self.label_option_nl_template_func.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_template_func, 160, 0)
        self.option_nl_template_func =  QtWidgets.QComboBox()
        self.option_nl_template_func.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_template_func.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_template_func, 160, 1)
        #--------------------------------------------
        self.label_nl_template_func_decl = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline after 'template<...>' of a template function\ndeclaration.", "nl_template_func_decl")+"\n\n"+self.tr("Overrides nl_template_func.", "nl_template_func_decl")))
        self.label_nl_template_func_decl.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_template_func_decl, 161, 0, 1, 2)
        self.label_option_nl_template_func_decl = QtWidgets.QLabel("nl_template_func_decl")
        self.label_option_nl_template_func_decl.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_template_func_decl, 162, 0)
        self.option_nl_template_func_decl =  QtWidgets.QComboBox()
        self.option_nl_template_func_decl.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_template_func_decl.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_template_func_decl, 162, 1)
        #--------------------------------------------
        self.label_nl_template_func_decl_special = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline after 'template<>' of a specialized function\ndeclaration.", "nl_template_func_decl_special")+"\n\n"+self.tr("Overrides nl_template_func_decl.", "nl_template_func_decl_special")))
        self.label_nl_template_func_decl_special.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_template_func_decl_special, 163, 0, 1, 2)
        self.label_option_nl_template_func_decl_special = QtWidgets.QLabel("nl_template_func_decl_special")
        self.label_option_nl_template_func_decl_special.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_template_func_decl_special, 164, 0)
        self.option_nl_template_func_decl_special =  QtWidgets.QComboBox()
        self.option_nl_template_func_decl_special.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_template_func_decl_special.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_template_func_decl_special, 164, 1)
        #--------------------------------------------
        self.label_nl_template_func_def = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline after 'template<...>' of a template function\ndefinition.", "nl_template_func_def")+"\n\n"+self.tr("Overrides nl_template_func.", "nl_template_func_def")))
        self.label_nl_template_func_def.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_template_func_def, 165, 0, 1, 2)
        self.label_option_nl_template_func_def = QtWidgets.QLabel("nl_template_func_def")
        self.label_option_nl_template_func_def.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_template_func_def, 166, 0)
        self.option_nl_template_func_def =  QtWidgets.QComboBox()
        self.option_nl_template_func_def.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_template_func_def.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_template_func_def, 166, 1)
        #--------------------------------------------
        self.label_nl_template_func_def_special = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline after 'template<>' of a specialized function\ndefinition.", "nl_template_func_def_special")+"\n\n"+self.tr("Overrides nl_template_func_def.", "nl_template_func_def_special")))
        self.label_nl_template_func_def_special.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_template_func_def_special, 167, 0, 1, 2)
        self.label_option_nl_template_func_def_special = QtWidgets.QLabel("nl_template_func_def_special")
        self.label_option_nl_template_func_def_special.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_template_func_def_special, 168, 0)
        self.option_nl_template_func_def_special =  QtWidgets.QComboBox()
        self.option_nl_template_func_def_special.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_template_func_def_special.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_template_func_def_special, 168, 1)
        #--------------------------------------------
        self.label_nl_template_var = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline after 'template<...>' of a template variable.", "nl_template_var")))
        self.label_nl_template_var.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_template_var, 169, 0, 1, 2)
        self.label_option_nl_template_var = QtWidgets.QLabel("nl_template_var")
        self.label_option_nl_template_var.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_template_var, 170, 0)
        self.option_nl_template_var =  QtWidgets.QComboBox()
        self.option_nl_template_var.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_template_var.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_template_var, 170, 1)
        #--------------------------------------------
        self.label_nl_template_using = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'template<...>' and 'using' of a templated\ntype alias.", "nl_template_using")))
        self.label_nl_template_using.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_template_using, 171, 0, 1, 2)
        self.label_option_nl_template_using = QtWidgets.QLabel("nl_template_using")
        self.label_option_nl_template_using.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_template_using, 172, 0)
        self.option_nl_template_using =  QtWidgets.QComboBox()
        self.option_nl_template_using.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_template_using.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_template_using, 172, 1)
        #--------------------------------------------
        self.label_nl_class_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'class' and '{'.", "nl_class_brace")))
        self.label_nl_class_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_class_brace, 173, 0, 1, 2)
        self.label_option_nl_class_brace = QtWidgets.QLabel("nl_class_brace")
        self.label_option_nl_class_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_class_brace, 174, 0)
        self.option_nl_class_brace =  QtWidgets.QComboBox()
        self.option_nl_class_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_class_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_class_brace, 174, 1)
        #--------------------------------------------
        self.label_nl_class_init_args = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline before or after (depending on pos_class_comma,\nmay not be IGNORE) each',' in the base class list.", "nl_class_init_args")))
        self.label_nl_class_init_args.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_class_init_args, 175, 0, 1, 2)
        self.label_option_nl_class_init_args = QtWidgets.QLabel("nl_class_init_args")
        self.label_option_nl_class_init_args.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_class_init_args, 176, 0)
        self.option_nl_class_init_args =  QtWidgets.QComboBox()
        self.option_nl_class_init_args.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_class_init_args.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_class_init_args, 176, 1)
        #--------------------------------------------
        self.label_nl_constr_init_args = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline after each ',' in the constructor member\ninitialization. Related to nl_constr_colon, pos_constr_colon and\npos_constr_comma.", "nl_constr_init_args")))
        self.label_nl_constr_init_args.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_constr_init_args, 177, 0, 1, 2)
        self.label_option_nl_constr_init_args = QtWidgets.QLabel("nl_constr_init_args")
        self.label_option_nl_constr_init_args.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_constr_init_args, 178, 0)
        self.option_nl_constr_init_args =  QtWidgets.QComboBox()
        self.option_nl_constr_init_args.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_constr_init_args.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_constr_init_args, 178, 1)
        #--------------------------------------------
        self.label_nl_enum_own_lines = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline before first element, after comma, and after last\nelement, in 'enum'.", "nl_enum_own_lines")))
        self.label_nl_enum_own_lines.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_enum_own_lines, 179, 0, 1, 2)
        self.label_option_nl_enum_own_lines = QtWidgets.QLabel("nl_enum_own_lines")
        self.label_option_nl_enum_own_lines.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_enum_own_lines, 180, 0)
        self.option_nl_enum_own_lines =  QtWidgets.QComboBox()
        self.option_nl_enum_own_lines.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_enum_own_lines.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_enum_own_lines, 180, 1)
        #--------------------------------------------
        self.label_nl_func_type_name = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between return type and function name in a function\ndefinition.\nmight be modified by nl_func_leave_one_liners", "nl_func_type_name")))
        self.label_nl_func_type_name.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_type_name, 181, 0, 1, 2)
        self.label_option_nl_func_type_name = QtWidgets.QLabel("nl_func_type_name")
        self.label_option_nl_func_type_name.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_type_name, 182, 0)
        self.option_nl_func_type_name =  QtWidgets.QComboBox()
        self.option_nl_func_type_name.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_type_name.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_type_name, 182, 1)
        #--------------------------------------------
        self.label_nl_func_type_name_class = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between return type and function name inside a class\ndefinition. If set to ignore, nl_func_type_name or nl_func_proto_type_name\nis used instead.", "nl_func_type_name_class")))
        self.label_nl_func_type_name_class.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_type_name_class, 183, 0, 1, 2)
        self.label_option_nl_func_type_name_class = QtWidgets.QLabel("nl_func_type_name_class")
        self.label_option_nl_func_type_name_class.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_type_name_class, 184, 0)
        self.option_nl_func_type_name_class =  QtWidgets.QComboBox()
        self.option_nl_func_type_name_class.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_type_name_class.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_type_name_class, 184, 1)
        #--------------------------------------------
        self.label_nl_func_class_scope = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between class specification and '::'\nin 'void A::f() { }'. Only appears in separate member implementation (does\nnot appear with in-line implementation).", "nl_func_class_scope")))
        self.label_nl_func_class_scope.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_class_scope, 185, 0, 1, 2)
        self.label_option_nl_func_class_scope = QtWidgets.QLabel("nl_func_class_scope")
        self.label_option_nl_func_class_scope.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_class_scope, 186, 0)
        self.option_nl_func_class_scope =  QtWidgets.QComboBox()
        self.option_nl_func_class_scope.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_class_scope.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_class_scope, 186, 1)
        #--------------------------------------------
        self.label_nl_func_scope_name = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between function scope and name, as in\n'void A :: <here> f() { }'.", "nl_func_scope_name")))
        self.label_nl_func_scope_name.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_scope_name, 187, 0, 1, 2)
        self.label_option_nl_func_scope_name = QtWidgets.QLabel("nl_func_scope_name")
        self.label_option_nl_func_scope_name.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_scope_name, 188, 0)
        self.option_nl_func_scope_name =  QtWidgets.QComboBox()
        self.option_nl_func_scope_name.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_scope_name.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_scope_name, 188, 1)
        #--------------------------------------------
        self.label_nl_func_proto_type_name = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between return type and function name in a prototype.", "nl_func_proto_type_name")))
        self.label_nl_func_proto_type_name.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_proto_type_name, 189, 0, 1, 2)
        self.label_option_nl_func_proto_type_name = QtWidgets.QLabel("nl_func_proto_type_name")
        self.label_option_nl_func_proto_type_name.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_proto_type_name, 190, 0)
        self.option_nl_func_proto_type_name =  QtWidgets.QComboBox()
        self.option_nl_func_proto_type_name.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_proto_type_name.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_proto_type_name, 190, 1)
        #--------------------------------------------
        self.label_nl_func_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between a function name and the opening '(' in the\ndeclaration.", "nl_func_paren")))
        self.label_nl_func_paren.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_paren, 191, 0, 1, 2)
        self.label_option_nl_func_paren = QtWidgets.QLabel("nl_func_paren")
        self.label_option_nl_func_paren.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_paren, 192, 0)
        self.option_nl_func_paren =  QtWidgets.QComboBox()
        self.option_nl_func_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_paren.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_paren, 192, 1)
        #--------------------------------------------
        self.label_nl_func_paren_empty = QtWidgets.QLabel(label("<hr>"+self.tr("Overrides nl_func_paren for functions with no parameters.", "nl_func_paren_empty")))
        self.label_nl_func_paren_empty.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_paren_empty, 193, 0, 1, 2)
        self.label_option_nl_func_paren_empty = QtWidgets.QLabel("nl_func_paren_empty")
        self.label_option_nl_func_paren_empty.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_paren_empty, 194, 0)
        self.option_nl_func_paren_empty =  QtWidgets.QComboBox()
        self.option_nl_func_paren_empty.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_paren_empty.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_paren_empty, 194, 1)
        #--------------------------------------------
        self.label_nl_func_def_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between a function name and the opening '(' in the\ndefinition.", "nl_func_def_paren")))
        self.label_nl_func_def_paren.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_def_paren, 195, 0, 1, 2)
        self.label_option_nl_func_def_paren = QtWidgets.QLabel("nl_func_def_paren")
        self.label_option_nl_func_def_paren.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_def_paren, 196, 0)
        self.option_nl_func_def_paren =  QtWidgets.QComboBox()
        self.option_nl_func_def_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_def_paren.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_def_paren, 196, 1)
        #--------------------------------------------
        self.label_nl_func_def_paren_empty = QtWidgets.QLabel(label("<hr>"+self.tr("Overrides nl_func_def_paren for functions with no parameters.", "nl_func_def_paren_empty")))
        self.label_nl_func_def_paren_empty.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_def_paren_empty, 197, 0, 1, 2)
        self.label_option_nl_func_def_paren_empty = QtWidgets.QLabel("nl_func_def_paren_empty")
        self.label_option_nl_func_def_paren_empty.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_def_paren_empty, 198, 0)
        self.option_nl_func_def_paren_empty =  QtWidgets.QComboBox()
        self.option_nl_func_def_paren_empty.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_def_paren_empty.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_def_paren_empty, 198, 1)
        #--------------------------------------------
        self.label_nl_func_call_paren = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between a function name and the opening '(' in the\ncall.", "nl_func_call_paren")))
        self.label_nl_func_call_paren.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_call_paren, 199, 0, 1, 2)
        self.label_option_nl_func_call_paren = QtWidgets.QLabel("nl_func_call_paren")
        self.label_option_nl_func_call_paren.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_call_paren, 200, 0)
        self.option_nl_func_call_paren =  QtWidgets.QComboBox()
        self.option_nl_func_call_paren.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_call_paren.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_call_paren, 200, 1)
        #--------------------------------------------
        self.label_nl_func_call_paren_empty = QtWidgets.QLabel(label("<hr>"+self.tr("Overrides nl_func_call_paren for functions with no parameters.", "nl_func_call_paren_empty")))
        self.label_nl_func_call_paren_empty.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_call_paren_empty, 201, 0, 1, 2)
        self.label_option_nl_func_call_paren_empty = QtWidgets.QLabel("nl_func_call_paren_empty")
        self.label_option_nl_func_call_paren_empty.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_call_paren_empty, 202, 0)
        self.option_nl_func_call_paren_empty =  QtWidgets.QComboBox()
        self.option_nl_func_call_paren_empty.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_call_paren_empty.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_call_paren_empty, 202, 1)
        #--------------------------------------------
        self.label_nl_func_decl_start = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline after '(' in a function declaration.", "nl_func_decl_start")))
        self.label_nl_func_decl_start.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_decl_start, 203, 0, 1, 2)
        self.label_option_nl_func_decl_start = QtWidgets.QLabel("nl_func_decl_start")
        self.label_option_nl_func_decl_start.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_decl_start, 204, 0)
        self.option_nl_func_decl_start =  QtWidgets.QComboBox()
        self.option_nl_func_decl_start.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_decl_start.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_decl_start, 204, 1)
        #--------------------------------------------
        self.label_nl_func_def_start = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline after '(' in a function definition.", "nl_func_def_start")))
        self.label_nl_func_def_start.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_def_start, 205, 0, 1, 2)
        self.label_option_nl_func_def_start = QtWidgets.QLabel("nl_func_def_start")
        self.label_option_nl_func_def_start.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_def_start, 206, 0)
        self.option_nl_func_def_start =  QtWidgets.QComboBox()
        self.option_nl_func_def_start.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_def_start.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_def_start, 206, 1)
        #--------------------------------------------
        self.label_nl_func_decl_start_single = QtWidgets.QLabel(label("<hr>"+self.tr("Overrides nl_func_decl_start when there is only one parameter.", "nl_func_decl_start_single")))
        self.label_nl_func_decl_start_single.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_decl_start_single, 207, 0, 1, 2)
        self.label_option_nl_func_decl_start_single = QtWidgets.QLabel("nl_func_decl_start_single")
        self.label_option_nl_func_decl_start_single.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_decl_start_single, 208, 0)
        self.option_nl_func_decl_start_single =  QtWidgets.QComboBox()
        self.option_nl_func_decl_start_single.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_decl_start_single.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_decl_start_single, 208, 1)
        #--------------------------------------------
        self.label_nl_func_def_start_single = QtWidgets.QLabel(label("<hr>"+self.tr("Overrides nl_func_def_start when there is only one parameter.", "nl_func_def_start_single")))
        self.label_nl_func_def_start_single.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_def_start_single, 209, 0, 1, 2)
        self.label_option_nl_func_def_start_single = QtWidgets.QLabel("nl_func_def_start_single")
        self.label_option_nl_func_def_start_single.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_def_start_single, 210, 0)
        self.option_nl_func_def_start_single =  QtWidgets.QComboBox()
        self.option_nl_func_def_start_single.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_def_start_single.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_def_start_single, 210, 1)
        #--------------------------------------------
        self.label_nl_func_decl_start_multi_line = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline after '(' in a function declaration if '(' and ')'\nare in different lines. If false, nl_func_decl_start is used instead.", "nl_func_decl_start_multi_line")))
        self.label_nl_func_decl_start_multi_line.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_decl_start_multi_line, 211, 0, 1, 2)
        self.label_option_nl_func_decl_start_multi_line = QtWidgets.QLabel("nl_func_decl_start_multi_line")
        self.label_option_nl_func_decl_start_multi_line.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_decl_start_multi_line, 212, 0)
        self.option_nl_func_decl_start_multi_line =  QtWidgets.QComboBox()
        self.option_nl_func_decl_start_multi_line.addItems(['true','false'])
        self.option_nl_func_decl_start_multi_line.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_func_decl_start_multi_line, 212, 1)
        #--------------------------------------------
        self.label_nl_func_def_start_multi_line = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline after '(' in a function definition if '(' and ')'\nare in different lines. If false, nl_func_def_start is used instead.", "nl_func_def_start_multi_line")))
        self.label_nl_func_def_start_multi_line.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_def_start_multi_line, 213, 0, 1, 2)
        self.label_option_nl_func_def_start_multi_line = QtWidgets.QLabel("nl_func_def_start_multi_line")
        self.label_option_nl_func_def_start_multi_line.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_def_start_multi_line, 214, 0)
        self.option_nl_func_def_start_multi_line =  QtWidgets.QComboBox()
        self.option_nl_func_def_start_multi_line.addItems(['true','false'])
        self.option_nl_func_def_start_multi_line.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_func_def_start_multi_line, 214, 1)
        #--------------------------------------------
        self.label_nl_func_decl_args = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline after each ',' in a function declaration.", "nl_func_decl_args")))
        self.label_nl_func_decl_args.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_decl_args, 215, 0, 1, 2)
        self.label_option_nl_func_decl_args = QtWidgets.QLabel("nl_func_decl_args")
        self.label_option_nl_func_decl_args.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_decl_args, 216, 0)
        self.option_nl_func_decl_args =  QtWidgets.QComboBox()
        self.option_nl_func_decl_args.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_decl_args.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_decl_args, 216, 1)
        #--------------------------------------------
        self.label_nl_func_def_args = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline after each ',' in a function definition.", "nl_func_def_args")))
        self.label_nl_func_def_args.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_def_args, 217, 0, 1, 2)
        self.label_option_nl_func_def_args = QtWidgets.QLabel("nl_func_def_args")
        self.label_option_nl_func_def_args.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_def_args, 218, 0)
        self.option_nl_func_def_args =  QtWidgets.QComboBox()
        self.option_nl_func_def_args.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_def_args.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_def_args, 218, 1)
        #--------------------------------------------
        self.label_nl_func_call_args = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline after each ',' in a function call.", "nl_func_call_args")))
        self.label_nl_func_call_args.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_call_args, 219, 0, 1, 2)
        self.label_option_nl_func_call_args = QtWidgets.QLabel("nl_func_call_args")
        self.label_option_nl_func_call_args.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_call_args, 220, 0)
        self.option_nl_func_call_args =  QtWidgets.QComboBox()
        self.option_nl_func_call_args.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_call_args.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_call_args, 220, 1)
        #--------------------------------------------
        self.label_nl_func_decl_args_multi_line = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline after each ',' in a function declaration if '('\nand ')' are in different lines. If false, nl_func_decl_args is used instead.", "nl_func_decl_args_multi_line")))
        self.label_nl_func_decl_args_multi_line.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_decl_args_multi_line, 221, 0, 1, 2)
        self.label_option_nl_func_decl_args_multi_line = QtWidgets.QLabel("nl_func_decl_args_multi_line")
        self.label_option_nl_func_decl_args_multi_line.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_decl_args_multi_line, 222, 0)
        self.option_nl_func_decl_args_multi_line =  QtWidgets.QComboBox()
        self.option_nl_func_decl_args_multi_line.addItems(['true','false'])
        self.option_nl_func_decl_args_multi_line.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_func_decl_args_multi_line, 222, 1)
        #--------------------------------------------
        self.label_nl_func_def_args_multi_line = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline after each ',' in a function definition if '('\nand ')' are in different lines. If false, nl_func_def_args is used instead.", "nl_func_def_args_multi_line")))
        self.label_nl_func_def_args_multi_line.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_def_args_multi_line, 223, 0, 1, 2)
        self.label_option_nl_func_def_args_multi_line = QtWidgets.QLabel("nl_func_def_args_multi_line")
        self.label_option_nl_func_def_args_multi_line.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_def_args_multi_line, 224, 0)
        self.option_nl_func_def_args_multi_line =  QtWidgets.QComboBox()
        self.option_nl_func_def_args_multi_line.addItems(['true','false'])
        self.option_nl_func_def_args_multi_line.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_func_def_args_multi_line, 224, 1)
        #--------------------------------------------
        self.label_nl_func_decl_end = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline before the ')' in a function declaration.", "nl_func_decl_end")))
        self.label_nl_func_decl_end.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_decl_end, 225, 0, 1, 2)
        self.label_option_nl_func_decl_end = QtWidgets.QLabel("nl_func_decl_end")
        self.label_option_nl_func_decl_end.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_decl_end, 226, 0)
        self.option_nl_func_decl_end =  QtWidgets.QComboBox()
        self.option_nl_func_decl_end.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_decl_end.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_decl_end, 226, 1)
        #--------------------------------------------
        self.label_nl_func_def_end = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline before the ')' in a function definition.", "nl_func_def_end")))
        self.label_nl_func_def_end.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_def_end, 227, 0, 1, 2)
        self.label_option_nl_func_def_end = QtWidgets.QLabel("nl_func_def_end")
        self.label_option_nl_func_def_end.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_def_end, 228, 0)
        self.option_nl_func_def_end =  QtWidgets.QComboBox()
        self.option_nl_func_def_end.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_def_end.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_def_end, 228, 1)
        #--------------------------------------------
        self.label_nl_func_decl_end_single = QtWidgets.QLabel(label("<hr>"+self.tr("Overrides nl_func_decl_end when there is only one parameter.", "nl_func_decl_end_single")))
        self.label_nl_func_decl_end_single.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_decl_end_single, 229, 0, 1, 2)
        self.label_option_nl_func_decl_end_single = QtWidgets.QLabel("nl_func_decl_end_single")
        self.label_option_nl_func_decl_end_single.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_decl_end_single, 230, 0)
        self.option_nl_func_decl_end_single =  QtWidgets.QComboBox()
        self.option_nl_func_decl_end_single.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_decl_end_single.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_decl_end_single, 230, 1)
        #--------------------------------------------
        self.label_nl_func_def_end_single = QtWidgets.QLabel(label("<hr>"+self.tr("Overrides nl_func_def_end when there is only one parameter.", "nl_func_def_end_single")))
        self.label_nl_func_def_end_single.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_def_end_single, 231, 0, 1, 2)
        self.label_option_nl_func_def_end_single = QtWidgets.QLabel("nl_func_def_end_single")
        self.label_option_nl_func_def_end_single.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_def_end_single, 232, 0)
        self.option_nl_func_def_end_single =  QtWidgets.QComboBox()
        self.option_nl_func_def_end_single.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_def_end_single.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_def_end_single, 232, 1)
        #--------------------------------------------
        self.label_nl_func_decl_end_multi_line = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline before ')' in a function declaration if '(' and ')'\nare in different lines. If false, nl_func_decl_end is used instead.", "nl_func_decl_end_multi_line")))
        self.label_nl_func_decl_end_multi_line.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_decl_end_multi_line, 233, 0, 1, 2)
        self.label_option_nl_func_decl_end_multi_line = QtWidgets.QLabel("nl_func_decl_end_multi_line")
        self.label_option_nl_func_decl_end_multi_line.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_decl_end_multi_line, 234, 0)
        self.option_nl_func_decl_end_multi_line =  QtWidgets.QComboBox()
        self.option_nl_func_decl_end_multi_line.addItems(['true','false'])
        self.option_nl_func_decl_end_multi_line.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_func_decl_end_multi_line, 234, 1)
        #--------------------------------------------
        self.label_nl_func_def_end_multi_line = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline before ')' in a function definition if '(' and ')'\nare in different lines. If false, nl_func_def_end is used instead.", "nl_func_def_end_multi_line")))
        self.label_nl_func_def_end_multi_line.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_def_end_multi_line, 235, 0, 1, 2)
        self.label_option_nl_func_def_end_multi_line = QtWidgets.QLabel("nl_func_def_end_multi_line")
        self.label_option_nl_func_def_end_multi_line.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_def_end_multi_line, 236, 0)
        self.option_nl_func_def_end_multi_line =  QtWidgets.QComboBox()
        self.option_nl_func_def_end_multi_line.addItems(['true','false'])
        self.option_nl_func_def_end_multi_line.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_func_def_end_multi_line, 236, 1)
        #--------------------------------------------
        self.label_nl_func_decl_empty = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between '()' in a function declaration.", "nl_func_decl_empty")))
        self.label_nl_func_decl_empty.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_decl_empty, 237, 0, 1, 2)
        self.label_option_nl_func_decl_empty = QtWidgets.QLabel("nl_func_decl_empty")
        self.label_option_nl_func_decl_empty.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_decl_empty, 238, 0)
        self.option_nl_func_decl_empty =  QtWidgets.QComboBox()
        self.option_nl_func_decl_empty.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_decl_empty.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_decl_empty, 238, 1)
        #--------------------------------------------
        self.label_nl_func_def_empty = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between '()' in a function definition.", "nl_func_def_empty")))
        self.label_nl_func_def_empty.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_def_empty, 239, 0, 1, 2)
        self.label_option_nl_func_def_empty = QtWidgets.QLabel("nl_func_def_empty")
        self.label_option_nl_func_def_empty.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_def_empty, 240, 0)
        self.option_nl_func_def_empty =  QtWidgets.QComboBox()
        self.option_nl_func_def_empty.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_def_empty.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_def_empty, 240, 1)
        #--------------------------------------------
        self.label_nl_func_call_empty = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between '()' in a function call.", "nl_func_call_empty")))
        self.label_nl_func_call_empty.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_call_empty, 241, 0, 1, 2)
        self.label_option_nl_func_call_empty = QtWidgets.QLabel("nl_func_call_empty")
        self.label_option_nl_func_call_empty.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_call_empty, 242, 0)
        self.option_nl_func_call_empty =  QtWidgets.QComboBox()
        self.option_nl_func_call_empty.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_call_empty.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_call_empty, 242, 1)
        #--------------------------------------------
        self.label_nl_func_call_start = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline after '(' in a function call,\nhas preference over nl_func_call_start_multi_line.", "nl_func_call_start")))
        self.label_nl_func_call_start.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_call_start, 243, 0, 1, 2)
        self.label_option_nl_func_call_start = QtWidgets.QLabel("nl_func_call_start")
        self.label_option_nl_func_call_start.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_call_start, 244, 0)
        self.option_nl_func_call_start =  QtWidgets.QComboBox()
        self.option_nl_func_call_start.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_call_start.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_call_start, 244, 1)
        #--------------------------------------------
        self.label_nl_func_call_end = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline before ')' in a function call.", "nl_func_call_end")))
        self.label_nl_func_call_end.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_call_end, 245, 0, 1, 2)
        self.label_option_nl_func_call_end = QtWidgets.QLabel("nl_func_call_end")
        self.label_option_nl_func_call_end.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_call_end, 246, 0)
        self.option_nl_func_call_end =  QtWidgets.QComboBox()
        self.option_nl_func_call_end.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_func_call_end.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_func_call_end, 246, 1)
        #--------------------------------------------
        self.label_nl_func_call_start_multi_line = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline after '(' in a function call if '(' and ')' are in\ndifferent lines.", "nl_func_call_start_multi_line")))
        self.label_nl_func_call_start_multi_line.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_call_start_multi_line, 247, 0, 1, 2)
        self.label_option_nl_func_call_start_multi_line = QtWidgets.QLabel("nl_func_call_start_multi_line")
        self.label_option_nl_func_call_start_multi_line.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_call_start_multi_line, 248, 0)
        self.option_nl_func_call_start_multi_line =  QtWidgets.QComboBox()
        self.option_nl_func_call_start_multi_line.addItems(['true','false'])
        self.option_nl_func_call_start_multi_line.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_func_call_start_multi_line, 248, 1)
        #--------------------------------------------
        self.label_nl_func_call_args_multi_line = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline after each ',' in a function call if '(' and ')'\nare in different lines.", "nl_func_call_args_multi_line")))
        self.label_nl_func_call_args_multi_line.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_call_args_multi_line, 249, 0, 1, 2)
        self.label_option_nl_func_call_args_multi_line = QtWidgets.QLabel("nl_func_call_args_multi_line")
        self.label_option_nl_func_call_args_multi_line.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_call_args_multi_line, 250, 0)
        self.option_nl_func_call_args_multi_line =  QtWidgets.QComboBox()
        self.option_nl_func_call_args_multi_line.addItems(['true','false'])
        self.option_nl_func_call_args_multi_line.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_func_call_args_multi_line, 250, 1)
        #--------------------------------------------
        self.label_nl_func_call_end_multi_line = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline before ')' in a function call if '(' and ')' are in\ndifferent lines.", "nl_func_call_end_multi_line")))
        self.label_nl_func_call_end_multi_line.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_call_end_multi_line, 251, 0, 1, 2)
        self.label_option_nl_func_call_end_multi_line = QtWidgets.QLabel("nl_func_call_end_multi_line")
        self.label_option_nl_func_call_end_multi_line.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_call_end_multi_line, 252, 0)
        self.option_nl_func_call_end_multi_line =  QtWidgets.QComboBox()
        self.option_nl_func_call_end_multi_line.addItems(['true','false'])
        self.option_nl_func_call_end_multi_line.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_func_call_end_multi_line, 252, 1)
        #--------------------------------------------
        self.label_nl_func_call_args_multi_line_ignore_closures = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to respect nl_func_call_XXX option in case of closure args.", "nl_func_call_args_multi_line_ignore_closures")))
        self.label_nl_func_call_args_multi_line_ignore_closures.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_func_call_args_multi_line_ignore_closures, 253, 0, 1, 2)
        self.label_option_nl_func_call_args_multi_line_ignore_closures = QtWidgets.QLabel("nl_func_call_args_multi_line_ignore_closures")
        self.label_option_nl_func_call_args_multi_line_ignore_closures.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_func_call_args_multi_line_ignore_closures, 254, 0)
        self.option_nl_func_call_args_multi_line_ignore_closures =  QtWidgets.QComboBox()
        self.option_nl_func_call_args_multi_line_ignore_closures.addItems(['true','false'])
        self.option_nl_func_call_args_multi_line_ignore_closures.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_func_call_args_multi_line_ignore_closures, 254, 1)
        #--------------------------------------------
        self.label_nl_template_start = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline after '<' of a template parameter list.", "nl_template_start")))
        self.label_nl_template_start.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_template_start, 255, 0, 1, 2)
        self.label_option_nl_template_start = QtWidgets.QLabel("nl_template_start")
        self.label_option_nl_template_start.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_template_start, 256, 0)
        self.option_nl_template_start =  QtWidgets.QComboBox()
        self.option_nl_template_start.addItems(['true','false'])
        self.option_nl_template_start.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_template_start, 256, 1)
        #--------------------------------------------
        self.label_nl_template_args = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline after each ',' in a template parameter list.", "nl_template_args")))
        self.label_nl_template_args.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_template_args, 257, 0, 1, 2)
        self.label_option_nl_template_args = QtWidgets.QLabel("nl_template_args")
        self.label_option_nl_template_args.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_template_args, 258, 0)
        self.option_nl_template_args =  QtWidgets.QComboBox()
        self.option_nl_template_args.addItems(['true','false'])
        self.option_nl_template_args.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_template_args, 258, 1)
        #--------------------------------------------
        self.label_nl_template_end = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline before '>' of a template parameter list.", "nl_template_end")))
        self.label_nl_template_end.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_template_end, 259, 0, 1, 2)
        self.label_option_nl_template_end = QtWidgets.QLabel("nl_template_end")
        self.label_option_nl_template_end.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_template_end, 260, 0)
        self.option_nl_template_end =  QtWidgets.QComboBox()
        self.option_nl_template_end.addItems(['true','false'])
        self.option_nl_template_end.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_template_end, 260, 1)
        #--------------------------------------------
        self.label_nl_oc_msg_args = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Whether to put each Objective-C message parameter on a separate line.\nSee nl_oc_msg_leave_one_liner.", "nl_oc_msg_args")))
        self.label_nl_oc_msg_args.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_oc_msg_args, 261, 0, 1, 2)
        self.label_option_nl_oc_msg_args = QtWidgets.QLabel("nl_oc_msg_args")
        self.label_option_nl_oc_msg_args.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_oc_msg_args, 262, 0)
        self.option_nl_oc_msg_args =  QtWidgets.QComboBox()
        self.option_nl_oc_msg_args.addItems(['true','false'])
        self.option_nl_oc_msg_args.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_oc_msg_args, 262, 1)
        #--------------------------------------------
        self.label_nl_oc_msg_args_min_params = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Minimum number of Objective-C message parameters before applying nl_oc_msg_args.", "nl_oc_msg_args_min_params")))
        self.label_nl_oc_msg_args_min_params.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_oc_msg_args_min_params, 263, 0, 1, 2)
        self.label_option_nl_oc_msg_args_min_params = QtWidgets.QLabel("nl_oc_msg_args_min_params")
        self.label_option_nl_oc_msg_args_min_params.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_oc_msg_args_min_params, 264, 0)
        self.option_nl_oc_msg_args_min_params =  QtWidgets.QSpinBox()
        self.option_nl_oc_msg_args_min_params.setMinimum( 0)
        self.option_nl_oc_msg_args_min_params.setMaximum( 16)
        self.option_nl_oc_msg_args_min_params.setValue(0)
        self.group_page_layout_4.addWidget(self.option_nl_oc_msg_args_min_params, 264, 1)
        #--------------------------------------------
        self.label_nl_oc_msg_args_max_code_width = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Max code width of Objective-C message before applying nl_oc_msg_args.", "nl_oc_msg_args_max_code_width")))
        self.label_nl_oc_msg_args_max_code_width.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_oc_msg_args_max_code_width, 265, 0, 1, 2)
        self.label_option_nl_oc_msg_args_max_code_width = QtWidgets.QLabel("nl_oc_msg_args_max_code_width")
        self.label_option_nl_oc_msg_args_max_code_width.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_oc_msg_args_max_code_width, 266, 0)
        self.option_nl_oc_msg_args_max_code_width =  QtWidgets.QSpinBox()
        self.option_nl_oc_msg_args_max_code_width.setMinimum( 0)
        self.option_nl_oc_msg_args_max_code_width.setMaximum( 10000)
        self.option_nl_oc_msg_args_max_code_width.setValue(0)
        self.group_page_layout_4.addWidget(self.option_nl_oc_msg_args_max_code_width, 266, 1)
        #--------------------------------------------
        self.label_nl_oc_msg_args_finish_multi_line = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Whether to apply nl_oc_msg_args if some of the parameters are already\non new lines. Overrides nl_oc_msg_args_min_params and nl_oc_msg_args_max_code_width.", "nl_oc_msg_args_finish_multi_line")))
        self.label_nl_oc_msg_args_finish_multi_line.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_oc_msg_args_finish_multi_line, 267, 0, 1, 2)
        self.label_option_nl_oc_msg_args_finish_multi_line = QtWidgets.QLabel("nl_oc_msg_args_finish_multi_line")
        self.label_option_nl_oc_msg_args_finish_multi_line.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_oc_msg_args_finish_multi_line, 268, 0)
        self.option_nl_oc_msg_args_finish_multi_line =  QtWidgets.QComboBox()
        self.option_nl_oc_msg_args_finish_multi_line.addItems(['true','false'])
        self.option_nl_oc_msg_args_finish_multi_line.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_oc_msg_args_finish_multi_line, 268, 1)
        #--------------------------------------------
        self.label_nl_fdef_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between function signature and '{'.", "nl_fdef_brace")))
        self.label_nl_fdef_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_fdef_brace, 269, 0, 1, 2)
        self.label_option_nl_fdef_brace = QtWidgets.QLabel("nl_fdef_brace")
        self.label_option_nl_fdef_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_fdef_brace, 270, 0)
        self.option_nl_fdef_brace =  QtWidgets.QComboBox()
        self.option_nl_fdef_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_fdef_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_fdef_brace, 270, 1)
        #--------------------------------------------
        self.label_nl_fdef_brace_cond = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between function signature and '{',\nif signature ends with ')'. Overrides nl_fdef_brace.", "nl_fdef_brace_cond")))
        self.label_nl_fdef_brace_cond.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_fdef_brace_cond, 271, 0, 1, 2)
        self.label_option_nl_fdef_brace_cond = QtWidgets.QLabel("nl_fdef_brace_cond")
        self.label_option_nl_fdef_brace_cond.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_fdef_brace_cond, 272, 0)
        self.option_nl_fdef_brace_cond =  QtWidgets.QComboBox()
        self.option_nl_fdef_brace_cond.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_fdef_brace_cond.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_fdef_brace_cond, 272, 1)
        #--------------------------------------------
        self.label_nl_cpp_ldef_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between C++11 lambda signature and '{'.", "nl_cpp_ldef_brace")))
        self.label_nl_cpp_ldef_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_cpp_ldef_brace, 273, 0, 1, 2)
        self.label_option_nl_cpp_ldef_brace = QtWidgets.QLabel("nl_cpp_ldef_brace")
        self.label_option_nl_cpp_ldef_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_cpp_ldef_brace, 274, 0)
        self.option_nl_cpp_ldef_brace =  QtWidgets.QComboBox()
        self.option_nl_cpp_ldef_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_cpp_ldef_brace.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_cpp_ldef_brace, 274, 1)
        #--------------------------------------------
        self.label_nl_return_expr = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'return' and the return expression.", "nl_return_expr")))
        self.label_nl_return_expr.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_return_expr, 275, 0, 1, 2)
        self.label_option_nl_return_expr = QtWidgets.QLabel("nl_return_expr")
        self.label_option_nl_return_expr.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_return_expr, 276, 0)
        self.option_nl_return_expr =  QtWidgets.QComboBox()
        self.option_nl_return_expr.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_return_expr.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_return_expr, 276, 1)
        #--------------------------------------------
        self.label_nl_throw_expr = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between 'throw' and the throw expression.", "nl_throw_expr")))
        self.label_nl_throw_expr.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_throw_expr, 277, 0, 1, 2)
        self.label_option_nl_throw_expr = QtWidgets.QLabel("nl_throw_expr")
        self.label_option_nl_throw_expr.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_throw_expr, 278, 0)
        self.option_nl_throw_expr =  QtWidgets.QComboBox()
        self.option_nl_throw_expr.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_throw_expr.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_throw_expr, 278, 1)
        #--------------------------------------------
        self.label_nl_after_semicolon = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline after semicolons, except in 'for' statements.", "nl_after_semicolon")))
        self.label_nl_after_semicolon.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_after_semicolon, 279, 0, 1, 2)
        self.label_option_nl_after_semicolon = QtWidgets.QLabel("nl_after_semicolon")
        self.label_option_nl_after_semicolon.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_after_semicolon, 280, 0)
        self.option_nl_after_semicolon =  QtWidgets.QComboBox()
        self.option_nl_after_semicolon.addItems(['true','false'])
        self.option_nl_after_semicolon.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_after_semicolon, 280, 1)
        #--------------------------------------------
        self.label_nl_paren_dbrace_open = QtWidgets.QLabel(label("<hr>"+self.tr("(Java) Add or remove newline between the ')' and '{{' of the double brace\ninitializer.", "nl_paren_dbrace_open")))
        self.label_nl_paren_dbrace_open.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_paren_dbrace_open, 281, 0, 1, 2)
        self.label_option_nl_paren_dbrace_open = QtWidgets.QLabel("nl_paren_dbrace_open")
        self.label_option_nl_paren_dbrace_open.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_paren_dbrace_open, 282, 0)
        self.option_nl_paren_dbrace_open =  QtWidgets.QComboBox()
        self.option_nl_paren_dbrace_open.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_paren_dbrace_open.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_paren_dbrace_open, 282, 1)
        #--------------------------------------------
        self.label_nl_type_brace_init_lst = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline after the type in an unnamed temporary\ndirect-list-initialization, better:\nbefore a direct-list-initialization.", "nl_type_brace_init_lst")))
        self.label_nl_type_brace_init_lst.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_type_brace_init_lst, 283, 0, 1, 2)
        self.label_option_nl_type_brace_init_lst = QtWidgets.QLabel("nl_type_brace_init_lst")
        self.label_option_nl_type_brace_init_lst.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_type_brace_init_lst, 284, 0)
        self.option_nl_type_brace_init_lst =  QtWidgets.QComboBox()
        self.option_nl_type_brace_init_lst.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_type_brace_init_lst.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_type_brace_init_lst, 284, 1)
        #--------------------------------------------
        self.label_nl_type_brace_init_lst_open = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline after the open brace in an unnamed temporary\ndirect-list-initialization.", "nl_type_brace_init_lst_open")))
        self.label_nl_type_brace_init_lst_open.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_type_brace_init_lst_open, 285, 0, 1, 2)
        self.label_option_nl_type_brace_init_lst_open = QtWidgets.QLabel("nl_type_brace_init_lst_open")
        self.label_option_nl_type_brace_init_lst_open.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_type_brace_init_lst_open, 286, 0)
        self.option_nl_type_brace_init_lst_open =  QtWidgets.QComboBox()
        self.option_nl_type_brace_init_lst_open.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_type_brace_init_lst_open.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_type_brace_init_lst_open, 286, 1)
        #--------------------------------------------
        self.label_nl_type_brace_init_lst_close = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline before the close brace in an unnamed temporary\ndirect-list-initialization.", "nl_type_brace_init_lst_close")))
        self.label_nl_type_brace_init_lst_close.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_type_brace_init_lst_close, 287, 0, 1, 2)
        self.label_option_nl_type_brace_init_lst_close = QtWidgets.QLabel("nl_type_brace_init_lst_close")
        self.label_option_nl_type_brace_init_lst_close.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_type_brace_init_lst_close, 288, 0)
        self.option_nl_type_brace_init_lst_close =  QtWidgets.QComboBox()
        self.option_nl_type_brace_init_lst_close.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_type_brace_init_lst_close.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_type_brace_init_lst_close, 288, 1)
        #--------------------------------------------
        self.label_nl_before_brace_open = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline before '{'.", "nl_before_brace_open")))
        self.label_nl_before_brace_open.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_before_brace_open, 289, 0, 1, 2)
        self.label_option_nl_before_brace_open = QtWidgets.QLabel("nl_before_brace_open")
        self.label_option_nl_before_brace_open.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_before_brace_open, 290, 0)
        self.option_nl_before_brace_open =  QtWidgets.QComboBox()
        self.option_nl_before_brace_open.addItems(['true','false'])
        self.option_nl_before_brace_open.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_before_brace_open, 290, 1)
        #--------------------------------------------
        self.label_nl_after_brace_open = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline after '{'.", "nl_after_brace_open")))
        self.label_nl_after_brace_open.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_after_brace_open, 291, 0, 1, 2)
        self.label_option_nl_after_brace_open = QtWidgets.QLabel("nl_after_brace_open")
        self.label_option_nl_after_brace_open.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_after_brace_open, 292, 0)
        self.option_nl_after_brace_open =  QtWidgets.QComboBox()
        self.option_nl_after_brace_open.addItems(['true','false'])
        self.option_nl_after_brace_open.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_after_brace_open, 292, 1)
        #--------------------------------------------
        self.label_nl_after_brace_open_cmt = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline between the open brace and a trailing single-line\ncomment. Requires nl_after_brace_open=true.", "nl_after_brace_open_cmt")))
        self.label_nl_after_brace_open_cmt.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_after_brace_open_cmt, 293, 0, 1, 2)
        self.label_option_nl_after_brace_open_cmt = QtWidgets.QLabel("nl_after_brace_open_cmt")
        self.label_option_nl_after_brace_open_cmt.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_after_brace_open_cmt, 294, 0)
        self.option_nl_after_brace_open_cmt =  QtWidgets.QComboBox()
        self.option_nl_after_brace_open_cmt.addItems(['true','false'])
        self.option_nl_after_brace_open_cmt.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_after_brace_open_cmt, 294, 1)
        #--------------------------------------------
        self.label_nl_after_vbrace_open = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline after a virtual brace open with a non-empty body.\nThese occur in un-braced if/while/do/for statement bodies.", "nl_after_vbrace_open")))
        self.label_nl_after_vbrace_open.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_after_vbrace_open, 295, 0, 1, 2)
        self.label_option_nl_after_vbrace_open = QtWidgets.QLabel("nl_after_vbrace_open")
        self.label_option_nl_after_vbrace_open.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_after_vbrace_open, 296, 0)
        self.option_nl_after_vbrace_open =  QtWidgets.QComboBox()
        self.option_nl_after_vbrace_open.addItems(['true','false'])
        self.option_nl_after_vbrace_open.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_after_vbrace_open, 296, 1)
        #--------------------------------------------
        self.label_nl_after_vbrace_open_empty = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline after a virtual brace open with an empty body.\nThese occur in un-braced if/while/do/for statement bodies.", "nl_after_vbrace_open_empty")))
        self.label_nl_after_vbrace_open_empty.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_after_vbrace_open_empty, 297, 0, 1, 2)
        self.label_option_nl_after_vbrace_open_empty = QtWidgets.QLabel("nl_after_vbrace_open_empty")
        self.label_option_nl_after_vbrace_open_empty.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_after_vbrace_open_empty, 298, 0)
        self.option_nl_after_vbrace_open_empty =  QtWidgets.QComboBox()
        self.option_nl_after_vbrace_open_empty.addItems(['true','false'])
        self.option_nl_after_vbrace_open_empty.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_after_vbrace_open_empty, 298, 1)
        #--------------------------------------------
        self.label_nl_after_brace_close = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline after '}'. Does not apply if followed by a\nnecessary ';'.", "nl_after_brace_close")))
        self.label_nl_after_brace_close.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_after_brace_close, 299, 0, 1, 2)
        self.label_option_nl_after_brace_close = QtWidgets.QLabel("nl_after_brace_close")
        self.label_option_nl_after_brace_close.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_after_brace_close, 300, 0)
        self.option_nl_after_brace_close =  QtWidgets.QComboBox()
        self.option_nl_after_brace_close.addItems(['true','false'])
        self.option_nl_after_brace_close.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_after_brace_close, 300, 1)
        #--------------------------------------------
        self.label_nl_after_vbrace_close = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline after a virtual brace close,\nas in 'if (foo) a++; <here> return;'.", "nl_after_vbrace_close")))
        self.label_nl_after_vbrace_close.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_after_vbrace_close, 301, 0, 1, 2)
        self.label_option_nl_after_vbrace_close = QtWidgets.QLabel("nl_after_vbrace_close")
        self.label_option_nl_after_vbrace_close.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_after_vbrace_close, 302, 0)
        self.option_nl_after_vbrace_close =  QtWidgets.QComboBox()
        self.option_nl_after_vbrace_close.addItems(['true','false'])
        self.option_nl_after_vbrace_close.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_after_vbrace_close, 302, 1)
        #--------------------------------------------
        self.label_nl_brace_struct_var = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline between the close brace and identifier,\nas in 'struct { int a; } <here> b;'. Affects enumerations, unions and\nstructures. If set to ignore, uses nl_after_brace_close.", "nl_brace_struct_var")))
        self.label_nl_brace_struct_var.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_brace_struct_var, 303, 0, 1, 2)
        self.label_option_nl_brace_struct_var = QtWidgets.QLabel("nl_brace_struct_var")
        self.label_option_nl_brace_struct_var.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_brace_struct_var, 304, 0)
        self.option_nl_brace_struct_var =  QtWidgets.QComboBox()
        self.option_nl_brace_struct_var.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_brace_struct_var.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_brace_struct_var, 304, 1)
        #--------------------------------------------
        self.label_nl_define_macro = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to alter newlines in '#define' macros.", "nl_define_macro")))
        self.label_nl_define_macro.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_define_macro, 305, 0, 1, 2)
        self.label_option_nl_define_macro = QtWidgets.QLabel("nl_define_macro")
        self.label_option_nl_define_macro.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_define_macro, 306, 0)
        self.option_nl_define_macro =  QtWidgets.QComboBox()
        self.option_nl_define_macro.addItems(['true','false'])
        self.option_nl_define_macro.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_define_macro, 306, 1)
        #--------------------------------------------
        self.label_nl_squeeze_paren_close = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to alter newlines between consecutive parenthesis closes. The number\nof closing parentheses in a line will depend on respective open parenthesis\nlines.", "nl_squeeze_paren_close")))
        self.label_nl_squeeze_paren_close.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_squeeze_paren_close, 307, 0, 1, 2)
        self.label_option_nl_squeeze_paren_close = QtWidgets.QLabel("nl_squeeze_paren_close")
        self.label_option_nl_squeeze_paren_close.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_squeeze_paren_close, 308, 0)
        self.option_nl_squeeze_paren_close =  QtWidgets.QComboBox()
        self.option_nl_squeeze_paren_close.addItems(['true','false'])
        self.option_nl_squeeze_paren_close.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_squeeze_paren_close, 308, 1)
        #--------------------------------------------
        self.label_nl_squeeze_ifdef = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to remove blanks after '#ifxx' and '#elxx', or before '#elxx' and\n'#endif'. Does not affect top-level #ifdefs.", "nl_squeeze_ifdef")))
        self.label_nl_squeeze_ifdef.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_squeeze_ifdef, 309, 0, 1, 2)
        self.label_option_nl_squeeze_ifdef = QtWidgets.QLabel("nl_squeeze_ifdef")
        self.label_option_nl_squeeze_ifdef.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_squeeze_ifdef, 310, 0)
        self.option_nl_squeeze_ifdef =  QtWidgets.QComboBox()
        self.option_nl_squeeze_ifdef.addItems(['true','false'])
        self.option_nl_squeeze_ifdef.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_squeeze_ifdef, 310, 1)
        #--------------------------------------------
        self.label_nl_squeeze_ifdef_top_level = QtWidgets.QLabel(label("<hr>"+self.tr("Makes the nl_squeeze_ifdef option affect the top-level #ifdefs as well.", "nl_squeeze_ifdef_top_level")))
        self.label_nl_squeeze_ifdef_top_level.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_squeeze_ifdef_top_level, 311, 0, 1, 2)
        self.label_option_nl_squeeze_ifdef_top_level = QtWidgets.QLabel("nl_squeeze_ifdef_top_level")
        self.label_option_nl_squeeze_ifdef_top_level.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_squeeze_ifdef_top_level, 312, 0)
        self.option_nl_squeeze_ifdef_top_level =  QtWidgets.QComboBox()
        self.option_nl_squeeze_ifdef_top_level.addItems(['true','false'])
        self.option_nl_squeeze_ifdef_top_level.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_squeeze_ifdef_top_level, 312, 1)
        #--------------------------------------------
        self.label_nl_before_if = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove blank line before 'if'.", "nl_before_if")))
        self.label_nl_before_if.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_before_if, 313, 0, 1, 2)
        self.label_option_nl_before_if = QtWidgets.QLabel("nl_before_if")
        self.label_option_nl_before_if.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_before_if, 314, 0)
        self.option_nl_before_if =  QtWidgets.QComboBox()
        self.option_nl_before_if.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_before_if.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_before_if, 314, 1)
        #--------------------------------------------
        self.label_nl_after_if = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove blank line after 'if' statement. Add/Force work only if the\nnext token is not a closing brace.", "nl_after_if")))
        self.label_nl_after_if.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_after_if, 315, 0, 1, 2)
        self.label_option_nl_after_if = QtWidgets.QLabel("nl_after_if")
        self.label_option_nl_after_if.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_after_if, 316, 0)
        self.option_nl_after_if =  QtWidgets.QComboBox()
        self.option_nl_after_if.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_after_if.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_after_if, 316, 1)
        #--------------------------------------------
        self.label_nl_before_for = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove blank line before 'for'.", "nl_before_for")))
        self.label_nl_before_for.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_before_for, 317, 0, 1, 2)
        self.label_option_nl_before_for = QtWidgets.QLabel("nl_before_for")
        self.label_option_nl_before_for.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_before_for, 318, 0)
        self.option_nl_before_for =  QtWidgets.QComboBox()
        self.option_nl_before_for.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_before_for.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_before_for, 318, 1)
        #--------------------------------------------
        self.label_nl_after_for = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove blank line after 'for' statement.", "nl_after_for")))
        self.label_nl_after_for.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_after_for, 319, 0, 1, 2)
        self.label_option_nl_after_for = QtWidgets.QLabel("nl_after_for")
        self.label_option_nl_after_for.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_after_for, 320, 0)
        self.option_nl_after_for =  QtWidgets.QComboBox()
        self.option_nl_after_for.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_after_for.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_after_for, 320, 1)
        #--------------------------------------------
        self.label_nl_before_while = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove blank line before 'while'.", "nl_before_while")))
        self.label_nl_before_while.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_before_while, 321, 0, 1, 2)
        self.label_option_nl_before_while = QtWidgets.QLabel("nl_before_while")
        self.label_option_nl_before_while.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_before_while, 322, 0)
        self.option_nl_before_while =  QtWidgets.QComboBox()
        self.option_nl_before_while.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_before_while.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_before_while, 322, 1)
        #--------------------------------------------
        self.label_nl_after_while = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove blank line after 'while' statement.", "nl_after_while")))
        self.label_nl_after_while.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_after_while, 323, 0, 1, 2)
        self.label_option_nl_after_while = QtWidgets.QLabel("nl_after_while")
        self.label_option_nl_after_while.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_after_while, 324, 0)
        self.option_nl_after_while =  QtWidgets.QComboBox()
        self.option_nl_after_while.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_after_while.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_after_while, 324, 1)
        #--------------------------------------------
        self.label_nl_before_switch = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove blank line before 'switch'.", "nl_before_switch")))
        self.label_nl_before_switch.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_before_switch, 325, 0, 1, 2)
        self.label_option_nl_before_switch = QtWidgets.QLabel("nl_before_switch")
        self.label_option_nl_before_switch.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_before_switch, 326, 0)
        self.option_nl_before_switch =  QtWidgets.QComboBox()
        self.option_nl_before_switch.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_before_switch.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_before_switch, 326, 1)
        #--------------------------------------------
        self.label_nl_after_switch = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove blank line after 'switch' statement.", "nl_after_switch")))
        self.label_nl_after_switch.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_after_switch, 327, 0, 1, 2)
        self.label_option_nl_after_switch = QtWidgets.QLabel("nl_after_switch")
        self.label_option_nl_after_switch.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_after_switch, 328, 0)
        self.option_nl_after_switch =  QtWidgets.QComboBox()
        self.option_nl_after_switch.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_after_switch.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_after_switch, 328, 1)
        #--------------------------------------------
        self.label_nl_before_synchronized = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove blank line before 'synchronized'.", "nl_before_synchronized")))
        self.label_nl_before_synchronized.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_before_synchronized, 329, 0, 1, 2)
        self.label_option_nl_before_synchronized = QtWidgets.QLabel("nl_before_synchronized")
        self.label_option_nl_before_synchronized.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_before_synchronized, 330, 0)
        self.option_nl_before_synchronized =  QtWidgets.QComboBox()
        self.option_nl_before_synchronized.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_before_synchronized.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_before_synchronized, 330, 1)
        #--------------------------------------------
        self.label_nl_after_synchronized = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove blank line after 'synchronized' statement.", "nl_after_synchronized")))
        self.label_nl_after_synchronized.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_after_synchronized, 331, 0, 1, 2)
        self.label_option_nl_after_synchronized = QtWidgets.QLabel("nl_after_synchronized")
        self.label_option_nl_after_synchronized.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_after_synchronized, 332, 0)
        self.option_nl_after_synchronized =  QtWidgets.QComboBox()
        self.option_nl_after_synchronized.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_after_synchronized.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_after_synchronized, 332, 1)
        #--------------------------------------------
        self.label_nl_before_do = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove blank line before 'do'.", "nl_before_do")))
        self.label_nl_before_do.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_before_do, 333, 0, 1, 2)
        self.label_option_nl_before_do = QtWidgets.QLabel("nl_before_do")
        self.label_option_nl_before_do.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_before_do, 334, 0)
        self.option_nl_before_do =  QtWidgets.QComboBox()
        self.option_nl_before_do.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_before_do.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_before_do, 334, 1)
        #--------------------------------------------
        self.label_nl_after_do = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove blank line after 'do/while' statement.", "nl_after_do")))
        self.label_nl_after_do.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_after_do, 335, 0, 1, 2)
        self.label_option_nl_after_do = QtWidgets.QLabel("nl_after_do")
        self.label_option_nl_after_do.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_after_do, 336, 0)
        self.option_nl_after_do =  QtWidgets.QComboBox()
        self.option_nl_after_do.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_after_do.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_after_do, 336, 1)
        #--------------------------------------------
        self.label_nl_before_ignore_after_case = QtWidgets.QLabel(label("<hr>"+self.tr("Ignore nl_before_{if,for,switch,do,synchronized} if the control\nstatement is immediately after a case statement.\nif nl_before_{if,for,switch,do} is set to remove, this option\ndoes nothing.", "nl_before_ignore_after_case")))
        self.label_nl_before_ignore_after_case.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_before_ignore_after_case, 337, 0, 1, 2)
        self.label_option_nl_before_ignore_after_case = QtWidgets.QLabel("nl_before_ignore_after_case")
        self.label_option_nl_before_ignore_after_case.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_before_ignore_after_case, 338, 0)
        self.option_nl_before_ignore_after_case =  QtWidgets.QComboBox()
        self.option_nl_before_ignore_after_case.addItems(['true','false'])
        self.option_nl_before_ignore_after_case.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_before_ignore_after_case, 338, 1)
        #--------------------------------------------
        self.label_nl_before_return = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to put a blank line before 'return' statements, unless after an open\nbrace.", "nl_before_return")))
        self.label_nl_before_return.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_before_return, 339, 0, 1, 2)
        self.label_option_nl_before_return = QtWidgets.QLabel("nl_before_return")
        self.label_option_nl_before_return.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_before_return, 340, 0)
        self.option_nl_before_return =  QtWidgets.QComboBox()
        self.option_nl_before_return.addItems(['true','false'])
        self.option_nl_before_return.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_before_return, 340, 1)
        #--------------------------------------------
        self.label_nl_after_return = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to put a blank line after 'return' statements, unless followed by a\nclose brace.", "nl_after_return")))
        self.label_nl_after_return.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_after_return, 341, 0, 1, 2)
        self.label_option_nl_after_return = QtWidgets.QLabel("nl_after_return")
        self.label_option_nl_after_return.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_after_return, 342, 0)
        self.option_nl_after_return =  QtWidgets.QComboBox()
        self.option_nl_after_return.addItems(['true','false'])
        self.option_nl_after_return.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_after_return, 342, 1)
        #--------------------------------------------
        self.label_nl_before_member = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to put a blank line before a member '.' or '->' operators.", "nl_before_member")))
        self.label_nl_before_member.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_before_member, 343, 0, 1, 2)
        self.label_option_nl_before_member = QtWidgets.QLabel("nl_before_member")
        self.label_option_nl_before_member.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_before_member, 344, 0)
        self.option_nl_before_member =  QtWidgets.QComboBox()
        self.option_nl_before_member.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_before_member.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_before_member, 344, 1)
        #--------------------------------------------
        self.label_nl_after_member = QtWidgets.QLabel(label("<hr>"+self.tr("(Java) Whether to put a blank line after a member '.' or '->' operators.", "nl_after_member")))
        self.label_nl_after_member.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_after_member, 345, 0, 1, 2)
        self.label_option_nl_after_member = QtWidgets.QLabel("nl_after_member")
        self.label_option_nl_after_member.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_after_member, 346, 0)
        self.option_nl_after_member =  QtWidgets.QComboBox()
        self.option_nl_after_member.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_after_member.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_after_member, 346, 1)
        #--------------------------------------------
        self.label_nl_ds_struct_enum_cmt = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to double-space commented-entries in 'struct'/'union'/'enum'.", "nl_ds_struct_enum_cmt")))
        self.label_nl_ds_struct_enum_cmt.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_ds_struct_enum_cmt, 347, 0, 1, 2)
        self.label_option_nl_ds_struct_enum_cmt = QtWidgets.QLabel("nl_ds_struct_enum_cmt")
        self.label_option_nl_ds_struct_enum_cmt.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_ds_struct_enum_cmt, 348, 0)
        self.option_nl_ds_struct_enum_cmt =  QtWidgets.QComboBox()
        self.option_nl_ds_struct_enum_cmt.addItems(['true','false'])
        self.option_nl_ds_struct_enum_cmt.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_ds_struct_enum_cmt, 348, 1)
        #--------------------------------------------
        self.label_nl_ds_struct_enum_close_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to force a newline before '}' of a 'struct'/'union'/'enum'.\n(Lower priority than eat_blanks_before_close_brace.)", "nl_ds_struct_enum_close_brace")))
        self.label_nl_ds_struct_enum_close_brace.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_ds_struct_enum_close_brace, 349, 0, 1, 2)
        self.label_option_nl_ds_struct_enum_close_brace = QtWidgets.QLabel("nl_ds_struct_enum_close_brace")
        self.label_option_nl_ds_struct_enum_close_brace.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_ds_struct_enum_close_brace, 350, 0)
        self.option_nl_ds_struct_enum_close_brace =  QtWidgets.QComboBox()
        self.option_nl_ds_struct_enum_close_brace.addItems(['true','false'])
        self.option_nl_ds_struct_enum_close_brace.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_ds_struct_enum_close_brace, 350, 1)
        #--------------------------------------------
        self.label_nl_class_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline before or after (depending on pos_class_colon) a class\ncolon, as in 'class Foo <here> : <or here> public Bar'.", "nl_class_colon")))
        self.label_nl_class_colon.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_class_colon, 351, 0, 1, 2)
        self.label_option_nl_class_colon = QtWidgets.QLabel("nl_class_colon")
        self.label_option_nl_class_colon.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_class_colon, 352, 0)
        self.option_nl_class_colon =  QtWidgets.QComboBox()
        self.option_nl_class_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_class_colon.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_class_colon, 352, 1)
        #--------------------------------------------
        self.label_nl_constr_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove newline around a class constructor colon. The exact position\ndepends on nl_constr_init_args, pos_constr_colon and pos_constr_comma.", "nl_constr_colon")))
        self.label_nl_constr_colon.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_constr_colon, 353, 0, 1, 2)
        self.label_option_nl_constr_colon = QtWidgets.QLabel("nl_constr_colon")
        self.label_option_nl_constr_colon.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_constr_colon, 354, 0)
        self.option_nl_constr_colon =  QtWidgets.QComboBox()
        self.option_nl_constr_colon.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_constr_colon.setCurrentText("ignore")
        self.group_page_layout_4.addWidget(self.option_nl_constr_colon, 354, 1)
        #--------------------------------------------
        self.label_nl_namespace_two_to_one_liner = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to collapse a two-line namespace, like 'namespace foo\\n{ decl; }'\ninto a single line. If true, prevents other brace newline rules from turning\nsuch code into four lines. If true, it also preserves one-liner namespaces.", "nl_namespace_two_to_one_liner")))
        self.label_nl_namespace_two_to_one_liner.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_namespace_two_to_one_liner, 355, 0, 1, 2)
        self.label_option_nl_namespace_two_to_one_liner = QtWidgets.QLabel("nl_namespace_two_to_one_liner")
        self.label_option_nl_namespace_two_to_one_liner.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_namespace_two_to_one_liner, 356, 0)
        self.option_nl_namespace_two_to_one_liner =  QtWidgets.QComboBox()
        self.option_nl_namespace_two_to_one_liner.addItems(['true','false'])
        self.option_nl_namespace_two_to_one_liner.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_namespace_two_to_one_liner, 356, 1)
        #--------------------------------------------
        self.label_nl_create_if_one_liner = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to remove a newline in simple unbraced if statements, turning them\ninto one-liners, as in 'if(b)\\n i++;' => 'if(b) i++;'.", "nl_create_if_one_liner")))
        self.label_nl_create_if_one_liner.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_create_if_one_liner, 357, 0, 1, 2)
        self.label_option_nl_create_if_one_liner = QtWidgets.QLabel("nl_create_if_one_liner")
        self.label_option_nl_create_if_one_liner.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_create_if_one_liner, 358, 0)
        self.option_nl_create_if_one_liner =  QtWidgets.QComboBox()
        self.option_nl_create_if_one_liner.addItems(['true','false'])
        self.option_nl_create_if_one_liner.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_create_if_one_liner, 358, 1)
        #--------------------------------------------
        self.label_nl_create_for_one_liner = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to remove a newline in simple unbraced for statements, turning them\ninto one-liners, as in 'for (...)\\n stmt;' => 'for (...) stmt;'.", "nl_create_for_one_liner")))
        self.label_nl_create_for_one_liner.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_create_for_one_liner, 359, 0, 1, 2)
        self.label_option_nl_create_for_one_liner = QtWidgets.QLabel("nl_create_for_one_liner")
        self.label_option_nl_create_for_one_liner.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_create_for_one_liner, 360, 0)
        self.option_nl_create_for_one_liner =  QtWidgets.QComboBox()
        self.option_nl_create_for_one_liner.addItems(['true','false'])
        self.option_nl_create_for_one_liner.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_create_for_one_liner, 360, 1)
        #--------------------------------------------
        self.label_nl_create_while_one_liner = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to remove a newline in simple unbraced while statements, turning\nthem into one-liners, as in 'while (expr)\\n stmt;' => 'while (expr) stmt;'.", "nl_create_while_one_liner")))
        self.label_nl_create_while_one_liner.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_create_while_one_liner, 361, 0, 1, 2)
        self.label_option_nl_create_while_one_liner = QtWidgets.QLabel("nl_create_while_one_liner")
        self.label_option_nl_create_while_one_liner.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_create_while_one_liner, 362, 0)
        self.option_nl_create_while_one_liner =  QtWidgets.QComboBox()
        self.option_nl_create_while_one_liner.addItems(['true','false'])
        self.option_nl_create_while_one_liner.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_create_while_one_liner, 362, 1)
        #--------------------------------------------
        self.label_nl_create_func_def_one_liner = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to collapse a function definition whose body (not counting braces)\nis only one line so that the entire definition (prototype, braces, body) is\na single line.", "nl_create_func_def_one_liner")))
        self.label_nl_create_func_def_one_liner.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_create_func_def_one_liner, 363, 0, 1, 2)
        self.label_option_nl_create_func_def_one_liner = QtWidgets.QLabel("nl_create_func_def_one_liner")
        self.label_option_nl_create_func_def_one_liner.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_create_func_def_one_liner, 364, 0)
        self.option_nl_create_func_def_one_liner =  QtWidgets.QComboBox()
        self.option_nl_create_func_def_one_liner.addItems(['true','false'])
        self.option_nl_create_func_def_one_liner.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_create_func_def_one_liner, 364, 1)
        #--------------------------------------------
        self.label_nl_create_list_one_liner = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to split one-line simple list definitions into three lines by\nadding newlines, as in 'int a[12] = { <here> 0 <here> };'.", "nl_create_list_one_liner")))
        self.label_nl_create_list_one_liner.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_create_list_one_liner, 365, 0, 1, 2)
        self.label_option_nl_create_list_one_liner = QtWidgets.QLabel("nl_create_list_one_liner")
        self.label_option_nl_create_list_one_liner.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_create_list_one_liner, 366, 0)
        self.option_nl_create_list_one_liner =  QtWidgets.QComboBox()
        self.option_nl_create_list_one_liner.addItems(['true','false'])
        self.option_nl_create_list_one_liner.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_create_list_one_liner, 366, 1)
        #--------------------------------------------
        self.label_nl_split_if_one_liner = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to split one-line simple unbraced if statements into two lines by\nadding a newline, as in 'if(b) <here> i++;'.", "nl_split_if_one_liner")))
        self.label_nl_split_if_one_liner.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_split_if_one_liner, 367, 0, 1, 2)
        self.label_option_nl_split_if_one_liner = QtWidgets.QLabel("nl_split_if_one_liner")
        self.label_option_nl_split_if_one_liner.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_split_if_one_liner, 368, 0)
        self.option_nl_split_if_one_liner =  QtWidgets.QComboBox()
        self.option_nl_split_if_one_liner.addItems(['true','false'])
        self.option_nl_split_if_one_liner.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_split_if_one_liner, 368, 1)
        #--------------------------------------------
        self.label_nl_split_for_one_liner = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to split one-line simple unbraced for statements into two lines by\nadding a newline, as in 'for (...) <here> stmt;'.", "nl_split_for_one_liner")))
        self.label_nl_split_for_one_liner.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_split_for_one_liner, 369, 0, 1, 2)
        self.label_option_nl_split_for_one_liner = QtWidgets.QLabel("nl_split_for_one_liner")
        self.label_option_nl_split_for_one_liner.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_split_for_one_liner, 370, 0)
        self.option_nl_split_for_one_liner =  QtWidgets.QComboBox()
        self.option_nl_split_for_one_liner.addItems(['true','false'])
        self.option_nl_split_for_one_liner.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_split_for_one_liner, 370, 1)
        #--------------------------------------------
        self.label_nl_split_while_one_liner = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to split one-line simple unbraced while statements into two lines by\nadding a newline, as in 'while (expr) <here> stmt;'.", "nl_split_while_one_liner")))
        self.label_nl_split_while_one_liner.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_nl_split_while_one_liner, 371, 0, 1, 2)
        self.label_option_nl_split_while_one_liner = QtWidgets.QLabel("nl_split_while_one_liner")
        self.label_option_nl_split_while_one_liner.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_nl_split_while_one_liner, 372, 0)
        self.option_nl_split_while_one_liner =  QtWidgets.QComboBox()
        self.option_nl_split_while_one_liner.addItems(['true','false'])
        self.option_nl_split_while_one_liner.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_nl_split_while_one_liner, 372, 1)
        #--------------------------------------------
        self.label_donot_add_nl_before_cpp_comment = QtWidgets.QLabel(label("<hr>"+self.tr("Don't add a newline before a cpp-comment in a parameter list of a function\ncall.", "donot_add_nl_before_cpp_comment")))
        self.label_donot_add_nl_before_cpp_comment.setWordWrap(True)
        self.group_page_layout_4.addWidget(self.label_donot_add_nl_before_cpp_comment, 373, 0, 1, 2)
        self.label_option_donot_add_nl_before_cpp_comment = QtWidgets.QLabel("donot_add_nl_before_cpp_comment")
        self.label_option_donot_add_nl_before_cpp_comment.setFont(font_name)
        self.group_page_layout_4.addWidget(self.label_option_donot_add_nl_before_cpp_comment, 374, 0)
        self.option_donot_add_nl_before_cpp_comment =  QtWidgets.QComboBox()
        self.option_donot_add_nl_before_cpp_comment.addItems(['true','false'])
        self.option_donot_add_nl_before_cpp_comment.setCurrentText("false")
        self.group_page_layout_4.addWidget(self.option_donot_add_nl_before_cpp_comment, 374, 1)
        self.group_page_layout_4.addItem(QtWidgets.QSpacerItem(10, 10, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding), 375,0)
        self.scroll_group_page_4 = QtWidgets.QScrollArea()
        self.scroll_group_page_4.setWidget(self.group_page_4)
        self.scroll_group_page_4.setWidgetResizable(True)
        self.addTab(self.scroll_group_page_4, self.tr("Newline adding and removing options"))
        #================== Blank line options ==============================================================
        self.group_page_5 = QtWidgets.QWidget()
        self.group_page_layout_5 = QtWidgets.QGridLayout(self.group_page_5)
        self.group_page_layout_5.addWidget(QtWidgets.QLabel(label(self.tr("Blank line options help"))), 0, 0, 1, 2)
        #--------------------------------------------
        self.label_nl_max = QtWidgets.QLabel(label("<hr>"+self.tr("The maximum number of consecutive newlines (3 = 2 blank lines).", "nl_max")))
        self.label_nl_max.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_max, 1, 0, 1, 2)
        self.label_option_nl_max = QtWidgets.QLabel("nl_max")
        self.label_option_nl_max.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_max, 2, 0)
        self.option_nl_max =  QtWidgets.QSpinBox()
        self.option_nl_max.setMinimum( 0)
        self.option_nl_max.setMaximum( 16)
        self.option_nl_max.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_max, 2, 1)
        #--------------------------------------------
        self.label_nl_max_blank_in_func = QtWidgets.QLabel(label("<hr>"+self.tr("The maximum number of consecutive newlines in a function.", "nl_max_blank_in_func")))
        self.label_nl_max_blank_in_func.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_max_blank_in_func, 3, 0, 1, 2)
        self.label_option_nl_max_blank_in_func = QtWidgets.QLabel("nl_max_blank_in_func")
        self.label_option_nl_max_blank_in_func.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_max_blank_in_func, 4, 0)
        self.option_nl_max_blank_in_func =  QtWidgets.QSpinBox()
        self.option_nl_max_blank_in_func.setMinimum( 0)
        self.option_nl_max_blank_in_func.setMaximum( 16)
        self.option_nl_max_blank_in_func.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_max_blank_in_func, 4, 1)
        #--------------------------------------------
        self.label_nl_inside_empty_func = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines inside an empty function body.\nThis option overrides eat_blanks_after_open_brace and\neat_blanks_before_close_brace, but is ignored when\nnl_collapse_empty_body_functions=true", "nl_inside_empty_func")))
        self.label_nl_inside_empty_func.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_inside_empty_func, 5, 0, 1, 2)
        self.label_option_nl_inside_empty_func = QtWidgets.QLabel("nl_inside_empty_func")
        self.label_option_nl_inside_empty_func.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_inside_empty_func, 6, 0)
        self.option_nl_inside_empty_func =  QtWidgets.QSpinBox()
        self.option_nl_inside_empty_func.setMinimum( 0)
        self.option_nl_inside_empty_func.setMaximum( 16)
        self.option_nl_inside_empty_func.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_inside_empty_func, 6, 1)
        #--------------------------------------------
        self.label_nl_before_func_body_proto = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines before a function prototype.", "nl_before_func_body_proto")))
        self.label_nl_before_func_body_proto.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_before_func_body_proto, 7, 0, 1, 2)
        self.label_option_nl_before_func_body_proto = QtWidgets.QLabel("nl_before_func_body_proto")
        self.label_option_nl_before_func_body_proto.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_before_func_body_proto, 8, 0)
        self.option_nl_before_func_body_proto =  QtWidgets.QSpinBox()
        self.option_nl_before_func_body_proto.setMinimum( 0)
        self.option_nl_before_func_body_proto.setMaximum( 16)
        self.option_nl_before_func_body_proto.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_before_func_body_proto, 8, 1)
        #--------------------------------------------
        self.label_nl_before_func_body_def = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines before a multi-line function definition. Where\napplicable, this option is overridden with eat_blanks_after_open_brace=true", "nl_before_func_body_def")))
        self.label_nl_before_func_body_def.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_before_func_body_def, 9, 0, 1, 2)
        self.label_option_nl_before_func_body_def = QtWidgets.QLabel("nl_before_func_body_def")
        self.label_option_nl_before_func_body_def.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_before_func_body_def, 10, 0)
        self.option_nl_before_func_body_def =  QtWidgets.QSpinBox()
        self.option_nl_before_func_body_def.setMinimum( 0)
        self.option_nl_before_func_body_def.setMaximum( 16)
        self.option_nl_before_func_body_def.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_before_func_body_def, 10, 1)
        #--------------------------------------------
        self.label_nl_before_func_class_proto = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines before a class constructor/destructor prototype.", "nl_before_func_class_proto")))
        self.label_nl_before_func_class_proto.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_before_func_class_proto, 11, 0, 1, 2)
        self.label_option_nl_before_func_class_proto = QtWidgets.QLabel("nl_before_func_class_proto")
        self.label_option_nl_before_func_class_proto.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_before_func_class_proto, 12, 0)
        self.option_nl_before_func_class_proto =  QtWidgets.QSpinBox()
        self.option_nl_before_func_class_proto.setMinimum( 0)
        self.option_nl_before_func_class_proto.setMaximum( 16)
        self.option_nl_before_func_class_proto.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_before_func_class_proto, 12, 1)
        #--------------------------------------------
        self.label_nl_before_func_class_def = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines before a class constructor/destructor definition.", "nl_before_func_class_def")))
        self.label_nl_before_func_class_def.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_before_func_class_def, 13, 0, 1, 2)
        self.label_option_nl_before_func_class_def = QtWidgets.QLabel("nl_before_func_class_def")
        self.label_option_nl_before_func_class_def.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_before_func_class_def, 14, 0)
        self.option_nl_before_func_class_def =  QtWidgets.QSpinBox()
        self.option_nl_before_func_class_def.setMinimum( 0)
        self.option_nl_before_func_class_def.setMaximum( 16)
        self.option_nl_before_func_class_def.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_before_func_class_def, 14, 1)
        #--------------------------------------------
        self.label_nl_after_func_proto = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines after a function prototype.", "nl_after_func_proto")))
        self.label_nl_after_func_proto.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_after_func_proto, 15, 0, 1, 2)
        self.label_option_nl_after_func_proto = QtWidgets.QLabel("nl_after_func_proto")
        self.label_option_nl_after_func_proto.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_after_func_proto, 16, 0)
        self.option_nl_after_func_proto =  QtWidgets.QSpinBox()
        self.option_nl_after_func_proto.setMinimum( 0)
        self.option_nl_after_func_proto.setMaximum( 16)
        self.option_nl_after_func_proto.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_after_func_proto, 16, 1)
        #--------------------------------------------
        self.label_nl_after_func_proto_group = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines after a function prototype, if not followed by\nanother function prototype.", "nl_after_func_proto_group")))
        self.label_nl_after_func_proto_group.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_after_func_proto_group, 17, 0, 1, 2)
        self.label_option_nl_after_func_proto_group = QtWidgets.QLabel("nl_after_func_proto_group")
        self.label_option_nl_after_func_proto_group.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_after_func_proto_group, 18, 0)
        self.option_nl_after_func_proto_group =  QtWidgets.QSpinBox()
        self.option_nl_after_func_proto_group.setMinimum( 0)
        self.option_nl_after_func_proto_group.setMaximum( 16)
        self.option_nl_after_func_proto_group.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_after_func_proto_group, 18, 1)
        #--------------------------------------------
        self.label_nl_after_func_class_proto = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines after a class constructor/destructor prototype.", "nl_after_func_class_proto")))
        self.label_nl_after_func_class_proto.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_after_func_class_proto, 19, 0, 1, 2)
        self.label_option_nl_after_func_class_proto = QtWidgets.QLabel("nl_after_func_class_proto")
        self.label_option_nl_after_func_class_proto.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_after_func_class_proto, 20, 0)
        self.option_nl_after_func_class_proto =  QtWidgets.QSpinBox()
        self.option_nl_after_func_class_proto.setMinimum( 0)
        self.option_nl_after_func_class_proto.setMaximum( 16)
        self.option_nl_after_func_class_proto.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_after_func_class_proto, 20, 1)
        #--------------------------------------------
        self.label_nl_after_func_class_proto_group = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines after a class constructor/destructor prototype,\nif not followed by another constructor/destructor prototype.", "nl_after_func_class_proto_group")))
        self.label_nl_after_func_class_proto_group.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_after_func_class_proto_group, 21, 0, 1, 2)
        self.label_option_nl_after_func_class_proto_group = QtWidgets.QLabel("nl_after_func_class_proto_group")
        self.label_option_nl_after_func_class_proto_group.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_after_func_class_proto_group, 22, 0)
        self.option_nl_after_func_class_proto_group =  QtWidgets.QSpinBox()
        self.option_nl_after_func_class_proto_group.setMinimum( 0)
        self.option_nl_after_func_class_proto_group.setMaximum( 16)
        self.option_nl_after_func_class_proto_group.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_after_func_class_proto_group, 22, 1)
        #--------------------------------------------
        self.label_nl_class_leave_one_liner_groups = QtWidgets.QLabel(label("<hr>"+self.tr("Whether one-line method definitions inside a class body should be treated\nas if they were prototypes for the purposes of adding newlines.", "nl_class_leave_one_liner_groups")+"\n\n"+self.tr("Requires nl_class_leave_one_liners=true. Overrides nl_before_func_body_def\nand nl_before_func_class_def for one-liners.", "nl_class_leave_one_liner_groups")))
        self.label_nl_class_leave_one_liner_groups.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_class_leave_one_liner_groups, 23, 0, 1, 2)
        self.label_option_nl_class_leave_one_liner_groups = QtWidgets.QLabel("nl_class_leave_one_liner_groups")
        self.label_option_nl_class_leave_one_liner_groups.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_class_leave_one_liner_groups, 24, 0)
        self.option_nl_class_leave_one_liner_groups =  QtWidgets.QComboBox()
        self.option_nl_class_leave_one_liner_groups.addItems(['true','false'])
        self.option_nl_class_leave_one_liner_groups.setCurrentText("false")
        self.group_page_layout_5.addWidget(self.option_nl_class_leave_one_liner_groups, 24, 1)
        #--------------------------------------------
        self.label_nl_after_func_body = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines after '}' of a multi-line function body.", "nl_after_func_body")+"\n\n"+self.tr("Overrides nl_min_after_func_body and nl_max_after_func_body.", "nl_after_func_body")))
        self.label_nl_after_func_body.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_after_func_body, 25, 0, 1, 2)
        self.label_option_nl_after_func_body = QtWidgets.QLabel("nl_after_func_body")
        self.label_option_nl_after_func_body.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_after_func_body, 26, 0)
        self.option_nl_after_func_body =  QtWidgets.QSpinBox()
        self.option_nl_after_func_body.setMinimum( 0)
        self.option_nl_after_func_body.setMaximum( 16)
        self.option_nl_after_func_body.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_after_func_body, 26, 1)
        #--------------------------------------------
        self.label_nl_min_after_func_body = QtWidgets.QLabel(label("<hr>"+self.tr("The minimum number of newlines after '}' of a multi-line function body.", "nl_min_after_func_body")+"\n\n"+self.tr("Only works when nl_after_func_body is 0.", "nl_min_after_func_body")))
        self.label_nl_min_after_func_body.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_min_after_func_body, 27, 0, 1, 2)
        self.label_option_nl_min_after_func_body = QtWidgets.QLabel("nl_min_after_func_body")
        self.label_option_nl_min_after_func_body.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_min_after_func_body, 28, 0)
        self.option_nl_min_after_func_body =  QtWidgets.QSpinBox()
        self.option_nl_min_after_func_body.setMinimum( 0)
        self.option_nl_min_after_func_body.setMaximum( 16)
        self.option_nl_min_after_func_body.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_min_after_func_body, 28, 1)
        #--------------------------------------------
        self.label_nl_max_after_func_body = QtWidgets.QLabel(label("<hr>"+self.tr("The maximum number of newlines after '}' of a multi-line function body.", "nl_max_after_func_body")+"\n\n"+self.tr("Only works when nl_after_func_body is 0.\nTakes precedence over nl_min_after_func_body.", "nl_max_after_func_body")))
        self.label_nl_max_after_func_body.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_max_after_func_body, 29, 0, 1, 2)
        self.label_option_nl_max_after_func_body = QtWidgets.QLabel("nl_max_after_func_body")
        self.label_option_nl_max_after_func_body.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_max_after_func_body, 30, 0)
        self.option_nl_max_after_func_body =  QtWidgets.QSpinBox()
        self.option_nl_max_after_func_body.setMinimum( 0)
        self.option_nl_max_after_func_body.setMaximum( 16)
        self.option_nl_max_after_func_body.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_max_after_func_body, 30, 1)
        #--------------------------------------------
        self.label_nl_after_func_body_class = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines after '}' of a multi-line function body in a class\ndeclaration. Also affects class constructors/destructors.", "nl_after_func_body_class")+"\n\n"+self.tr("Overrides nl_after_func_body.", "nl_after_func_body_class")))
        self.label_nl_after_func_body_class.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_after_func_body_class, 31, 0, 1, 2)
        self.label_option_nl_after_func_body_class = QtWidgets.QLabel("nl_after_func_body_class")
        self.label_option_nl_after_func_body_class.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_after_func_body_class, 32, 0)
        self.option_nl_after_func_body_class =  QtWidgets.QSpinBox()
        self.option_nl_after_func_body_class.setMinimum( 0)
        self.option_nl_after_func_body_class.setMaximum( 16)
        self.option_nl_after_func_body_class.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_after_func_body_class, 32, 1)
        #--------------------------------------------
        self.label_nl_after_func_body_one_liner = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines after '}' of a single line function body. Also\naffects class constructors/destructors.", "nl_after_func_body_one_liner")+"\n\n"+self.tr("Overrides nl_after_func_body and nl_after_func_body_class.", "nl_after_func_body_one_liner")))
        self.label_nl_after_func_body_one_liner.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_after_func_body_one_liner, 33, 0, 1, 2)
        self.label_option_nl_after_func_body_one_liner = QtWidgets.QLabel("nl_after_func_body_one_liner")
        self.label_option_nl_after_func_body_one_liner.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_after_func_body_one_liner, 34, 0)
        self.option_nl_after_func_body_one_liner =  QtWidgets.QSpinBox()
        self.option_nl_after_func_body_one_liner.setMinimum( 0)
        self.option_nl_after_func_body_one_liner.setMaximum( 16)
        self.option_nl_after_func_body_one_liner.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_after_func_body_one_liner, 34, 1)
        #--------------------------------------------
        self.label_nl_typedef_blk_start = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines before a block of typedefs. If nl_after_access_spec\nis non-zero, that option takes precedence.", "nl_typedef_blk_start")+"\n\n"+self.tr("0: No change (default).", "nl_typedef_blk_start")))
        self.label_nl_typedef_blk_start.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_typedef_blk_start, 35, 0, 1, 2)
        self.label_option_nl_typedef_blk_start = QtWidgets.QLabel("nl_typedef_blk_start")
        self.label_option_nl_typedef_blk_start.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_typedef_blk_start, 36, 0)
        self.option_nl_typedef_blk_start =  QtWidgets.QSpinBox()
        self.option_nl_typedef_blk_start.setMinimum( 0)
        self.option_nl_typedef_blk_start.setMaximum( 16)
        self.option_nl_typedef_blk_start.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_typedef_blk_start, 36, 1)
        #--------------------------------------------
        self.label_nl_typedef_blk_end = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines after a block of typedefs.", "nl_typedef_blk_end")+"\n\n"+self.tr("0: No change (default).", "nl_typedef_blk_end")))
        self.label_nl_typedef_blk_end.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_typedef_blk_end, 37, 0, 1, 2)
        self.label_option_nl_typedef_blk_end = QtWidgets.QLabel("nl_typedef_blk_end")
        self.label_option_nl_typedef_blk_end.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_typedef_blk_end, 38, 0)
        self.option_nl_typedef_blk_end =  QtWidgets.QSpinBox()
        self.option_nl_typedef_blk_end.setMinimum( 0)
        self.option_nl_typedef_blk_end.setMaximum( 16)
        self.option_nl_typedef_blk_end.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_typedef_blk_end, 38, 1)
        #--------------------------------------------
        self.label_nl_typedef_blk_in = QtWidgets.QLabel(label("<hr>"+self.tr("The maximum number of consecutive newlines within a block of typedefs.", "nl_typedef_blk_in")+"\n\n"+self.tr("0: No change (default).", "nl_typedef_blk_in")))
        self.label_nl_typedef_blk_in.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_typedef_blk_in, 39, 0, 1, 2)
        self.label_option_nl_typedef_blk_in = QtWidgets.QLabel("nl_typedef_blk_in")
        self.label_option_nl_typedef_blk_in.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_typedef_blk_in, 40, 0)
        self.option_nl_typedef_blk_in =  QtWidgets.QSpinBox()
        self.option_nl_typedef_blk_in.setMinimum( 0)
        self.option_nl_typedef_blk_in.setMaximum( 16)
        self.option_nl_typedef_blk_in.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_typedef_blk_in, 40, 1)
        #--------------------------------------------
        self.label_nl_var_def_blk_end_func_top = QtWidgets.QLabel(label("<hr>"+self.tr("The minimum number of blank lines after a block of variable definitions\nat the top of a function body. If any preprocessor directives appear\nbetween the opening brace of the function and the variable block, then\nit is considered as not at the top of the function.Newlines are added\nbefore trailing preprocessor directives, if any exist.", "nl_var_def_blk_end_func_top")+"\n\n"+self.tr("0: No change (default).", "nl_var_def_blk_end_func_top")))
        self.label_nl_var_def_blk_end_func_top.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_var_def_blk_end_func_top, 41, 0, 1, 2)
        self.label_option_nl_var_def_blk_end_func_top = QtWidgets.QLabel("nl_var_def_blk_end_func_top")
        self.label_option_nl_var_def_blk_end_func_top.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_var_def_blk_end_func_top, 42, 0)
        self.option_nl_var_def_blk_end_func_top =  QtWidgets.QSpinBox()
        self.option_nl_var_def_blk_end_func_top.setMinimum( 0)
        self.option_nl_var_def_blk_end_func_top.setMaximum( 16)
        self.option_nl_var_def_blk_end_func_top.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_var_def_blk_end_func_top, 42, 1)
        #--------------------------------------------
        self.label_nl_var_def_blk_start = QtWidgets.QLabel(label("<hr>"+self.tr("The minimum number of empty newlines before a block of variable definitions\nnot at the top of a function body. If nl_after_access_spec is non-zero,\nthat option takes precedence. Newlines are not added at the top of the\nfile or just after an opening brace. Newlines are added above any\npreprocessor directives before the block.", "nl_var_def_blk_start")+"\n\n"+self.tr("0: No change (default).", "nl_var_def_blk_start")))
        self.label_nl_var_def_blk_start.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_var_def_blk_start, 43, 0, 1, 2)
        self.label_option_nl_var_def_blk_start = QtWidgets.QLabel("nl_var_def_blk_start")
        self.label_option_nl_var_def_blk_start.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_var_def_blk_start, 44, 0)
        self.option_nl_var_def_blk_start =  QtWidgets.QSpinBox()
        self.option_nl_var_def_blk_start.setMinimum( 0)
        self.option_nl_var_def_blk_start.setMaximum( 16)
        self.option_nl_var_def_blk_start.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_var_def_blk_start, 44, 1)
        #--------------------------------------------
        self.label_nl_var_def_blk_end = QtWidgets.QLabel(label("<hr>"+self.tr("The minimum number of empty newlines after a block of variable definitions\nnot at the top of a function body. Newlines are not added if the block\nis at the bottom of the file or just before a preprocessor directive.", "nl_var_def_blk_end")+"\n\n"+self.tr("0: No change (default).", "nl_var_def_blk_end")))
        self.label_nl_var_def_blk_end.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_var_def_blk_end, 45, 0, 1, 2)
        self.label_option_nl_var_def_blk_end = QtWidgets.QLabel("nl_var_def_blk_end")
        self.label_option_nl_var_def_blk_end.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_var_def_blk_end, 46, 0)
        self.option_nl_var_def_blk_end =  QtWidgets.QSpinBox()
        self.option_nl_var_def_blk_end.setMinimum( 0)
        self.option_nl_var_def_blk_end.setMaximum( 16)
        self.option_nl_var_def_blk_end.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_var_def_blk_end, 46, 1)
        #--------------------------------------------
        self.label_nl_var_def_blk_in = QtWidgets.QLabel(label("<hr>"+self.tr("The maximum number of consecutive newlines within a block of variable\ndefinitions.", "nl_var_def_blk_in")+"\n\n"+self.tr("0: No change (default).", "nl_var_def_blk_in")))
        self.label_nl_var_def_blk_in.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_var_def_blk_in, 47, 0, 1, 2)
        self.label_option_nl_var_def_blk_in = QtWidgets.QLabel("nl_var_def_blk_in")
        self.label_option_nl_var_def_blk_in.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_var_def_blk_in, 48, 0)
        self.option_nl_var_def_blk_in =  QtWidgets.QSpinBox()
        self.option_nl_var_def_blk_in.setMinimum( 0)
        self.option_nl_var_def_blk_in.setMaximum( 16)
        self.option_nl_var_def_blk_in.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_var_def_blk_in, 48, 1)
        #--------------------------------------------
        self.label_nl_before_block_comment = QtWidgets.QLabel(label("<hr>"+self.tr("The minimum number of newlines before a multi-line comment.\nDoesn't apply if after a brace open or another multi-line comment.", "nl_before_block_comment")))
        self.label_nl_before_block_comment.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_before_block_comment, 49, 0, 1, 2)
        self.label_option_nl_before_block_comment = QtWidgets.QLabel("nl_before_block_comment")
        self.label_option_nl_before_block_comment.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_before_block_comment, 50, 0)
        self.option_nl_before_block_comment =  QtWidgets.QSpinBox()
        self.option_nl_before_block_comment.setMinimum( 0)
        self.option_nl_before_block_comment.setMaximum( 16)
        self.option_nl_before_block_comment.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_before_block_comment, 50, 1)
        #--------------------------------------------
        self.label_nl_before_c_comment = QtWidgets.QLabel(label("<hr>"+self.tr("The minimum number of newlines before a single-line C comment.\nDoesn't apply if after a brace open or other single-line C comments.", "nl_before_c_comment")))
        self.label_nl_before_c_comment.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_before_c_comment, 51, 0, 1, 2)
        self.label_option_nl_before_c_comment = QtWidgets.QLabel("nl_before_c_comment")
        self.label_option_nl_before_c_comment.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_before_c_comment, 52, 0)
        self.option_nl_before_c_comment =  QtWidgets.QSpinBox()
        self.option_nl_before_c_comment.setMinimum( 0)
        self.option_nl_before_c_comment.setMaximum( 16)
        self.option_nl_before_c_comment.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_before_c_comment, 52, 1)
        #--------------------------------------------
        self.label_nl_before_cpp_comment = QtWidgets.QLabel(label("<hr>"+self.tr("The minimum number of newlines before a CPP comment.\nDoesn't apply if after a brace open or other CPP comments.", "nl_before_cpp_comment")))
        self.label_nl_before_cpp_comment.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_before_cpp_comment, 53, 0, 1, 2)
        self.label_option_nl_before_cpp_comment = QtWidgets.QLabel("nl_before_cpp_comment")
        self.label_option_nl_before_cpp_comment.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_before_cpp_comment, 54, 0)
        self.option_nl_before_cpp_comment =  QtWidgets.QSpinBox()
        self.option_nl_before_cpp_comment.setMinimum( 0)
        self.option_nl_before_cpp_comment.setMaximum( 16)
        self.option_nl_before_cpp_comment.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_before_cpp_comment, 54, 1)
        #--------------------------------------------
        self.label_nl_after_multiline_comment = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to force a newline after a multi-line comment.", "nl_after_multiline_comment")))
        self.label_nl_after_multiline_comment.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_after_multiline_comment, 55, 0, 1, 2)
        self.label_option_nl_after_multiline_comment = QtWidgets.QLabel("nl_after_multiline_comment")
        self.label_option_nl_after_multiline_comment.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_after_multiline_comment, 56, 0)
        self.option_nl_after_multiline_comment =  QtWidgets.QComboBox()
        self.option_nl_after_multiline_comment.addItems(['true','false'])
        self.option_nl_after_multiline_comment.setCurrentText("false")
        self.group_page_layout_5.addWidget(self.option_nl_after_multiline_comment, 56, 1)
        #--------------------------------------------
        self.label_nl_after_label_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to force a newline after a label's colon.", "nl_after_label_colon")))
        self.label_nl_after_label_colon.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_after_label_colon, 57, 0, 1, 2)
        self.label_option_nl_after_label_colon = QtWidgets.QLabel("nl_after_label_colon")
        self.label_option_nl_after_label_colon.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_after_label_colon, 58, 0)
        self.option_nl_after_label_colon =  QtWidgets.QComboBox()
        self.option_nl_after_label_colon.addItems(['true','false'])
        self.option_nl_after_label_colon.setCurrentText("false")
        self.group_page_layout_5.addWidget(self.option_nl_after_label_colon, 58, 1)
        #--------------------------------------------
        self.label_nl_before_struct = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines before a struct definition.", "nl_before_struct")))
        self.label_nl_before_struct.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_before_struct, 59, 0, 1, 2)
        self.label_option_nl_before_struct = QtWidgets.QLabel("nl_before_struct")
        self.label_option_nl_before_struct.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_before_struct, 60, 0)
        self.option_nl_before_struct =  QtWidgets.QSpinBox()
        self.option_nl_before_struct.setMinimum( 0)
        self.option_nl_before_struct.setMaximum( 16)
        self.option_nl_before_struct.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_before_struct, 60, 1)
        #--------------------------------------------
        self.label_nl_after_struct = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines after '}' or ';' of a struct/enum/union definition.", "nl_after_struct")))
        self.label_nl_after_struct.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_after_struct, 61, 0, 1, 2)
        self.label_option_nl_after_struct = QtWidgets.QLabel("nl_after_struct")
        self.label_option_nl_after_struct.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_after_struct, 62, 0)
        self.option_nl_after_struct =  QtWidgets.QSpinBox()
        self.option_nl_after_struct.setMinimum( 0)
        self.option_nl_after_struct.setMaximum( 16)
        self.option_nl_after_struct.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_after_struct, 62, 1)
        #--------------------------------------------
        self.label_nl_before_class = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines before a class definition.", "nl_before_class")))
        self.label_nl_before_class.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_before_class, 63, 0, 1, 2)
        self.label_option_nl_before_class = QtWidgets.QLabel("nl_before_class")
        self.label_option_nl_before_class.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_before_class, 64, 0)
        self.option_nl_before_class =  QtWidgets.QSpinBox()
        self.option_nl_before_class.setMinimum( 0)
        self.option_nl_before_class.setMaximum( 16)
        self.option_nl_before_class.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_before_class, 64, 1)
        #--------------------------------------------
        self.label_nl_after_class = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines after '}' or ';' of a class definition.", "nl_after_class")))
        self.label_nl_after_class.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_after_class, 65, 0, 1, 2)
        self.label_option_nl_after_class = QtWidgets.QLabel("nl_after_class")
        self.label_option_nl_after_class.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_after_class, 66, 0)
        self.option_nl_after_class =  QtWidgets.QSpinBox()
        self.option_nl_after_class.setMinimum( 0)
        self.option_nl_after_class.setMaximum( 16)
        self.option_nl_after_class.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_after_class, 66, 1)
        #--------------------------------------------
        self.label_nl_before_namespace = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines before a namespace.", "nl_before_namespace")))
        self.label_nl_before_namespace.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_before_namespace, 67, 0, 1, 2)
        self.label_option_nl_before_namespace = QtWidgets.QLabel("nl_before_namespace")
        self.label_option_nl_before_namespace.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_before_namespace, 68, 0)
        self.option_nl_before_namespace =  QtWidgets.QSpinBox()
        self.option_nl_before_namespace.setMinimum( 0)
        self.option_nl_before_namespace.setMaximum( 16)
        self.option_nl_before_namespace.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_before_namespace, 68, 1)
        #--------------------------------------------
        self.label_nl_inside_namespace = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines after '{' of a namespace. This also adds newlines\nbefore the matching '}'.", "nl_inside_namespace")+"\n\n"+self.tr("0: Apply eat_blanks_after_open_brace or eat_blanks_before_close_brace if\n    applicable, otherwise no change.", "nl_inside_namespace")+"\n\n"+self.tr("Overrides eat_blanks_after_open_brace and eat_blanks_before_close_brace.", "nl_inside_namespace")))
        self.label_nl_inside_namespace.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_inside_namespace, 69, 0, 1, 2)
        self.label_option_nl_inside_namespace = QtWidgets.QLabel("nl_inside_namespace")
        self.label_option_nl_inside_namespace.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_inside_namespace, 70, 0)
        self.option_nl_inside_namespace =  QtWidgets.QSpinBox()
        self.option_nl_inside_namespace.setMinimum( 0)
        self.option_nl_inside_namespace.setMaximum( 16)
        self.option_nl_inside_namespace.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_inside_namespace, 70, 1)
        #--------------------------------------------
        self.label_nl_after_namespace = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines after '}' of a namespace.", "nl_after_namespace")))
        self.label_nl_after_namespace.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_after_namespace, 71, 0, 1, 2)
        self.label_option_nl_after_namespace = QtWidgets.QLabel("nl_after_namespace")
        self.label_option_nl_after_namespace.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_after_namespace, 72, 0)
        self.option_nl_after_namespace =  QtWidgets.QSpinBox()
        self.option_nl_after_namespace.setMinimum( 0)
        self.option_nl_after_namespace.setMaximum( 16)
        self.option_nl_after_namespace.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_after_namespace, 72, 1)
        #--------------------------------------------
        self.label_nl_before_access_spec = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines before an access specifier label. This also includes\nthe Qt-specific 'signals:' and 'slots:'. Will not change the newline count\nif after a brace open.", "nl_before_access_spec")+"\n\n"+self.tr("0: No change (default).", "nl_before_access_spec")))
        self.label_nl_before_access_spec.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_before_access_spec, 73, 0, 1, 2)
        self.label_option_nl_before_access_spec = QtWidgets.QLabel("nl_before_access_spec")
        self.label_option_nl_before_access_spec.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_before_access_spec, 74, 0)
        self.option_nl_before_access_spec =  QtWidgets.QSpinBox()
        self.option_nl_before_access_spec.setMinimum( 0)
        self.option_nl_before_access_spec.setMaximum( 16)
        self.option_nl_before_access_spec.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_before_access_spec, 74, 1)
        #--------------------------------------------
        self.label_nl_after_access_spec = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines after an access specifier label. This also includes\nthe Qt-specific 'signals:' and 'slots:'. Will not change the newline count\nif after a brace open.", "nl_after_access_spec")+"\n\n"+self.tr("0: No change (default).", "nl_after_access_spec")+"\n\n"+self.tr("Overrides nl_typedef_blk_start and nl_var_def_blk_start.", "nl_after_access_spec")))
        self.label_nl_after_access_spec.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_after_access_spec, 75, 0, 1, 2)
        self.label_option_nl_after_access_spec = QtWidgets.QLabel("nl_after_access_spec")
        self.label_option_nl_after_access_spec.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_after_access_spec, 76, 0)
        self.option_nl_after_access_spec =  QtWidgets.QSpinBox()
        self.option_nl_after_access_spec.setMinimum( 0)
        self.option_nl_after_access_spec.setMaximum( 16)
        self.option_nl_after_access_spec.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_after_access_spec, 76, 1)
        #--------------------------------------------
        self.label_nl_comment_func_def = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines between a function definition and the function\ncomment, as in '// comment\\n <here> void foo() {...}'.", "nl_comment_func_def")+"\n\n"+self.tr("0: No change (default).", "nl_comment_func_def")))
        self.label_nl_comment_func_def.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_comment_func_def, 77, 0, 1, 2)
        self.label_option_nl_comment_func_def = QtWidgets.QLabel("nl_comment_func_def")
        self.label_option_nl_comment_func_def.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_comment_func_def, 78, 0)
        self.option_nl_comment_func_def =  QtWidgets.QSpinBox()
        self.option_nl_comment_func_def.setMinimum( 0)
        self.option_nl_comment_func_def.setMaximum( 16)
        self.option_nl_comment_func_def.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_comment_func_def, 78, 1)
        #--------------------------------------------
        self.label_nl_after_try_catch_finally = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines after a try-catch-finally block that isn't followed\nby a brace close.", "nl_after_try_catch_finally")+"\n\n"+self.tr("0: No change (default).", "nl_after_try_catch_finally")))
        self.label_nl_after_try_catch_finally.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_after_try_catch_finally, 79, 0, 1, 2)
        self.label_option_nl_after_try_catch_finally = QtWidgets.QLabel("nl_after_try_catch_finally")
        self.label_option_nl_after_try_catch_finally.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_after_try_catch_finally, 80, 0)
        self.option_nl_after_try_catch_finally =  QtWidgets.QSpinBox()
        self.option_nl_after_try_catch_finally.setMinimum( 0)
        self.option_nl_after_try_catch_finally.setMaximum( 16)
        self.option_nl_after_try_catch_finally.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_after_try_catch_finally, 80, 1)
        #--------------------------------------------
        self.label_nl_around_cs_property = QtWidgets.QLabel(label("<hr>"+self.tr("(C#) The number of newlines before and after a property, indexer or event\ndeclaration.", "nl_around_cs_property")+"\n\n"+self.tr("0: No change (default).", "nl_around_cs_property")))
        self.label_nl_around_cs_property.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_around_cs_property, 81, 0, 1, 2)
        self.label_option_nl_around_cs_property = QtWidgets.QLabel("nl_around_cs_property")
        self.label_option_nl_around_cs_property.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_around_cs_property, 82, 0)
        self.option_nl_around_cs_property =  QtWidgets.QSpinBox()
        self.option_nl_around_cs_property.setMinimum( 0)
        self.option_nl_around_cs_property.setMaximum( 16)
        self.option_nl_around_cs_property.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_around_cs_property, 82, 1)
        #--------------------------------------------
        self.label_nl_between_get_set = QtWidgets.QLabel(label("<hr>"+self.tr("(C#) The number of newlines between the get/set/add/remove handlers.", "nl_between_get_set")+"\n\n"+self.tr("0: No change (default).", "nl_between_get_set")))
        self.label_nl_between_get_set.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_between_get_set, 83, 0, 1, 2)
        self.label_option_nl_between_get_set = QtWidgets.QLabel("nl_between_get_set")
        self.label_option_nl_between_get_set.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_between_get_set, 84, 0)
        self.option_nl_between_get_set =  QtWidgets.QSpinBox()
        self.option_nl_between_get_set.setMinimum( 0)
        self.option_nl_between_get_set.setMaximum( 16)
        self.option_nl_between_get_set.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_between_get_set, 84, 1)
        #--------------------------------------------
        self.label_nl_property_brace = QtWidgets.QLabel(label("<hr>"+self.tr("(C#) Add or remove newline between property and the '{'.", "nl_property_brace")))
        self.label_nl_property_brace.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_property_brace, 85, 0, 1, 2)
        self.label_option_nl_property_brace = QtWidgets.QLabel("nl_property_brace")
        self.label_option_nl_property_brace.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_property_brace, 86, 0)
        self.option_nl_property_brace =  QtWidgets.QComboBox()
        self.option_nl_property_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_property_brace.setCurrentText("ignore")
        self.group_page_layout_5.addWidget(self.option_nl_property_brace, 86, 1)
        #--------------------------------------------
        self.label_eat_blanks_after_open_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to remove blank lines after '{'.", "eat_blanks_after_open_brace")))
        self.label_eat_blanks_after_open_brace.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_eat_blanks_after_open_brace, 87, 0, 1, 2)
        self.label_option_eat_blanks_after_open_brace = QtWidgets.QLabel("eat_blanks_after_open_brace")
        self.label_option_eat_blanks_after_open_brace.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_eat_blanks_after_open_brace, 88, 0)
        self.option_eat_blanks_after_open_brace =  QtWidgets.QComboBox()
        self.option_eat_blanks_after_open_brace.addItems(['true','false'])
        self.option_eat_blanks_after_open_brace.setCurrentText("false")
        self.group_page_layout_5.addWidget(self.option_eat_blanks_after_open_brace, 88, 1)
        #--------------------------------------------
        self.label_eat_blanks_before_close_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to remove blank lines before '}'.", "eat_blanks_before_close_brace")))
        self.label_eat_blanks_before_close_brace.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_eat_blanks_before_close_brace, 89, 0, 1, 2)
        self.label_option_eat_blanks_before_close_brace = QtWidgets.QLabel("eat_blanks_before_close_brace")
        self.label_option_eat_blanks_before_close_brace.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_eat_blanks_before_close_brace, 90, 0)
        self.option_eat_blanks_before_close_brace =  QtWidgets.QComboBox()
        self.option_eat_blanks_before_close_brace.addItems(['true','false'])
        self.option_eat_blanks_before_close_brace.setCurrentText("false")
        self.group_page_layout_5.addWidget(self.option_eat_blanks_before_close_brace, 90, 1)
        #--------------------------------------------
        self.label_nl_remove_extra_newlines = QtWidgets.QLabel(label("<hr>"+self.tr("How aggressively to remove extra newlines not in preprocessor.", "nl_remove_extra_newlines")+"\n\n"+self.tr("0: No change (default)\n1: Remove most newlines not handled by other config\n2: Remove all newlines and reformat completely by config", "nl_remove_extra_newlines")))
        self.label_nl_remove_extra_newlines.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_remove_extra_newlines, 91, 0, 1, 2)
        self.label_option_nl_remove_extra_newlines = QtWidgets.QLabel("nl_remove_extra_newlines")
        self.label_option_nl_remove_extra_newlines.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_remove_extra_newlines, 92, 0)
        self.option_nl_remove_extra_newlines =  QtWidgets.QSpinBox()
        self.option_nl_remove_extra_newlines.setMinimum( 0)
        self.option_nl_remove_extra_newlines.setMaximum( 2)
        self.option_nl_remove_extra_newlines.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_remove_extra_newlines, 92, 1)
        #--------------------------------------------
        self.label_nl_after_annotation = QtWidgets.QLabel(label("<hr>"+self.tr("(Java) Add or remove newline after an annotation statement. Only affects\nannotations that are after a newline.", "nl_after_annotation")))
        self.label_nl_after_annotation.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_after_annotation, 93, 0, 1, 2)
        self.label_option_nl_after_annotation = QtWidgets.QLabel("nl_after_annotation")
        self.label_option_nl_after_annotation.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_after_annotation, 94, 0)
        self.option_nl_after_annotation =  QtWidgets.QComboBox()
        self.option_nl_after_annotation.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_after_annotation.setCurrentText("ignore")
        self.group_page_layout_5.addWidget(self.option_nl_after_annotation, 94, 1)
        #--------------------------------------------
        self.label_nl_between_annotation = QtWidgets.QLabel(label("<hr>"+self.tr("(Java) Add or remove newline between two annotations.", "nl_between_annotation")))
        self.label_nl_between_annotation.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_between_annotation, 95, 0, 1, 2)
        self.label_option_nl_between_annotation = QtWidgets.QLabel("nl_between_annotation")
        self.label_option_nl_between_annotation.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_between_annotation, 96, 0)
        self.option_nl_between_annotation =  QtWidgets.QComboBox()
        self.option_nl_between_annotation.addItems(['ignore','add','remove','force','not_defined'])
        self.option_nl_between_annotation.setCurrentText("ignore")
        self.group_page_layout_5.addWidget(self.option_nl_between_annotation, 96, 1)
        #--------------------------------------------
        self.label_nl_before_whole_file_ifdef = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines before a whole-file #ifdef.", "nl_before_whole_file_ifdef")+"\n\n"+self.tr("0: No change (default).", "nl_before_whole_file_ifdef")))
        self.label_nl_before_whole_file_ifdef.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_before_whole_file_ifdef, 97, 0, 1, 2)
        self.label_option_nl_before_whole_file_ifdef = QtWidgets.QLabel("nl_before_whole_file_ifdef")
        self.label_option_nl_before_whole_file_ifdef.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_before_whole_file_ifdef, 98, 0)
        self.option_nl_before_whole_file_ifdef =  QtWidgets.QSpinBox()
        self.option_nl_before_whole_file_ifdef.setMinimum( 0)
        self.option_nl_before_whole_file_ifdef.setMaximum( 16)
        self.option_nl_before_whole_file_ifdef.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_before_whole_file_ifdef, 98, 1)
        #--------------------------------------------
        self.label_nl_after_whole_file_ifdef = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines after a whole-file #ifdef.", "nl_after_whole_file_ifdef")+"\n\n"+self.tr("0: No change (default).", "nl_after_whole_file_ifdef")))
        self.label_nl_after_whole_file_ifdef.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_after_whole_file_ifdef, 99, 0, 1, 2)
        self.label_option_nl_after_whole_file_ifdef = QtWidgets.QLabel("nl_after_whole_file_ifdef")
        self.label_option_nl_after_whole_file_ifdef.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_after_whole_file_ifdef, 100, 0)
        self.option_nl_after_whole_file_ifdef =  QtWidgets.QSpinBox()
        self.option_nl_after_whole_file_ifdef.setMinimum( 0)
        self.option_nl_after_whole_file_ifdef.setMaximum( 16)
        self.option_nl_after_whole_file_ifdef.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_after_whole_file_ifdef, 100, 1)
        #--------------------------------------------
        self.label_nl_before_whole_file_endif = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines before a whole-file #endif.", "nl_before_whole_file_endif")+"\n\n"+self.tr("0: No change (default).", "nl_before_whole_file_endif")))
        self.label_nl_before_whole_file_endif.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_before_whole_file_endif, 101, 0, 1, 2)
        self.label_option_nl_before_whole_file_endif = QtWidgets.QLabel("nl_before_whole_file_endif")
        self.label_option_nl_before_whole_file_endif.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_before_whole_file_endif, 102, 0)
        self.option_nl_before_whole_file_endif =  QtWidgets.QSpinBox()
        self.option_nl_before_whole_file_endif.setMinimum( 0)
        self.option_nl_before_whole_file_endif.setMaximum( 16)
        self.option_nl_before_whole_file_endif.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_before_whole_file_endif, 102, 1)
        #--------------------------------------------
        self.label_nl_after_whole_file_endif = QtWidgets.QLabel(label("<hr>"+self.tr("The number of newlines after a whole-file #endif.", "nl_after_whole_file_endif")+"\n\n"+self.tr("0: No change (default).", "nl_after_whole_file_endif")))
        self.label_nl_after_whole_file_endif.setWordWrap(True)
        self.group_page_layout_5.addWidget(self.label_nl_after_whole_file_endif, 103, 0, 1, 2)
        self.label_option_nl_after_whole_file_endif = QtWidgets.QLabel("nl_after_whole_file_endif")
        self.label_option_nl_after_whole_file_endif.setFont(font_name)
        self.group_page_layout_5.addWidget(self.label_option_nl_after_whole_file_endif, 104, 0)
        self.option_nl_after_whole_file_endif =  QtWidgets.QSpinBox()
        self.option_nl_after_whole_file_endif.setMinimum( 0)
        self.option_nl_after_whole_file_endif.setMaximum( 16)
        self.option_nl_after_whole_file_endif.setValue(0)
        self.group_page_layout_5.addWidget(self.option_nl_after_whole_file_endif, 104, 1)
        self.group_page_layout_5.addItem(QtWidgets.QSpacerItem(10, 10, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding), 105,0)
        self.scroll_group_page_5 = QtWidgets.QScrollArea()
        self.scroll_group_page_5.setWidget(self.group_page_5)
        self.scroll_group_page_5.setWidgetResizable(True)
        self.addTab(self.scroll_group_page_5, self.tr("Blank line options"))
        #================== Positioning options =============================================================
        self.group_page_6 = QtWidgets.QWidget()
        self.group_page_layout_6 = QtWidgets.QGridLayout(self.group_page_6)
        self.group_page_layout_6.addWidget(QtWidgets.QLabel(label(self.tr("Positioning options help"))), 0, 0, 1, 2)
        #--------------------------------------------
        self.label_pos_arith = QtWidgets.QLabel(label("<hr>"+self.tr("The position of arithmetic operators in wrapped expressions.", "pos_arith")))
        self.label_pos_arith.setWordWrap(True)
        self.group_page_layout_6.addWidget(self.label_pos_arith, 1, 0, 1, 2)
        self.label_option_pos_arith = QtWidgets.QLabel("pos_arith")
        self.label_option_pos_arith.setFont(font_name)
        self.group_page_layout_6.addWidget(self.label_option_pos_arith, 2, 0)
        self.option_pos_arith =  QtWidgets.QComboBox()
        self.option_pos_arith.addItems(['ignore','break','force','lead','trail','join','lead_break','lead_force','trail_break','trail_force'])
        self.option_pos_arith.setCurrentText("ignore")
        self.group_page_layout_6.addWidget(self.option_pos_arith, 2, 1)
        #--------------------------------------------
        self.label_pos_assign = QtWidgets.QLabel(label("<hr>"+self.tr("The position of assignment in wrapped expressions. Do not affect '='\nfollowed by '{'.", "pos_assign")))
        self.label_pos_assign.setWordWrap(True)
        self.group_page_layout_6.addWidget(self.label_pos_assign, 3, 0, 1, 2)
        self.label_option_pos_assign = QtWidgets.QLabel("pos_assign")
        self.label_option_pos_assign.setFont(font_name)
        self.group_page_layout_6.addWidget(self.label_option_pos_assign, 4, 0)
        self.option_pos_assign =  QtWidgets.QComboBox()
        self.option_pos_assign.addItems(['ignore','break','force','lead','trail','join','lead_break','lead_force','trail_break','trail_force'])
        self.option_pos_assign.setCurrentText("ignore")
        self.group_page_layout_6.addWidget(self.option_pos_assign, 4, 1)
        #--------------------------------------------
        self.label_pos_bool = QtWidgets.QLabel(label("<hr>"+self.tr("The position of Boolean operators in wrapped expressions.", "pos_bool")))
        self.label_pos_bool.setWordWrap(True)
        self.group_page_layout_6.addWidget(self.label_pos_bool, 5, 0, 1, 2)
        self.label_option_pos_bool = QtWidgets.QLabel("pos_bool")
        self.label_option_pos_bool.setFont(font_name)
        self.group_page_layout_6.addWidget(self.label_option_pos_bool, 6, 0)
        self.option_pos_bool =  QtWidgets.QComboBox()
        self.option_pos_bool.addItems(['ignore','break','force','lead','trail','join','lead_break','lead_force','trail_break','trail_force'])
        self.option_pos_bool.setCurrentText("ignore")
        self.group_page_layout_6.addWidget(self.option_pos_bool, 6, 1)
        #--------------------------------------------
        self.label_pos_compare = QtWidgets.QLabel(label("<hr>"+self.tr("The position of comparison operators in wrapped expressions.", "pos_compare")))
        self.label_pos_compare.setWordWrap(True)
        self.group_page_layout_6.addWidget(self.label_pos_compare, 7, 0, 1, 2)
        self.label_option_pos_compare = QtWidgets.QLabel("pos_compare")
        self.label_option_pos_compare.setFont(font_name)
        self.group_page_layout_6.addWidget(self.label_option_pos_compare, 8, 0)
        self.option_pos_compare =  QtWidgets.QComboBox()
        self.option_pos_compare.addItems(['ignore','break','force','lead','trail','join','lead_break','lead_force','trail_break','trail_force'])
        self.option_pos_compare.setCurrentText("ignore")
        self.group_page_layout_6.addWidget(self.option_pos_compare, 8, 1)
        #--------------------------------------------
        self.label_pos_conditional = QtWidgets.QLabel(label("<hr>"+self.tr("The position of conditional operators, as in the '?' and ':' of\n'expr ? stmt : stmt', in wrapped expressions.", "pos_conditional")))
        self.label_pos_conditional.setWordWrap(True)
        self.group_page_layout_6.addWidget(self.label_pos_conditional, 9, 0, 1, 2)
        self.label_option_pos_conditional = QtWidgets.QLabel("pos_conditional")
        self.label_option_pos_conditional.setFont(font_name)
        self.group_page_layout_6.addWidget(self.label_option_pos_conditional, 10, 0)
        self.option_pos_conditional =  QtWidgets.QComboBox()
        self.option_pos_conditional.addItems(['ignore','break','force','lead','trail','join','lead_break','lead_force','trail_break','trail_force'])
        self.option_pos_conditional.setCurrentText("ignore")
        self.group_page_layout_6.addWidget(self.option_pos_conditional, 10, 1)
        #--------------------------------------------
        self.label_pos_comma = QtWidgets.QLabel(label("<hr>"+self.tr("The position of the comma in wrapped expressions.", "pos_comma")))
        self.label_pos_comma.setWordWrap(True)
        self.group_page_layout_6.addWidget(self.label_pos_comma, 11, 0, 1, 2)
        self.label_option_pos_comma = QtWidgets.QLabel("pos_comma")
        self.label_option_pos_comma.setFont(font_name)
        self.group_page_layout_6.addWidget(self.label_option_pos_comma, 12, 0)
        self.option_pos_comma =  QtWidgets.QComboBox()
        self.option_pos_comma.addItems(['ignore','break','force','lead','trail','join','lead_break','lead_force','trail_break','trail_force'])
        self.option_pos_comma.setCurrentText("ignore")
        self.group_page_layout_6.addWidget(self.option_pos_comma, 12, 1)
        #--------------------------------------------
        self.label_pos_enum_comma = QtWidgets.QLabel(label("<hr>"+self.tr("The position of the comma in enum entries.", "pos_enum_comma")))
        self.label_pos_enum_comma.setWordWrap(True)
        self.group_page_layout_6.addWidget(self.label_pos_enum_comma, 13, 0, 1, 2)
        self.label_option_pos_enum_comma = QtWidgets.QLabel("pos_enum_comma")
        self.label_option_pos_enum_comma.setFont(font_name)
        self.group_page_layout_6.addWidget(self.label_option_pos_enum_comma, 14, 0)
        self.option_pos_enum_comma =  QtWidgets.QComboBox()
        self.option_pos_enum_comma.addItems(['ignore','break','force','lead','trail','join','lead_break','lead_force','trail_break','trail_force'])
        self.option_pos_enum_comma.setCurrentText("ignore")
        self.group_page_layout_6.addWidget(self.option_pos_enum_comma, 14, 1)
        #--------------------------------------------
        self.label_pos_class_comma = QtWidgets.QLabel(label("<hr>"+self.tr("The position of the comma in the base class list if there is more than one\nline. Affects nl_class_init_args.", "pos_class_comma")))
        self.label_pos_class_comma.setWordWrap(True)
        self.group_page_layout_6.addWidget(self.label_pos_class_comma, 15, 0, 1, 2)
        self.label_option_pos_class_comma = QtWidgets.QLabel("pos_class_comma")
        self.label_option_pos_class_comma.setFont(font_name)
        self.group_page_layout_6.addWidget(self.label_option_pos_class_comma, 16, 0)
        self.option_pos_class_comma =  QtWidgets.QComboBox()
        self.option_pos_class_comma.addItems(['ignore','break','force','lead','trail','join','lead_break','lead_force','trail_break','trail_force'])
        self.option_pos_class_comma.setCurrentText("ignore")
        self.group_page_layout_6.addWidget(self.option_pos_class_comma, 16, 1)
        #--------------------------------------------
        self.label_pos_constr_comma = QtWidgets.QLabel(label("<hr>"+self.tr("The position of the comma in the constructor initialization list.\nRelated to nl_constr_colon, nl_constr_init_args and pos_constr_colon.", "pos_constr_comma")))
        self.label_pos_constr_comma.setWordWrap(True)
        self.group_page_layout_6.addWidget(self.label_pos_constr_comma, 17, 0, 1, 2)
        self.label_option_pos_constr_comma = QtWidgets.QLabel("pos_constr_comma")
        self.label_option_pos_constr_comma.setFont(font_name)
        self.group_page_layout_6.addWidget(self.label_option_pos_constr_comma, 18, 0)
        self.option_pos_constr_comma =  QtWidgets.QComboBox()
        self.option_pos_constr_comma.addItems(['ignore','break','force','lead','trail','join','lead_break','lead_force','trail_break','trail_force'])
        self.option_pos_constr_comma.setCurrentText("ignore")
        self.group_page_layout_6.addWidget(self.option_pos_constr_comma, 18, 1)
        #--------------------------------------------
        self.label_pos_class_colon = QtWidgets.QLabel(label("<hr>"+self.tr("The position of trailing/leading class colon, between class and base class\nlist. Affects nl_class_colon.", "pos_class_colon")))
        self.label_pos_class_colon.setWordWrap(True)
        self.group_page_layout_6.addWidget(self.label_pos_class_colon, 19, 0, 1, 2)
        self.label_option_pos_class_colon = QtWidgets.QLabel("pos_class_colon")
        self.label_option_pos_class_colon.setFont(font_name)
        self.group_page_layout_6.addWidget(self.label_option_pos_class_colon, 20, 0)
        self.option_pos_class_colon =  QtWidgets.QComboBox()
        self.option_pos_class_colon.addItems(['ignore','break','force','lead','trail','join','lead_break','lead_force','trail_break','trail_force'])
        self.option_pos_class_colon.setCurrentText("ignore")
        self.group_page_layout_6.addWidget(self.option_pos_class_colon, 20, 1)
        #--------------------------------------------
        self.label_pos_constr_colon = QtWidgets.QLabel(label("<hr>"+self.tr("The position of colons between constructor and member initialization.\nRelated to nl_constr_colon, nl_constr_init_args and pos_constr_comma.", "pos_constr_colon")))
        self.label_pos_constr_colon.setWordWrap(True)
        self.group_page_layout_6.addWidget(self.label_pos_constr_colon, 21, 0, 1, 2)
        self.label_option_pos_constr_colon = QtWidgets.QLabel("pos_constr_colon")
        self.label_option_pos_constr_colon.setFont(font_name)
        self.group_page_layout_6.addWidget(self.label_option_pos_constr_colon, 22, 0)
        self.option_pos_constr_colon =  QtWidgets.QComboBox()
        self.option_pos_constr_colon.addItems(['ignore','break','force','lead','trail','join','lead_break','lead_force','trail_break','trail_force'])
        self.option_pos_constr_colon.setCurrentText("ignore")
        self.group_page_layout_6.addWidget(self.option_pos_constr_colon, 22, 1)
        #--------------------------------------------
        self.label_pos_shift = QtWidgets.QLabel(label("<hr>"+self.tr("The position of shift operators in wrapped expressions.", "pos_shift")))
        self.label_pos_shift.setWordWrap(True)
        self.group_page_layout_6.addWidget(self.label_pos_shift, 23, 0, 1, 2)
        self.label_option_pos_shift = QtWidgets.QLabel("pos_shift")
        self.label_option_pos_shift.setFont(font_name)
        self.group_page_layout_6.addWidget(self.label_option_pos_shift, 24, 0)
        self.option_pos_shift =  QtWidgets.QComboBox()
        self.option_pos_shift.addItems(['ignore','break','force','lead','trail','join','lead_break','lead_force','trail_break','trail_force'])
        self.option_pos_shift.setCurrentText("ignore")
        self.group_page_layout_6.addWidget(self.option_pos_shift, 24, 1)
        self.group_page_layout_6.addItem(QtWidgets.QSpacerItem(10, 10, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding), 25,0)
        self.scroll_group_page_6 = QtWidgets.QScrollArea()
        self.scroll_group_page_6.setWidget(self.group_page_6)
        self.scroll_group_page_6.setWidgetResizable(True)
        self.addTab(self.scroll_group_page_6, self.tr("Positioning options"))
        #================== Line splitting options ==========================================================
        self.group_page_7 = QtWidgets.QWidget()
        self.group_page_layout_7 = QtWidgets.QGridLayout(self.group_page_7)
        self.group_page_layout_7.addWidget(QtWidgets.QLabel(label(self.tr("Line splitting options help"))), 0, 0, 1, 2)
        #--------------------------------------------
        self.label_code_width = QtWidgets.QLabel(label("<hr>"+self.tr("Try to limit code width to N columns.", "code_width")))
        self.label_code_width.setWordWrap(True)
        self.group_page_layout_7.addWidget(self.label_code_width, 1, 0, 1, 2)
        self.label_option_code_width = QtWidgets.QLabel("code_width")
        self.label_option_code_width.setFont(font_name)
        self.group_page_layout_7.addWidget(self.label_option_code_width, 2, 0)
        self.option_code_width =  QtWidgets.QSpinBox()
        self.option_code_width.setMinimum( 0)
        self.option_code_width.setMaximum( 10000)
        self.option_code_width.setValue(0)
        self.group_page_layout_7.addWidget(self.option_code_width, 2, 1)
        #--------------------------------------------
        self.label_ls_for_split_full = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to fully split long 'for' statements at semi-colons.", "ls_for_split_full")))
        self.label_ls_for_split_full.setWordWrap(True)
        self.group_page_layout_7.addWidget(self.label_ls_for_split_full, 3, 0, 1, 2)
        self.label_option_ls_for_split_full = QtWidgets.QLabel("ls_for_split_full")
        self.label_option_ls_for_split_full.setFont(font_name)
        self.group_page_layout_7.addWidget(self.label_option_ls_for_split_full, 4, 0)
        self.option_ls_for_split_full =  QtWidgets.QComboBox()
        self.option_ls_for_split_full.addItems(['true','false'])
        self.option_ls_for_split_full.setCurrentText("false")
        self.group_page_layout_7.addWidget(self.option_ls_for_split_full, 4, 1)
        #--------------------------------------------
        self.label_ls_func_split_full = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to fully split long function prototypes/calls at commas.\nThe option ls_code_width has priority over the option ls_func_split_full.", "ls_func_split_full")))
        self.label_ls_func_split_full.setWordWrap(True)
        self.group_page_layout_7.addWidget(self.label_ls_func_split_full, 5, 0, 1, 2)
        self.label_option_ls_func_split_full = QtWidgets.QLabel("ls_func_split_full")
        self.label_option_ls_func_split_full.setFont(font_name)
        self.group_page_layout_7.addWidget(self.label_option_ls_func_split_full, 6, 0)
        self.option_ls_func_split_full =  QtWidgets.QComboBox()
        self.option_ls_func_split_full.addItems(['true','false'])
        self.option_ls_func_split_full.setCurrentText("false")
        self.group_page_layout_7.addWidget(self.option_ls_func_split_full, 6, 1)
        #--------------------------------------------
        self.label_ls_code_width = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to split lines as close to code_width as possible and ignore some\ngroupings.\nThe option ls_code_width has priority over the option ls_func_split_full.", "ls_code_width")))
        self.label_ls_code_width.setWordWrap(True)
        self.group_page_layout_7.addWidget(self.label_ls_code_width, 7, 0, 1, 2)
        self.label_option_ls_code_width = QtWidgets.QLabel("ls_code_width")
        self.label_option_ls_code_width.setFont(font_name)
        self.group_page_layout_7.addWidget(self.label_option_ls_code_width, 8, 0)
        self.option_ls_code_width =  QtWidgets.QComboBox()
        self.option_ls_code_width.addItems(['true','false'])
        self.option_ls_code_width.setCurrentText("false")
        self.group_page_layout_7.addWidget(self.option_ls_code_width, 8, 1)
        self.group_page_layout_7.addItem(QtWidgets.QSpacerItem(10, 10, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding), 9,0)
        self.scroll_group_page_7 = QtWidgets.QScrollArea()
        self.scroll_group_page_7.setWidget(self.group_page_7)
        self.scroll_group_page_7.setWidgetResizable(True)
        self.addTab(self.scroll_group_page_7, self.tr("Line splitting options"))
        #================== Code alignment options (not left column spaces/tabs) ============================
        self.group_page_8 = QtWidgets.QWidget()
        self.group_page_layout_8 = QtWidgets.QGridLayout(self.group_page_8)
        self.group_page_layout_8.addWidget(QtWidgets.QLabel(label(self.tr("Code alignment options (not left column spaces/tabs) help"))), 0, 0, 1, 2)
        #--------------------------------------------
        self.label_align_keep_tabs = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to keep non-indenting tabs.", "align_keep_tabs")))
        self.label_align_keep_tabs.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_keep_tabs, 1, 0, 1, 2)
        self.label_option_align_keep_tabs = QtWidgets.QLabel("align_keep_tabs")
        self.label_option_align_keep_tabs.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_keep_tabs, 2, 0)
        self.option_align_keep_tabs =  QtWidgets.QComboBox()
        self.option_align_keep_tabs.addItems(['true','false'])
        self.option_align_keep_tabs.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_keep_tabs, 2, 1)
        #--------------------------------------------
        self.label_align_with_tabs = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to use tabs for aligning.", "align_with_tabs")))
        self.label_align_with_tabs.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_with_tabs, 3, 0, 1, 2)
        self.label_option_align_with_tabs = QtWidgets.QLabel("align_with_tabs")
        self.label_option_align_with_tabs.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_with_tabs, 4, 0)
        self.option_align_with_tabs =  QtWidgets.QComboBox()
        self.option_align_with_tabs.addItems(['true','false'])
        self.option_align_with_tabs.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_with_tabs, 4, 1)
        #--------------------------------------------
        self.label_align_on_tabstop = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to bump out to the next tab when aligning.", "align_on_tabstop")))
        self.label_align_on_tabstop.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_on_tabstop, 5, 0, 1, 2)
        self.label_option_align_on_tabstop = QtWidgets.QLabel("align_on_tabstop")
        self.label_option_align_on_tabstop.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_on_tabstop, 6, 0)
        self.option_align_on_tabstop =  QtWidgets.QComboBox()
        self.option_align_on_tabstop.addItems(['true','false'])
        self.option_align_on_tabstop.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_on_tabstop, 6, 1)
        #--------------------------------------------
        self.label_align_number_right = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to right-align numbers.", "align_number_right")))
        self.label_align_number_right.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_number_right, 7, 0, 1, 2)
        self.label_option_align_number_right = QtWidgets.QLabel("align_number_right")
        self.label_option_align_number_right.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_number_right, 8, 0)
        self.option_align_number_right =  QtWidgets.QComboBox()
        self.option_align_number_right.addItems(['true','false'])
        self.option_align_number_right.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_number_right, 8, 1)
        #--------------------------------------------
        self.label_align_keep_extra_space = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to keep whitespace not required for alignment.", "align_keep_extra_space")))
        self.label_align_keep_extra_space.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_keep_extra_space, 9, 0, 1, 2)
        self.label_option_align_keep_extra_space = QtWidgets.QLabel("align_keep_extra_space")
        self.label_option_align_keep_extra_space.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_keep_extra_space, 10, 0)
        self.option_align_keep_extra_space =  QtWidgets.QComboBox()
        self.option_align_keep_extra_space.addItems(['true','false'])
        self.option_align_keep_extra_space.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_keep_extra_space, 10, 1)
        #--------------------------------------------
        self.label_align_func_params = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to align variable definitions in prototypes and functions.", "align_func_params")))
        self.label_align_func_params.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_func_params, 11, 0, 1, 2)
        self.label_option_align_func_params = QtWidgets.QLabel("align_func_params")
        self.label_option_align_func_params.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_func_params, 12, 0)
        self.option_align_func_params =  QtWidgets.QComboBox()
        self.option_align_func_params.addItems(['true','false'])
        self.option_align_func_params.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_func_params, 12, 1)
        #--------------------------------------------
        self.label_align_func_params_span = QtWidgets.QLabel(label("<hr>"+self.tr("The span for aligning parameter definitions in function on parameter name.", "align_func_params_span")+"\n\n"+self.tr("0: Don't align (default).", "align_func_params_span")))
        self.label_align_func_params_span.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_func_params_span, 13, 0, 1, 2)
        self.label_option_align_func_params_span = QtWidgets.QLabel("align_func_params_span")
        self.label_option_align_func_params_span.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_func_params_span, 14, 0)
        self.option_align_func_params_span =  QtWidgets.QSpinBox()
        self.option_align_func_params_span.setMinimum( 0)
        self.option_align_func_params_span.setMaximum( 16)
        self.option_align_func_params_span.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_func_params_span, 14, 1)
        #--------------------------------------------
        self.label_align_func_params_thresh = QtWidgets.QLabel(label("<hr>"+self.tr("The threshold for aligning function parameter definitions.\nUse a negative number for absolute thresholds.", "align_func_params_thresh")+"\n\n"+self.tr("0: No limit (default).", "align_func_params_thresh")))
        self.label_align_func_params_thresh.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_func_params_thresh, 15, 0, 1, 2)
        self.label_option_align_func_params_thresh = QtWidgets.QLabel("align_func_params_thresh")
        self.label_option_align_func_params_thresh.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_func_params_thresh, 16, 0)
        self.option_align_func_params_thresh =  QtWidgets.QSpinBox()
        self.option_align_func_params_thresh.setMinimum( -1000)
        self.option_align_func_params_thresh.setMaximum( 5000)
        self.option_align_func_params_thresh.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_func_params_thresh, 16, 1)
        #--------------------------------------------
        self.label_align_func_params_gap = QtWidgets.QLabel(label("<hr>"+self.tr("The gap for aligning function parameter definitions.", "align_func_params_gap")))
        self.label_align_func_params_gap.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_func_params_gap, 17, 0, 1, 2)
        self.label_option_align_func_params_gap = QtWidgets.QLabel("align_func_params_gap")
        self.label_option_align_func_params_gap.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_func_params_gap, 18, 0)
        self.option_align_func_params_gap =  QtWidgets.QSpinBox()
        self.option_align_func_params_gap.setMinimum( 0)
        self.option_align_func_params_gap.setMaximum( 16)
        self.option_align_func_params_gap.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_func_params_gap, 18, 1)
        #--------------------------------------------
        self.label_align_constr_value_span = QtWidgets.QLabel(label("<hr>"+self.tr("The span for aligning constructor value.", "align_constr_value_span")+"\n\n"+self.tr("0: Don't align (default).", "align_constr_value_span")))
        self.label_align_constr_value_span.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_constr_value_span, 19, 0, 1, 2)
        self.label_option_align_constr_value_span = QtWidgets.QLabel("align_constr_value_span")
        self.label_option_align_constr_value_span.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_constr_value_span, 20, 0)
        self.option_align_constr_value_span =  QtWidgets.QSpinBox()
        self.option_align_constr_value_span.setMinimum( 0)
        self.option_align_constr_value_span.setMaximum( 16)
        self.option_align_constr_value_span.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_constr_value_span, 20, 1)
        #--------------------------------------------
        self.label_align_constr_value_thresh = QtWidgets.QLabel(label("<hr>"+self.tr("The threshold for aligning constructor value.\nUse a negative number for absolute thresholds.", "align_constr_value_thresh")+"\n\n"+self.tr("0: No limit (default).", "align_constr_value_thresh")))
        self.label_align_constr_value_thresh.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_constr_value_thresh, 21, 0, 1, 2)
        self.label_option_align_constr_value_thresh = QtWidgets.QLabel("align_constr_value_thresh")
        self.label_option_align_constr_value_thresh.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_constr_value_thresh, 22, 0)
        self.option_align_constr_value_thresh =  QtWidgets.QSpinBox()
        self.option_align_constr_value_thresh.setMinimum( -1000)
        self.option_align_constr_value_thresh.setMaximum( 5000)
        self.option_align_constr_value_thresh.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_constr_value_thresh, 22, 1)
        #--------------------------------------------
        self.label_align_constr_value_gap = QtWidgets.QLabel(label("<hr>"+self.tr("The gap for aligning constructor value.", "align_constr_value_gap")))
        self.label_align_constr_value_gap.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_constr_value_gap, 23, 0, 1, 2)
        self.label_option_align_constr_value_gap = QtWidgets.QLabel("align_constr_value_gap")
        self.label_option_align_constr_value_gap.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_constr_value_gap, 24, 0)
        self.option_align_constr_value_gap =  QtWidgets.QSpinBox()
        self.option_align_constr_value_gap.setMinimum( 0)
        self.option_align_constr_value_gap.setMaximum( 16)
        self.option_align_constr_value_gap.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_constr_value_gap, 24, 1)
        #--------------------------------------------
        self.label_align_same_func_call_params = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to align parameters in single-line functions that have the same\nname. The function names must already be aligned with each other.", "align_same_func_call_params")))
        self.label_align_same_func_call_params.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_same_func_call_params, 25, 0, 1, 2)
        self.label_option_align_same_func_call_params = QtWidgets.QLabel("align_same_func_call_params")
        self.label_option_align_same_func_call_params.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_same_func_call_params, 26, 0)
        self.option_align_same_func_call_params =  QtWidgets.QComboBox()
        self.option_align_same_func_call_params.addItems(['true','false'])
        self.option_align_same_func_call_params.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_same_func_call_params, 26, 1)
        #--------------------------------------------
        self.label_align_same_func_call_params_span = QtWidgets.QLabel(label("<hr>"+self.tr("The span for aligning function-call parameters for single line functions.", "align_same_func_call_params_span")+"\n\n"+self.tr("0: Don't align (default).", "align_same_func_call_params_span")))
        self.label_align_same_func_call_params_span.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_same_func_call_params_span, 27, 0, 1, 2)
        self.label_option_align_same_func_call_params_span = QtWidgets.QLabel("align_same_func_call_params_span")
        self.label_option_align_same_func_call_params_span.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_same_func_call_params_span, 28, 0)
        self.option_align_same_func_call_params_span =  QtWidgets.QSpinBox()
        self.option_align_same_func_call_params_span.setMinimum( 0)
        self.option_align_same_func_call_params_span.setMaximum( 5000)
        self.option_align_same_func_call_params_span.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_same_func_call_params_span, 28, 1)
        #--------------------------------------------
        self.label_align_same_func_call_params_thresh = QtWidgets.QLabel(label("<hr>"+self.tr("The threshold for aligning function-call parameters for single line\nfunctions.\nUse a negative number for absolute thresholds.", "align_same_func_call_params_thresh")+"\n\n"+self.tr("0: No limit (default).", "align_same_func_call_params_thresh")))
        self.label_align_same_func_call_params_thresh.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_same_func_call_params_thresh, 29, 0, 1, 2)
        self.label_option_align_same_func_call_params_thresh = QtWidgets.QLabel("align_same_func_call_params_thresh")
        self.label_option_align_same_func_call_params_thresh.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_same_func_call_params_thresh, 30, 0)
        self.option_align_same_func_call_params_thresh =  QtWidgets.QSpinBox()
        self.option_align_same_func_call_params_thresh.setMinimum( -1000)
        self.option_align_same_func_call_params_thresh.setMaximum( 5000)
        self.option_align_same_func_call_params_thresh.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_same_func_call_params_thresh, 30, 1)
        #--------------------------------------------
        self.label_align_var_def_span = QtWidgets.QLabel(label("<hr>"+self.tr("The span for aligning variable definitions.", "align_var_def_span")+"\n\n"+self.tr("0: Don't align (default).", "align_var_def_span")))
        self.label_align_var_def_span.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_var_def_span, 31, 0, 1, 2)
        self.label_option_align_var_def_span = QtWidgets.QLabel("align_var_def_span")
        self.label_option_align_var_def_span.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_var_def_span, 32, 0)
        self.option_align_var_def_span =  QtWidgets.QSpinBox()
        self.option_align_var_def_span.setMinimum( 0)
        self.option_align_var_def_span.setMaximum( 5000)
        self.option_align_var_def_span.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_var_def_span, 32, 1)
        #--------------------------------------------
        self.label_align_var_def_star_style = QtWidgets.QLabel(label("<hr>"+self.tr("How to consider (or treat) the '*' in the alignment of variable definitions.", "align_var_def_star_style")+"\n\n"+self.tr("0: Part of the type     'void *   foo;' (default)\n1: Part of the variable 'void     *foo;'\n2: Dangling             'void    *foo;'\nDangling: the '*' will not be taken into account when aligning.", "align_var_def_star_style")))
        self.label_align_var_def_star_style.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_var_def_star_style, 33, 0, 1, 2)
        self.label_option_align_var_def_star_style = QtWidgets.QLabel("align_var_def_star_style")
        self.label_option_align_var_def_star_style.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_var_def_star_style, 34, 0)
        self.option_align_var_def_star_style =  QtWidgets.QSpinBox()
        self.option_align_var_def_star_style.setMinimum( 0)
        self.option_align_var_def_star_style.setMaximum( 2)
        self.option_align_var_def_star_style.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_var_def_star_style, 34, 1)
        #--------------------------------------------
        self.label_align_var_def_amp_style = QtWidgets.QLabel(label("<hr>"+self.tr("How to consider (or treat) the '&' in the alignment of variable definitions.", "align_var_def_amp_style")+"\n\n"+self.tr("0: Part of the type     'long &   foo;' (default)\n1: Part of the variable 'long     &foo;'\n2: Dangling             'long    &foo;'\nDangling: the '&' will not be taken into account when aligning.", "align_var_def_amp_style")))
        self.label_align_var_def_amp_style.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_var_def_amp_style, 35, 0, 1, 2)
        self.label_option_align_var_def_amp_style = QtWidgets.QLabel("align_var_def_amp_style")
        self.label_option_align_var_def_amp_style.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_var_def_amp_style, 36, 0)
        self.option_align_var_def_amp_style =  QtWidgets.QSpinBox()
        self.option_align_var_def_amp_style.setMinimum( 0)
        self.option_align_var_def_amp_style.setMaximum( 2)
        self.option_align_var_def_amp_style.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_var_def_amp_style, 36, 1)
        #--------------------------------------------
        self.label_align_var_def_thresh = QtWidgets.QLabel(label("<hr>"+self.tr("The threshold for aligning variable definitions.\nUse a negative number for absolute thresholds.", "align_var_def_thresh")+"\n\n"+self.tr("0: No limit (default).", "align_var_def_thresh")))
        self.label_align_var_def_thresh.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_var_def_thresh, 37, 0, 1, 2)
        self.label_option_align_var_def_thresh = QtWidgets.QLabel("align_var_def_thresh")
        self.label_option_align_var_def_thresh.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_var_def_thresh, 38, 0)
        self.option_align_var_def_thresh =  QtWidgets.QSpinBox()
        self.option_align_var_def_thresh.setMinimum( -1000)
        self.option_align_var_def_thresh.setMaximum( 5000)
        self.option_align_var_def_thresh.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_var_def_thresh, 38, 1)
        #--------------------------------------------
        self.label_align_var_def_gap = QtWidgets.QLabel(label("<hr>"+self.tr("The gap for aligning variable definitions.", "align_var_def_gap")))
        self.label_align_var_def_gap.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_var_def_gap, 39, 0, 1, 2)
        self.label_option_align_var_def_gap = QtWidgets.QLabel("align_var_def_gap")
        self.label_option_align_var_def_gap.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_var_def_gap, 40, 0)
        self.option_align_var_def_gap =  QtWidgets.QSpinBox()
        self.option_align_var_def_gap.setMinimum( 0)
        self.option_align_var_def_gap.setMaximum( 16)
        self.option_align_var_def_gap.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_var_def_gap, 40, 1)
        #--------------------------------------------
        self.label_align_var_def_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to align the colon in struct bit fields.", "align_var_def_colon")))
        self.label_align_var_def_colon.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_var_def_colon, 41, 0, 1, 2)
        self.label_option_align_var_def_colon = QtWidgets.QLabel("align_var_def_colon")
        self.label_option_align_var_def_colon.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_var_def_colon, 42, 0)
        self.option_align_var_def_colon =  QtWidgets.QComboBox()
        self.option_align_var_def_colon.addItems(['true','false'])
        self.option_align_var_def_colon.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_var_def_colon, 42, 1)
        #--------------------------------------------
        self.label_align_var_def_colon_gap = QtWidgets.QLabel(label("<hr>"+self.tr("The gap for aligning the colon in struct bit fields.", "align_var_def_colon_gap")))
        self.label_align_var_def_colon_gap.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_var_def_colon_gap, 43, 0, 1, 2)
        self.label_option_align_var_def_colon_gap = QtWidgets.QLabel("align_var_def_colon_gap")
        self.label_option_align_var_def_colon_gap.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_var_def_colon_gap, 44, 0)
        self.option_align_var_def_colon_gap =  QtWidgets.QSpinBox()
        self.option_align_var_def_colon_gap.setMinimum( 0)
        self.option_align_var_def_colon_gap.setMaximum( 16)
        self.option_align_var_def_colon_gap.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_var_def_colon_gap, 44, 1)
        #--------------------------------------------
        self.label_align_var_def_attribute = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to align any attribute after the variable name.", "align_var_def_attribute")))
        self.label_align_var_def_attribute.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_var_def_attribute, 45, 0, 1, 2)
        self.label_option_align_var_def_attribute = QtWidgets.QLabel("align_var_def_attribute")
        self.label_option_align_var_def_attribute.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_var_def_attribute, 46, 0)
        self.option_align_var_def_attribute =  QtWidgets.QComboBox()
        self.option_align_var_def_attribute.addItems(['true','false'])
        self.option_align_var_def_attribute.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_var_def_attribute, 46, 1)
        #--------------------------------------------
        self.label_align_var_def_inline = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to align inline struct/enum/union variable definitions.", "align_var_def_inline")))
        self.label_align_var_def_inline.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_var_def_inline, 47, 0, 1, 2)
        self.label_option_align_var_def_inline = QtWidgets.QLabel("align_var_def_inline")
        self.label_option_align_var_def_inline.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_var_def_inline, 48, 0)
        self.option_align_var_def_inline =  QtWidgets.QComboBox()
        self.option_align_var_def_inline.addItems(['true','false'])
        self.option_align_var_def_inline.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_var_def_inline, 48, 1)
        #--------------------------------------------
        self.label_align_assign_span = QtWidgets.QLabel(label("<hr>"+self.tr("The span for aligning on '=' in assignments.", "align_assign_span")+"\n\n"+self.tr("0: Don't align (default).", "align_assign_span")))
        self.label_align_assign_span.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_assign_span, 49, 0, 1, 2)
        self.label_option_align_assign_span = QtWidgets.QLabel("align_assign_span")
        self.label_option_align_assign_span.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_assign_span, 50, 0)
        self.option_align_assign_span =  QtWidgets.QSpinBox()
        self.option_align_assign_span.setMinimum( 0)
        self.option_align_assign_span.setMaximum( 5000)
        self.option_align_assign_span.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_assign_span, 50, 1)
        #--------------------------------------------
        self.label_align_assign_func_proto_span = QtWidgets.QLabel(label("<hr>"+self.tr("The span for aligning on '=' in function prototype modifier.", "align_assign_func_proto_span")+"\n\n"+self.tr("0: Don't align (default).", "align_assign_func_proto_span")))
        self.label_align_assign_func_proto_span.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_assign_func_proto_span, 51, 0, 1, 2)
        self.label_option_align_assign_func_proto_span = QtWidgets.QLabel("align_assign_func_proto_span")
        self.label_option_align_assign_func_proto_span.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_assign_func_proto_span, 52, 0)
        self.option_align_assign_func_proto_span =  QtWidgets.QSpinBox()
        self.option_align_assign_func_proto_span.setMinimum( 0)
        self.option_align_assign_func_proto_span.setMaximum( 5000)
        self.option_align_assign_func_proto_span.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_assign_func_proto_span, 52, 1)
        #--------------------------------------------
        self.label_align_assign_thresh = QtWidgets.QLabel(label("<hr>"+self.tr("The threshold for aligning on '=' in assignments.\nUse a negative number for absolute thresholds.", "align_assign_thresh")+"\n\n"+self.tr("0: No limit (default).", "align_assign_thresh")))
        self.label_align_assign_thresh.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_assign_thresh, 53, 0, 1, 2)
        self.label_option_align_assign_thresh = QtWidgets.QLabel("align_assign_thresh")
        self.label_option_align_assign_thresh.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_assign_thresh, 54, 0)
        self.option_align_assign_thresh =  QtWidgets.QSpinBox()
        self.option_align_assign_thresh.setMinimum( -1000)
        self.option_align_assign_thresh.setMaximum( 5000)
        self.option_align_assign_thresh.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_assign_thresh, 54, 1)
        #--------------------------------------------
        self.label_align_assign_on_multi_var_defs = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to align on the left most assignment when multiple\ndefinitions are found on the same line.\nDepends on 'align_assign_span' and 'align_assign_thresh' settings.", "align_assign_on_multi_var_defs")))
        self.label_align_assign_on_multi_var_defs.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_assign_on_multi_var_defs, 55, 0, 1, 2)
        self.label_option_align_assign_on_multi_var_defs = QtWidgets.QLabel("align_assign_on_multi_var_defs")
        self.label_option_align_assign_on_multi_var_defs.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_assign_on_multi_var_defs, 56, 0)
        self.option_align_assign_on_multi_var_defs =  QtWidgets.QComboBox()
        self.option_align_assign_on_multi_var_defs.addItems(['true','false'])
        self.option_align_assign_on_multi_var_defs.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_assign_on_multi_var_defs, 56, 1)
        #--------------------------------------------
        self.label_align_braced_init_list_span = QtWidgets.QLabel(label("<hr>"+self.tr("The span for aligning on '{' in braced init list.", "align_braced_init_list_span")+"\n\n"+self.tr("0: Don't align (default).", "align_braced_init_list_span")))
        self.label_align_braced_init_list_span.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_braced_init_list_span, 57, 0, 1, 2)
        self.label_option_align_braced_init_list_span = QtWidgets.QLabel("align_braced_init_list_span")
        self.label_option_align_braced_init_list_span.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_braced_init_list_span, 58, 0)
        self.option_align_braced_init_list_span =  QtWidgets.QSpinBox()
        self.option_align_braced_init_list_span.setMinimum( 0)
        self.option_align_braced_init_list_span.setMaximum( 5000)
        self.option_align_braced_init_list_span.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_braced_init_list_span, 58, 1)
        #--------------------------------------------
        self.label_align_braced_init_list_thresh = QtWidgets.QLabel(label("<hr>"+self.tr("The threshold for aligning on '{' in braced init list.\nUse a negative number for absolute thresholds.", "align_braced_init_list_thresh")+"\n\n"+self.tr("0: No limit (default).", "align_braced_init_list_thresh")))
        self.label_align_braced_init_list_thresh.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_braced_init_list_thresh, 59, 0, 1, 2)
        self.label_option_align_braced_init_list_thresh = QtWidgets.QLabel("align_braced_init_list_thresh")
        self.label_option_align_braced_init_list_thresh.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_braced_init_list_thresh, 60, 0)
        self.option_align_braced_init_list_thresh =  QtWidgets.QSpinBox()
        self.option_align_braced_init_list_thresh.setMinimum( -1000)
        self.option_align_braced_init_list_thresh.setMaximum( 5000)
        self.option_align_braced_init_list_thresh.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_braced_init_list_thresh, 60, 1)
        #--------------------------------------------
        self.label_align_assign_decl_func = QtWidgets.QLabel(label("<hr>"+self.tr("How to apply align_assign_span to function declaration \"assignments\", i.e.\n'virtual void foo() = 0' or '~foo() = {default|delete}'.", "align_assign_decl_func")+"\n\n"+self.tr("0: Align with other assignments (default)\n1: Align with each other, ignoring regular assignments\n2: Don't align", "align_assign_decl_func")))
        self.label_align_assign_decl_func.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_assign_decl_func, 61, 0, 1, 2)
        self.label_option_align_assign_decl_func = QtWidgets.QLabel("align_assign_decl_func")
        self.label_option_align_assign_decl_func.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_assign_decl_func, 62, 0)
        self.option_align_assign_decl_func =  QtWidgets.QSpinBox()
        self.option_align_assign_decl_func.setMinimum( 0)
        self.option_align_assign_decl_func.setMaximum( 2)
        self.option_align_assign_decl_func.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_assign_decl_func, 62, 1)
        #--------------------------------------------
        self.label_align_enum_equ_span = QtWidgets.QLabel(label("<hr>"+self.tr("The span for aligning on '=' in enums.", "align_enum_equ_span")+"\n\n"+self.tr("0: Don't align (default).", "align_enum_equ_span")))
        self.label_align_enum_equ_span.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_enum_equ_span, 63, 0, 1, 2)
        self.label_option_align_enum_equ_span = QtWidgets.QLabel("align_enum_equ_span")
        self.label_option_align_enum_equ_span.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_enum_equ_span, 64, 0)
        self.option_align_enum_equ_span =  QtWidgets.QSpinBox()
        self.option_align_enum_equ_span.setMinimum( 0)
        self.option_align_enum_equ_span.setMaximum( 5000)
        self.option_align_enum_equ_span.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_enum_equ_span, 64, 1)
        #--------------------------------------------
        self.label_align_enum_equ_thresh = QtWidgets.QLabel(label("<hr>"+self.tr("The threshold for aligning on '=' in enums.\nUse a negative number for absolute thresholds.", "align_enum_equ_thresh")+"\n\n"+self.tr("0: no limit (default).", "align_enum_equ_thresh")))
        self.label_align_enum_equ_thresh.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_enum_equ_thresh, 65, 0, 1, 2)
        self.label_option_align_enum_equ_thresh = QtWidgets.QLabel("align_enum_equ_thresh")
        self.label_option_align_enum_equ_thresh.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_enum_equ_thresh, 66, 0)
        self.option_align_enum_equ_thresh =  QtWidgets.QSpinBox()
        self.option_align_enum_equ_thresh.setMinimum( -1000)
        self.option_align_enum_equ_thresh.setMaximum( 5000)
        self.option_align_enum_equ_thresh.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_enum_equ_thresh, 66, 1)
        #--------------------------------------------
        self.label_align_var_class_span = QtWidgets.QLabel(label("<hr>"+self.tr("The span for aligning class member definitions.", "align_var_class_span")+"\n\n"+self.tr("0: Don't align (default).", "align_var_class_span")))
        self.label_align_var_class_span.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_var_class_span, 67, 0, 1, 2)
        self.label_option_align_var_class_span = QtWidgets.QLabel("align_var_class_span")
        self.label_option_align_var_class_span.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_var_class_span, 68, 0)
        self.option_align_var_class_span =  QtWidgets.QSpinBox()
        self.option_align_var_class_span.setMinimum( 0)
        self.option_align_var_class_span.setMaximum( 5000)
        self.option_align_var_class_span.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_var_class_span, 68, 1)
        #--------------------------------------------
        self.label_align_var_class_thresh = QtWidgets.QLabel(label("<hr>"+self.tr("The threshold for aligning class member definitions.\nUse a negative number for absolute thresholds.", "align_var_class_thresh")+"\n\n"+self.tr("0: No limit (default).", "align_var_class_thresh")))
        self.label_align_var_class_thresh.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_var_class_thresh, 69, 0, 1, 2)
        self.label_option_align_var_class_thresh = QtWidgets.QLabel("align_var_class_thresh")
        self.label_option_align_var_class_thresh.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_var_class_thresh, 70, 0)
        self.option_align_var_class_thresh =  QtWidgets.QSpinBox()
        self.option_align_var_class_thresh.setMinimum( -1000)
        self.option_align_var_class_thresh.setMaximum( 5000)
        self.option_align_var_class_thresh.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_var_class_thresh, 70, 1)
        #--------------------------------------------
        self.label_align_var_class_gap = QtWidgets.QLabel(label("<hr>"+self.tr("The gap for aligning class member definitions.", "align_var_class_gap")))
        self.label_align_var_class_gap.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_var_class_gap, 71, 0, 1, 2)
        self.label_option_align_var_class_gap = QtWidgets.QLabel("align_var_class_gap")
        self.label_option_align_var_class_gap.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_var_class_gap, 72, 0)
        self.option_align_var_class_gap =  QtWidgets.QSpinBox()
        self.option_align_var_class_gap.setMinimum( 0)
        self.option_align_var_class_gap.setMaximum( 16)
        self.option_align_var_class_gap.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_var_class_gap, 72, 1)
        #--------------------------------------------
        self.label_align_var_struct_span = QtWidgets.QLabel(label("<hr>"+self.tr("The span for aligning struct/union member definitions.", "align_var_struct_span")+"\n\n"+self.tr("0: Don't align (default).", "align_var_struct_span")))
        self.label_align_var_struct_span.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_var_struct_span, 73, 0, 1, 2)
        self.label_option_align_var_struct_span = QtWidgets.QLabel("align_var_struct_span")
        self.label_option_align_var_struct_span.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_var_struct_span, 74, 0)
        self.option_align_var_struct_span =  QtWidgets.QSpinBox()
        self.option_align_var_struct_span.setMinimum( 0)
        self.option_align_var_struct_span.setMaximum( 5000)
        self.option_align_var_struct_span.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_var_struct_span, 74, 1)
        #--------------------------------------------
        self.label_align_var_struct_thresh = QtWidgets.QLabel(label("<hr>"+self.tr("The threshold for aligning struct/union member definitions.\nUse a negative number for absolute thresholds.", "align_var_struct_thresh")+"\n\n"+self.tr("0: No limit (default).", "align_var_struct_thresh")))
        self.label_align_var_struct_thresh.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_var_struct_thresh, 75, 0, 1, 2)
        self.label_option_align_var_struct_thresh = QtWidgets.QLabel("align_var_struct_thresh")
        self.label_option_align_var_struct_thresh.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_var_struct_thresh, 76, 0)
        self.option_align_var_struct_thresh =  QtWidgets.QSpinBox()
        self.option_align_var_struct_thresh.setMinimum( -1000)
        self.option_align_var_struct_thresh.setMaximum( 5000)
        self.option_align_var_struct_thresh.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_var_struct_thresh, 76, 1)
        #--------------------------------------------
        self.label_align_var_struct_gap = QtWidgets.QLabel(label("<hr>"+self.tr("The gap for aligning struct/union member definitions.", "align_var_struct_gap")))
        self.label_align_var_struct_gap.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_var_struct_gap, 77, 0, 1, 2)
        self.label_option_align_var_struct_gap = QtWidgets.QLabel("align_var_struct_gap")
        self.label_option_align_var_struct_gap.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_var_struct_gap, 78, 0)
        self.option_align_var_struct_gap =  QtWidgets.QSpinBox()
        self.option_align_var_struct_gap.setMinimum( 0)
        self.option_align_var_struct_gap.setMaximum( 16)
        self.option_align_var_struct_gap.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_var_struct_gap, 78, 1)
        #--------------------------------------------
        self.label_align_struct_init_span = QtWidgets.QLabel(label("<hr>"+self.tr("The span for aligning struct initializer values.", "align_struct_init_span")+"\n\n"+self.tr("0: Don't align (default).", "align_struct_init_span")))
        self.label_align_struct_init_span.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_struct_init_span, 79, 0, 1, 2)
        self.label_option_align_struct_init_span = QtWidgets.QLabel("align_struct_init_span")
        self.label_option_align_struct_init_span.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_struct_init_span, 80, 0)
        self.option_align_struct_init_span =  QtWidgets.QSpinBox()
        self.option_align_struct_init_span.setMinimum( 0)
        self.option_align_struct_init_span.setMaximum( 5000)
        self.option_align_struct_init_span.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_struct_init_span, 80, 1)
        #--------------------------------------------
        self.label_align_typedef_span = QtWidgets.QLabel(label("<hr>"+self.tr("The span for aligning single-line typedefs.", "align_typedef_span")+"\n\n"+self.tr("0: Don't align (default).", "align_typedef_span")))
        self.label_align_typedef_span.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_typedef_span, 81, 0, 1, 2)
        self.label_option_align_typedef_span = QtWidgets.QLabel("align_typedef_span")
        self.label_option_align_typedef_span.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_typedef_span, 82, 0)
        self.option_align_typedef_span =  QtWidgets.QSpinBox()
        self.option_align_typedef_span.setMinimum( 0)
        self.option_align_typedef_span.setMaximum( 16)
        self.option_align_typedef_span.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_typedef_span, 82, 1)
        #--------------------------------------------
        self.label_align_typedef_gap = QtWidgets.QLabel(label("<hr>"+self.tr("The minimum space between the type and the synonym of a typedef.", "align_typedef_gap")))
        self.label_align_typedef_gap.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_typedef_gap, 83, 0, 1, 2)
        self.label_option_align_typedef_gap = QtWidgets.QLabel("align_typedef_gap")
        self.label_option_align_typedef_gap.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_typedef_gap, 84, 0)
        self.option_align_typedef_gap =  QtWidgets.QSpinBox()
        self.option_align_typedef_gap.setMinimum( 0)
        self.option_align_typedef_gap.setMaximum( 16)
        self.option_align_typedef_gap.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_typedef_gap, 84, 1)
        #--------------------------------------------
        self.label_align_typedef_func = QtWidgets.QLabel(label("<hr>"+self.tr("How to align typedef'd functions with other typedefs.", "align_typedef_func")+"\n\n"+self.tr("0: Don't mix them at all (default)\n1: Align the open parenthesis with the types\n2: Align the function type name with the other type names", "align_typedef_func")))
        self.label_align_typedef_func.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_typedef_func, 85, 0, 1, 2)
        self.label_option_align_typedef_func = QtWidgets.QLabel("align_typedef_func")
        self.label_option_align_typedef_func.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_typedef_func, 86, 0)
        self.option_align_typedef_func =  QtWidgets.QSpinBox()
        self.option_align_typedef_func.setMinimum( 0)
        self.option_align_typedef_func.setMaximum( 2)
        self.option_align_typedef_func.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_typedef_func, 86, 1)
        #--------------------------------------------
        self.label_align_typedef_star_style = QtWidgets.QLabel(label("<hr>"+self.tr("How to consider (or treat) the '*' in the alignment of typedefs.", "align_typedef_star_style")+"\n\n"+self.tr("0: Part of the typedef type, 'typedef int * pint;' (default)\n1: Part of type name:        'typedef int   *pint;'\n2: Dangling:                 'typedef int  *pint;'\nDangling: the '*' will not be taken into account when aligning.", "align_typedef_star_style")))
        self.label_align_typedef_star_style.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_typedef_star_style, 87, 0, 1, 2)
        self.label_option_align_typedef_star_style = QtWidgets.QLabel("align_typedef_star_style")
        self.label_option_align_typedef_star_style.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_typedef_star_style, 88, 0)
        self.option_align_typedef_star_style =  QtWidgets.QSpinBox()
        self.option_align_typedef_star_style.setMinimum( 0)
        self.option_align_typedef_star_style.setMaximum( 2)
        self.option_align_typedef_star_style.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_typedef_star_style, 88, 1)
        #--------------------------------------------
        self.label_align_typedef_amp_style = QtWidgets.QLabel(label("<hr>"+self.tr("How to consider (or treat) the '&' in the alignment of typedefs.", "align_typedef_amp_style")+"\n\n"+self.tr("0: Part of the typedef type, 'typedef int & intref;' (default)\n1: Part of type name:        'typedef int   &intref;'\n2: Dangling:                 'typedef int  &intref;'\nDangling: the '&' will not be taken into account when aligning.", "align_typedef_amp_style")))
        self.label_align_typedef_amp_style.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_typedef_amp_style, 89, 0, 1, 2)
        self.label_option_align_typedef_amp_style = QtWidgets.QLabel("align_typedef_amp_style")
        self.label_option_align_typedef_amp_style.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_typedef_amp_style, 90, 0)
        self.option_align_typedef_amp_style =  QtWidgets.QSpinBox()
        self.option_align_typedef_amp_style.setMinimum( 0)
        self.option_align_typedef_amp_style.setMaximum( 2)
        self.option_align_typedef_amp_style.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_typedef_amp_style, 90, 1)
        #--------------------------------------------
        self.label_align_right_cmt_span = QtWidgets.QLabel(label("<hr>"+self.tr("The span for aligning comments that end lines.", "align_right_cmt_span")+"\n\n"+self.tr("0: Don't align (default).", "align_right_cmt_span")))
        self.label_align_right_cmt_span.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_right_cmt_span, 91, 0, 1, 2)
        self.label_option_align_right_cmt_span = QtWidgets.QLabel("align_right_cmt_span")
        self.label_option_align_right_cmt_span.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_right_cmt_span, 92, 0)
        self.option_align_right_cmt_span =  QtWidgets.QSpinBox()
        self.option_align_right_cmt_span.setMinimum( 0)
        self.option_align_right_cmt_span.setMaximum( 5000)
        self.option_align_right_cmt_span.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_right_cmt_span, 92, 1)
        #--------------------------------------------
        self.label_align_right_cmt_gap = QtWidgets.QLabel(label("<hr>"+self.tr("Minimum number of columns between preceding text and a trailing comment in\norder for the comment to qualify for being aligned. Must be non-zero to have\nan effect.", "align_right_cmt_gap")))
        self.label_align_right_cmt_gap.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_right_cmt_gap, 93, 0, 1, 2)
        self.label_option_align_right_cmt_gap = QtWidgets.QLabel("align_right_cmt_gap")
        self.label_option_align_right_cmt_gap.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_right_cmt_gap, 94, 0)
        self.option_align_right_cmt_gap =  QtWidgets.QSpinBox()
        self.option_align_right_cmt_gap.setMinimum( 0)
        self.option_align_right_cmt_gap.setMaximum( 16)
        self.option_align_right_cmt_gap.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_right_cmt_gap, 94, 1)
        #--------------------------------------------
        self.label_align_right_cmt_mix = QtWidgets.QLabel(label("<hr>"+self.tr("If aligning comments, whether to mix with comments after '}' and #endif with\nless than three spaces before the comment.", "align_right_cmt_mix")))
        self.label_align_right_cmt_mix.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_right_cmt_mix, 95, 0, 1, 2)
        self.label_option_align_right_cmt_mix = QtWidgets.QLabel("align_right_cmt_mix")
        self.label_option_align_right_cmt_mix.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_right_cmt_mix, 96, 0)
        self.option_align_right_cmt_mix =  QtWidgets.QComboBox()
        self.option_align_right_cmt_mix.addItems(['true','false'])
        self.option_align_right_cmt_mix.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_right_cmt_mix, 96, 1)
        #--------------------------------------------
        self.label_align_right_cmt_same_level = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to only align trailing comments that are at the same brace level.", "align_right_cmt_same_level")))
        self.label_align_right_cmt_same_level.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_right_cmt_same_level, 97, 0, 1, 2)
        self.label_option_align_right_cmt_same_level = QtWidgets.QLabel("align_right_cmt_same_level")
        self.label_option_align_right_cmt_same_level.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_right_cmt_same_level, 98, 0)
        self.option_align_right_cmt_same_level =  QtWidgets.QComboBox()
        self.option_align_right_cmt_same_level.addItems(['true','false'])
        self.option_align_right_cmt_same_level.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_right_cmt_same_level, 98, 1)
        #--------------------------------------------
        self.label_align_right_cmt_at_col = QtWidgets.QLabel(label("<hr>"+self.tr("Minimum column at which to align trailing comments. Comments which are\naligned beyond this column, but which can be aligned in a lesser column,\nmay be \"pulled in\".", "align_right_cmt_at_col")+"\n\n"+self.tr("0: Ignore (default).", "align_right_cmt_at_col")))
        self.label_align_right_cmt_at_col.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_right_cmt_at_col, 99, 0, 1, 2)
        self.label_option_align_right_cmt_at_col = QtWidgets.QLabel("align_right_cmt_at_col")
        self.label_option_align_right_cmt_at_col.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_right_cmt_at_col, 100, 0)
        self.option_align_right_cmt_at_col =  QtWidgets.QSpinBox()
        self.option_align_right_cmt_at_col.setMinimum( 0)
        self.option_align_right_cmt_at_col.setMaximum( 200)
        self.option_align_right_cmt_at_col.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_right_cmt_at_col, 100, 1)
        #--------------------------------------------
        self.label_align_func_proto_span = QtWidgets.QLabel(label("<hr>"+self.tr("The span for aligning function prototypes.", "align_func_proto_span")+"\n\n"+self.tr("0: Don't align (default).", "align_func_proto_span")))
        self.label_align_func_proto_span.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_func_proto_span, 101, 0, 1, 2)
        self.label_option_align_func_proto_span = QtWidgets.QLabel("align_func_proto_span")
        self.label_option_align_func_proto_span.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_func_proto_span, 102, 0)
        self.option_align_func_proto_span =  QtWidgets.QSpinBox()
        self.option_align_func_proto_span.setMinimum( 0)
        self.option_align_func_proto_span.setMaximum( 5000)
        self.option_align_func_proto_span.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_func_proto_span, 102, 1)
        #--------------------------------------------
        self.label_align_func_proto_span_ignore_cont_lines = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to ignore continuation lines when evaluating the number of\nnew lines for the function prototype alignment's span.", "align_func_proto_span_ignore_cont_lines")+"\n\n"+self.tr("false: continuation lines are part of the newlines count\ntrue:  continuation lines are not counted", "align_func_proto_span_ignore_cont_lines")))
        self.label_align_func_proto_span_ignore_cont_lines.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_func_proto_span_ignore_cont_lines, 103, 0, 1, 2)
        self.label_option_align_func_proto_span_ignore_cont_lines = QtWidgets.QLabel("align_func_proto_span_ignore_cont_lines")
        self.label_option_align_func_proto_span_ignore_cont_lines.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_func_proto_span_ignore_cont_lines, 104, 0)
        self.option_align_func_proto_span_ignore_cont_lines =  QtWidgets.QComboBox()
        self.option_align_func_proto_span_ignore_cont_lines.addItems(['true','false'])
        self.option_align_func_proto_span_ignore_cont_lines.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_func_proto_span_ignore_cont_lines, 104, 1)
        #--------------------------------------------
        self.label_align_func_proto_star_style = QtWidgets.QLabel(label("<hr>"+self.tr("How to consider (or treat) the '*' in the alignment of function prototypes.", "align_func_proto_star_style")+"\n\n"+self.tr("0: Part of the type     'void *   foo();' (default)\n1: Part of the function 'void     *foo();'\n2: Dangling             'void    *foo();'\nDangling: the '*' will not be taken into account when aligning.", "align_func_proto_star_style")))
        self.label_align_func_proto_star_style.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_func_proto_star_style, 105, 0, 1, 2)
        self.label_option_align_func_proto_star_style = QtWidgets.QLabel("align_func_proto_star_style")
        self.label_option_align_func_proto_star_style.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_func_proto_star_style, 106, 0)
        self.option_align_func_proto_star_style =  QtWidgets.QSpinBox()
        self.option_align_func_proto_star_style.setMinimum( 0)
        self.option_align_func_proto_star_style.setMaximum( 2)
        self.option_align_func_proto_star_style.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_func_proto_star_style, 106, 1)
        #--------------------------------------------
        self.label_align_func_proto_amp_style = QtWidgets.QLabel(label("<hr>"+self.tr("How to consider (or treat) the '&' in the alignment of function prototypes.", "align_func_proto_amp_style")+"\n\n"+self.tr("0: Part of the type     'long &   foo();' (default)\n1: Part of the function 'long     &foo();'\n2: Dangling             'long    &foo();'\nDangling: the '&' will not be taken into account when aligning.", "align_func_proto_amp_style")))
        self.label_align_func_proto_amp_style.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_func_proto_amp_style, 107, 0, 1, 2)
        self.label_option_align_func_proto_amp_style = QtWidgets.QLabel("align_func_proto_amp_style")
        self.label_option_align_func_proto_amp_style.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_func_proto_amp_style, 108, 0)
        self.option_align_func_proto_amp_style =  QtWidgets.QSpinBox()
        self.option_align_func_proto_amp_style.setMinimum( 0)
        self.option_align_func_proto_amp_style.setMaximum( 2)
        self.option_align_func_proto_amp_style.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_func_proto_amp_style, 108, 1)
        #--------------------------------------------
        self.label_align_func_proto_thresh = QtWidgets.QLabel(label("<hr>"+self.tr("The threshold for aligning function prototypes.\nUse a negative number for absolute thresholds.", "align_func_proto_thresh")+"\n\n"+self.tr("0: No limit (default).", "align_func_proto_thresh")))
        self.label_align_func_proto_thresh.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_func_proto_thresh, 109, 0, 1, 2)
        self.label_option_align_func_proto_thresh = QtWidgets.QLabel("align_func_proto_thresh")
        self.label_option_align_func_proto_thresh.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_func_proto_thresh, 110, 0)
        self.option_align_func_proto_thresh =  QtWidgets.QSpinBox()
        self.option_align_func_proto_thresh.setMinimum( -1000)
        self.option_align_func_proto_thresh.setMaximum( 5000)
        self.option_align_func_proto_thresh.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_func_proto_thresh, 110, 1)
        #--------------------------------------------
        self.label_align_func_proto_gap = QtWidgets.QLabel(label("<hr>"+self.tr("Minimum gap between the return type and the function name.", "align_func_proto_gap")))
        self.label_align_func_proto_gap.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_func_proto_gap, 111, 0, 1, 2)
        self.label_option_align_func_proto_gap = QtWidgets.QLabel("align_func_proto_gap")
        self.label_option_align_func_proto_gap.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_func_proto_gap, 112, 0)
        self.option_align_func_proto_gap =  QtWidgets.QSpinBox()
        self.option_align_func_proto_gap.setMinimum( 0)
        self.option_align_func_proto_gap.setMaximum( 16)
        self.option_align_func_proto_gap.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_func_proto_gap, 112, 1)
        #--------------------------------------------
        self.label_align_on_operator = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to align function prototypes on the 'operator' keyword instead of\nwhat follows.", "align_on_operator")))
        self.label_align_on_operator.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_on_operator, 113, 0, 1, 2)
        self.label_option_align_on_operator = QtWidgets.QLabel("align_on_operator")
        self.label_option_align_on_operator.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_on_operator, 114, 0)
        self.option_align_on_operator =  QtWidgets.QComboBox()
        self.option_align_on_operator.addItems(['true','false'])
        self.option_align_on_operator.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_on_operator, 114, 1)
        #--------------------------------------------
        self.label_align_mix_var_proto = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to mix aligning prototype and variable declarations. If true,\nalign_var_def_XXX options are used instead of align_func_proto_XXX options.", "align_mix_var_proto")))
        self.label_align_mix_var_proto.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_mix_var_proto, 115, 0, 1, 2)
        self.label_option_align_mix_var_proto = QtWidgets.QLabel("align_mix_var_proto")
        self.label_option_align_mix_var_proto.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_mix_var_proto, 116, 0)
        self.option_align_mix_var_proto =  QtWidgets.QComboBox()
        self.option_align_mix_var_proto.addItems(['true','false'])
        self.option_align_mix_var_proto.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_mix_var_proto, 116, 1)
        #--------------------------------------------
        self.label_align_single_line_func = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to align single-line functions with function prototypes.\nUses align_func_proto_span.", "align_single_line_func")))
        self.label_align_single_line_func.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_single_line_func, 117, 0, 1, 2)
        self.label_option_align_single_line_func = QtWidgets.QLabel("align_single_line_func")
        self.label_option_align_single_line_func.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_single_line_func, 118, 0)
        self.option_align_single_line_func =  QtWidgets.QComboBox()
        self.option_align_single_line_func.addItems(['true','false'])
        self.option_align_single_line_func.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_single_line_func, 118, 1)
        #--------------------------------------------
        self.label_align_single_line_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to align the open brace of single-line functions.\nRequires align_single_line_func=true. Uses align_func_proto_span.", "align_single_line_brace")))
        self.label_align_single_line_brace.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_single_line_brace, 119, 0, 1, 2)
        self.label_option_align_single_line_brace = QtWidgets.QLabel("align_single_line_brace")
        self.label_option_align_single_line_brace.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_single_line_brace, 120, 0)
        self.option_align_single_line_brace =  QtWidgets.QComboBox()
        self.option_align_single_line_brace.addItems(['true','false'])
        self.option_align_single_line_brace.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_single_line_brace, 120, 1)
        #--------------------------------------------
        self.label_align_single_line_brace_gap = QtWidgets.QLabel(label("<hr>"+self.tr("Gap for align_single_line_brace.", "align_single_line_brace_gap")))
        self.label_align_single_line_brace_gap.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_single_line_brace_gap, 121, 0, 1, 2)
        self.label_option_align_single_line_brace_gap = QtWidgets.QLabel("align_single_line_brace_gap")
        self.label_option_align_single_line_brace_gap.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_single_line_brace_gap, 122, 0)
        self.option_align_single_line_brace_gap =  QtWidgets.QSpinBox()
        self.option_align_single_line_brace_gap.setMinimum( 0)
        self.option_align_single_line_brace_gap.setMaximum( 16)
        self.option_align_single_line_brace_gap.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_single_line_brace_gap, 122, 1)
        #--------------------------------------------
        self.label_align_oc_msg_spec_span = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) The span for aligning Objective-C message specifications.", "align_oc_msg_spec_span")+"\n\n"+self.tr("0: Don't align (default).", "align_oc_msg_spec_span")))
        self.label_align_oc_msg_spec_span.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_oc_msg_spec_span, 123, 0, 1, 2)
        self.label_option_align_oc_msg_spec_span = QtWidgets.QLabel("align_oc_msg_spec_span")
        self.label_option_align_oc_msg_spec_span.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_oc_msg_spec_span, 124, 0)
        self.option_align_oc_msg_spec_span =  QtWidgets.QSpinBox()
        self.option_align_oc_msg_spec_span.setMinimum( 0)
        self.option_align_oc_msg_spec_span.setMaximum( 5000)
        self.option_align_oc_msg_spec_span.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_oc_msg_spec_span, 124, 1)
        #--------------------------------------------
        self.label_align_nl_cont = QtWidgets.QLabel(label("<hr>"+self.tr("Whether and how to align backslashes that split a macro onto multiple lines.\nThis will not work right if the macro contains a multi-line comment.", "align_nl_cont")+"\n\n"+self.tr("0: Do nothing (default)\n1: Align the backslashes in the column at the end of the longest line\n2: Align with the backslash that is farthest to the left, or, if that\n   backslash is farther left than the end of the longest line, at the end of\n   the longest line\n3: Align with the backslash that is farthest to the right", "align_nl_cont")))
        self.label_align_nl_cont.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_nl_cont, 125, 0, 1, 2)
        self.label_option_align_nl_cont = QtWidgets.QLabel("align_nl_cont")
        self.label_option_align_nl_cont.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_nl_cont, 126, 0)
        self.option_align_nl_cont =  QtWidgets.QSpinBox()
        self.option_align_nl_cont.setMinimum( 0)
        self.option_align_nl_cont.setMaximum( 3)
        self.option_align_nl_cont.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_nl_cont, 126, 1)
        #--------------------------------------------
        self.label_align_nl_cont_spaces = QtWidgets.QLabel(label("<hr>"+self.tr("The minimum number of spaces between the end of a line and its continuation\nbackslash. Requires align_nl_cont.", "align_nl_cont_spaces")))
        self.label_align_nl_cont_spaces.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_nl_cont_spaces, 127, 0, 1, 2)
        self.label_option_align_nl_cont_spaces = QtWidgets.QLabel("align_nl_cont_spaces")
        self.label_option_align_nl_cont_spaces.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_nl_cont_spaces, 128, 0)
        self.option_align_nl_cont_spaces =  QtWidgets.QSpinBox()
        self.option_align_nl_cont_spaces.setMinimum( 0)
        self.option_align_nl_cont_spaces.setMaximum( 16)
        self.option_align_nl_cont_spaces.setValue(1)
        self.group_page_layout_8.addWidget(self.option_align_nl_cont_spaces, 128, 1)
        #--------------------------------------------
        self.label_align_pp_define_together = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to align macro functions and variables together.", "align_pp_define_together")))
        self.label_align_pp_define_together.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_pp_define_together, 129, 0, 1, 2)
        self.label_option_align_pp_define_together = QtWidgets.QLabel("align_pp_define_together")
        self.label_option_align_pp_define_together.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_pp_define_together, 130, 0)
        self.option_align_pp_define_together =  QtWidgets.QComboBox()
        self.option_align_pp_define_together.addItems(['true','false'])
        self.option_align_pp_define_together.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_pp_define_together, 130, 1)
        #--------------------------------------------
        self.label_align_pp_define_span = QtWidgets.QLabel(label("<hr>"+self.tr("The span for aligning on '#define' bodies.", "align_pp_define_span")+"\n\n"+self.tr("=0: Don't align (default)\n>0: Number of lines (including comments) between blocks", "align_pp_define_span")))
        self.label_align_pp_define_span.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_pp_define_span, 131, 0, 1, 2)
        self.label_option_align_pp_define_span = QtWidgets.QLabel("align_pp_define_span")
        self.label_option_align_pp_define_span.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_pp_define_span, 132, 0)
        self.option_align_pp_define_span =  QtWidgets.QSpinBox()
        self.option_align_pp_define_span.setMinimum( 0)
        self.option_align_pp_define_span.setMaximum( 5000)
        self.option_align_pp_define_span.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_pp_define_span, 132, 1)
        #--------------------------------------------
        self.label_align_pp_define_gap = QtWidgets.QLabel(label("<hr>"+self.tr("The minimum space between label and value of a preprocessor define.", "align_pp_define_gap")))
        self.label_align_pp_define_gap.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_pp_define_gap, 133, 0, 1, 2)
        self.label_option_align_pp_define_gap = QtWidgets.QLabel("align_pp_define_gap")
        self.label_option_align_pp_define_gap.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_pp_define_gap, 134, 0)
        self.option_align_pp_define_gap =  QtWidgets.QSpinBox()
        self.option_align_pp_define_gap.setMinimum( 0)
        self.option_align_pp_define_gap.setMaximum( 16)
        self.option_align_pp_define_gap.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_pp_define_gap, 134, 1)
        #--------------------------------------------
        self.label_align_left_shift = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to align lines that start with '<<' with previous '<<'.", "align_left_shift")))
        self.label_align_left_shift.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_left_shift, 135, 0, 1, 2)
        self.label_option_align_left_shift = QtWidgets.QLabel("align_left_shift")
        self.label_option_align_left_shift.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_left_shift, 136, 0)
        self.option_align_left_shift =  QtWidgets.QComboBox()
        self.option_align_left_shift.addItems(['true','false'])
        self.option_align_left_shift.setCurrentText("true")
        self.group_page_layout_8.addWidget(self.option_align_left_shift, 136, 1)
        #--------------------------------------------
        self.label_align_eigen_comma_init = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to align comma-separated statements following '<<' (as used to\ninitialize Eigen matrices).", "align_eigen_comma_init")))
        self.label_align_eigen_comma_init.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_eigen_comma_init, 137, 0, 1, 2)
        self.label_option_align_eigen_comma_init = QtWidgets.QLabel("align_eigen_comma_init")
        self.label_option_align_eigen_comma_init.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_eigen_comma_init, 138, 0)
        self.option_align_eigen_comma_init =  QtWidgets.QComboBox()
        self.option_align_eigen_comma_init.addItems(['true','false'])
        self.option_align_eigen_comma_init.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_eigen_comma_init, 138, 1)
        #--------------------------------------------
        self.label_align_asm_colon = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to align text after 'asm volatile ()' colons.", "align_asm_colon")))
        self.label_align_asm_colon.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_asm_colon, 139, 0, 1, 2)
        self.label_option_align_asm_colon = QtWidgets.QLabel("align_asm_colon")
        self.label_option_align_asm_colon.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_asm_colon, 140, 0)
        self.option_align_asm_colon =  QtWidgets.QComboBox()
        self.option_align_asm_colon.addItems(['true','false'])
        self.option_align_asm_colon.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_asm_colon, 140, 1)
        #--------------------------------------------
        self.label_align_oc_msg_colon_span = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Span for aligning parameters in an Objective-C message call\non the ':'.", "align_oc_msg_colon_span")+"\n\n"+self.tr("0: Don't align.", "align_oc_msg_colon_span")))
        self.label_align_oc_msg_colon_span.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_oc_msg_colon_span, 141, 0, 1, 2)
        self.label_option_align_oc_msg_colon_span = QtWidgets.QLabel("align_oc_msg_colon_span")
        self.label_option_align_oc_msg_colon_span.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_oc_msg_colon_span, 142, 0)
        self.option_align_oc_msg_colon_span =  QtWidgets.QSpinBox()
        self.option_align_oc_msg_colon_span.setMinimum( 0)
        self.option_align_oc_msg_colon_span.setMaximum( 5000)
        self.option_align_oc_msg_colon_span.setValue(0)
        self.group_page_layout_8.addWidget(self.option_align_oc_msg_colon_span, 142, 1)
        #--------------------------------------------
        self.label_align_oc_msg_colon_first = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Whether to always align with the first parameter, even if it is too\nshort.", "align_oc_msg_colon_first")))
        self.label_align_oc_msg_colon_first.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_oc_msg_colon_first, 143, 0, 1, 2)
        self.label_option_align_oc_msg_colon_first = QtWidgets.QLabel("align_oc_msg_colon_first")
        self.label_option_align_oc_msg_colon_first.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_oc_msg_colon_first, 144, 0)
        self.option_align_oc_msg_colon_first =  QtWidgets.QComboBox()
        self.option_align_oc_msg_colon_first.addItems(['true','false'])
        self.option_align_oc_msg_colon_first.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_oc_msg_colon_first, 144, 1)
        #--------------------------------------------
        self.label_align_oc_decl_colon = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Whether to align parameters in an Objective-C '+' or '-' declaration\non the ':'.", "align_oc_decl_colon")))
        self.label_align_oc_decl_colon.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_oc_decl_colon, 145, 0, 1, 2)
        self.label_option_align_oc_decl_colon = QtWidgets.QLabel("align_oc_decl_colon")
        self.label_option_align_oc_decl_colon.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_oc_decl_colon, 146, 0)
        self.option_align_oc_decl_colon =  QtWidgets.QComboBox()
        self.option_align_oc_decl_colon.addItems(['true','false'])
        self.option_align_oc_decl_colon.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_oc_decl_colon, 146, 1)
        #--------------------------------------------
        self.label_align_oc_msg_colon_xcode_like = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Whether to not align parameters in an Objectve-C message call if first\ncolon is not on next line of the message call (the same way Xcode does\nalignment)", "align_oc_msg_colon_xcode_like")))
        self.label_align_oc_msg_colon_xcode_like.setWordWrap(True)
        self.group_page_layout_8.addWidget(self.label_align_oc_msg_colon_xcode_like, 147, 0, 1, 2)
        self.label_option_align_oc_msg_colon_xcode_like = QtWidgets.QLabel("align_oc_msg_colon_xcode_like")
        self.label_option_align_oc_msg_colon_xcode_like.setFont(font_name)
        self.group_page_layout_8.addWidget(self.label_option_align_oc_msg_colon_xcode_like, 148, 0)
        self.option_align_oc_msg_colon_xcode_like =  QtWidgets.QComboBox()
        self.option_align_oc_msg_colon_xcode_like.addItems(['true','false'])
        self.option_align_oc_msg_colon_xcode_like.setCurrentText("false")
        self.group_page_layout_8.addWidget(self.option_align_oc_msg_colon_xcode_like, 148, 1)
        self.group_page_layout_8.addItem(QtWidgets.QSpacerItem(10, 10, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding), 149,0)
        self.scroll_group_page_8 = QtWidgets.QScrollArea()
        self.scroll_group_page_8.setWidget(self.group_page_8)
        self.scroll_group_page_8.setWidgetResizable(True)
        self.addTab(self.scroll_group_page_8, self.tr("Code alignment options (not left column spaces/tabs)"))
        #================== Comment modification options ====================================================
        self.group_page_9 = QtWidgets.QWidget()
        self.group_page_layout_9 = QtWidgets.QGridLayout(self.group_page_9)
        self.group_page_layout_9.addWidget(QtWidgets.QLabel(label(self.tr("Comment modification options help"))), 0, 0, 1, 2)
        #--------------------------------------------
        self.label_cmt_width = QtWidgets.QLabel(label("<hr>"+self.tr("Try to wrap comments at N columns.", "cmt_width")))
        self.label_cmt_width.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_width, 1, 0, 1, 2)
        self.label_option_cmt_width = QtWidgets.QLabel("cmt_width")
        self.label_option_cmt_width.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_width, 2, 0)
        self.option_cmt_width =  QtWidgets.QSpinBox()
        self.option_cmt_width.setMinimum( 0)
        self.option_cmt_width.setMaximum( 256)
        self.option_cmt_width.setValue(0)
        self.group_page_layout_9.addWidget(self.option_cmt_width, 2, 1)
        #--------------------------------------------
        self.label_cmt_reflow_mode = QtWidgets.QLabel(label("<hr>"+self.tr("How to reflow comments.", "cmt_reflow_mode")+"\n\n"+self.tr("0: No reflowing (apart from the line wrapping due to cmt_width) (default)\n1: No touching at all\n2: Full reflow (enable cmt_indent_multi for indent with line wrapping due to cmt_width)", "cmt_reflow_mode")))
        self.label_cmt_reflow_mode.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_reflow_mode, 3, 0, 1, 2)
        self.label_option_cmt_reflow_mode = QtWidgets.QLabel("cmt_reflow_mode")
        self.label_option_cmt_reflow_mode.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_reflow_mode, 4, 0)
        self.option_cmt_reflow_mode =  QtWidgets.QSpinBox()
        self.option_cmt_reflow_mode.setMinimum( 0)
        self.option_cmt_reflow_mode.setMaximum( 2)
        self.option_cmt_reflow_mode.setValue(0)
        self.group_page_layout_9.addWidget(self.option_cmt_reflow_mode, 4, 1)
        #--------------------------------------------
        self.label_cmt_reflow_fold_regex_file = QtWidgets.QLabel(label("<hr>"+self.tr("Path to a file that contains regular expressions describing patterns for\nwhich the end of one line and the beginning of the next will be folded into\nthe same sentence or paragraph during full comment reflow. The regular\nexpressions are described using ECMAScript syntax. The syntax for this\nspecification is as follows, where \"...\" indicates the custom regular\nexpression and \"n\" indicates the nth end_of_prev_line_regex and\nbeg_of_next_line_regex regular expression pair:", "cmt_reflow_fold_regex_file")+"\n\n"+self.tr("end_of_prev_line_regex[1] = \"...$\"\nbeg_of_next_line_regex[1] = \"^...\"\nend_of_prev_line_regex[2] = \"...$\"\nbeg_of_next_line_regex[2] = \"^...\"\n            .\n            .\n            .\nend_of_prev_line_regex[n] = \"...$\"\nbeg_of_next_line_regex[n] = \"^...\"", "cmt_reflow_fold_regex_file")+"\n\n"+self.tr("Note that use of this option overrides the default reflow fold regular\nexpressions, which are internally defined as follows:", "cmt_reflow_fold_regex_file")+"\n\n"+self.tr("end_of_prev_line_regex[1] = \"[\\w,\\]\\)]$\"\nbeg_of_next_line_regex[1] = \"^[\\w,\\[\\(]\"\nend_of_prev_line_regex[2] = \"\\.$\"\nbeg_of_next_line_regex[2] = \"^[A-Z]\"", "cmt_reflow_fold_regex_file")))
        self.label_cmt_reflow_fold_regex_file.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_reflow_fold_regex_file, 5, 0, 1, 2)
        self.label_option_cmt_reflow_fold_regex_file = QtWidgets.QLabel("cmt_reflow_fold_regex_file")
        self.label_option_cmt_reflow_fold_regex_file.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_reflow_fold_regex_file, 6, 0)
        self.option_cmt_reflow_fold_regex_file =  QtWidgets.QLineEdit("")
        self.group_page_layout_9.addWidget(self.option_cmt_reflow_fold_regex_file, 6, 1)
        #--------------------------------------------
        self.label_cmt_reflow_indent_to_paragraph_start = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent wrapped lines to the start of the encompassing paragraph\nduring full comment reflow (cmt_reflow_mode = 2). Overrides the value\nspecified by cmt_sp_after_star_cont.", "cmt_reflow_indent_to_paragraph_start")+"\n\n"+self.tr("Note that cmt_align_doxygen_javadoc_tags overrides this option for\nparagraphs associated with javadoc tags", "cmt_reflow_indent_to_paragraph_start")))
        self.label_cmt_reflow_indent_to_paragraph_start.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_reflow_indent_to_paragraph_start, 7, 0, 1, 2)
        self.label_option_cmt_reflow_indent_to_paragraph_start = QtWidgets.QLabel("cmt_reflow_indent_to_paragraph_start")
        self.label_option_cmt_reflow_indent_to_paragraph_start.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_reflow_indent_to_paragraph_start, 8, 0)
        self.option_cmt_reflow_indent_to_paragraph_start =  QtWidgets.QComboBox()
        self.option_cmt_reflow_indent_to_paragraph_start.addItems(['true','false'])
        self.option_cmt_reflow_indent_to_paragraph_start.setCurrentText("false")
        self.group_page_layout_9.addWidget(self.option_cmt_reflow_indent_to_paragraph_start, 8, 1)
        #--------------------------------------------
        self.label_cmt_convert_tab_to_spaces = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to convert all tabs to spaces in comments. If false, tabs in\ncomments are left alone, unless used for indenting.", "cmt_convert_tab_to_spaces")))
        self.label_cmt_convert_tab_to_spaces.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_convert_tab_to_spaces, 9, 0, 1, 2)
        self.label_option_cmt_convert_tab_to_spaces = QtWidgets.QLabel("cmt_convert_tab_to_spaces")
        self.label_option_cmt_convert_tab_to_spaces.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_convert_tab_to_spaces, 10, 0)
        self.option_cmt_convert_tab_to_spaces =  QtWidgets.QComboBox()
        self.option_cmt_convert_tab_to_spaces.addItems(['true','false'])
        self.option_cmt_convert_tab_to_spaces.setCurrentText("false")
        self.group_page_layout_9.addWidget(self.option_cmt_convert_tab_to_spaces, 10, 1)
        #--------------------------------------------
        self.label_cmt_indent_multi = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to apply changes to multi-line comments, including cmt_width,\nkeyword substitution and leading chars.", "cmt_indent_multi")))
        self.label_cmt_indent_multi.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_indent_multi, 11, 0, 1, 2)
        self.label_option_cmt_indent_multi = QtWidgets.QLabel("cmt_indent_multi")
        self.label_option_cmt_indent_multi.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_indent_multi, 12, 0)
        self.option_cmt_indent_multi =  QtWidgets.QComboBox()
        self.option_cmt_indent_multi.addItems(['true','false'])
        self.option_cmt_indent_multi.setCurrentText("true")
        self.group_page_layout_9.addWidget(self.option_cmt_indent_multi, 12, 1)
        #--------------------------------------------
        self.label_cmt_align_doxygen_javadoc_tags = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to align doxygen javadoc-style tags ('@param', '@return', etc.)\nand corresponding fields such that groups of consecutive block tags,\nparameter names, and descriptions align with one another. Overrides that\nwhich is specified by the cmt_sp_after_star_cont. If cmt_width > 0, it may\nbe necessary to enable cmt_indent_multi and set cmt_reflow_mode = 2\nin order to achieve the desired alignment for line-wrapping.", "cmt_align_doxygen_javadoc_tags")))
        self.label_cmt_align_doxygen_javadoc_tags.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_align_doxygen_javadoc_tags, 13, 0, 1, 2)
        self.label_option_cmt_align_doxygen_javadoc_tags = QtWidgets.QLabel("cmt_align_doxygen_javadoc_tags")
        self.label_option_cmt_align_doxygen_javadoc_tags.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_align_doxygen_javadoc_tags, 14, 0)
        self.option_cmt_align_doxygen_javadoc_tags =  QtWidgets.QComboBox()
        self.option_cmt_align_doxygen_javadoc_tags.addItems(['true','false'])
        self.option_cmt_align_doxygen_javadoc_tags.setCurrentText("false")
        self.group_page_layout_9.addWidget(self.option_cmt_align_doxygen_javadoc_tags, 14, 1)
        #--------------------------------------------
        self.label_cmt_sp_before_doxygen_javadoc_tags = QtWidgets.QLabel(label("<hr>"+self.tr("The number of spaces to insert after the star and before doxygen\njavadoc-style tags (@param, @return, etc). Requires enabling\ncmt_align_doxygen_javadoc_tags. Overrides that which is specified by the\ncmt_sp_after_star_cont.", "cmt_sp_before_doxygen_javadoc_tags")))
        self.label_cmt_sp_before_doxygen_javadoc_tags.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_sp_before_doxygen_javadoc_tags, 15, 0, 1, 2)
        self.label_option_cmt_sp_before_doxygen_javadoc_tags = QtWidgets.QLabel("cmt_sp_before_doxygen_javadoc_tags")
        self.label_option_cmt_sp_before_doxygen_javadoc_tags.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_sp_before_doxygen_javadoc_tags, 16, 0)
        self.option_cmt_sp_before_doxygen_javadoc_tags =  QtWidgets.QSpinBox()
        self.option_cmt_sp_before_doxygen_javadoc_tags.setMinimum( 0)
        self.option_cmt_sp_before_doxygen_javadoc_tags.setMaximum( 16)
        self.option_cmt_sp_before_doxygen_javadoc_tags.setValue(1)
        self.group_page_layout_9.addWidget(self.option_cmt_sp_before_doxygen_javadoc_tags, 16, 1)
        #--------------------------------------------
        self.label_cmt_trailing_single_line_c_to_cpp = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to change trailing, single-line c-comments into cpp-comments.", "cmt_trailing_single_line_c_to_cpp")))
        self.label_cmt_trailing_single_line_c_to_cpp.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_trailing_single_line_c_to_cpp, 17, 0, 1, 2)
        self.label_option_cmt_trailing_single_line_c_to_cpp = QtWidgets.QLabel("cmt_trailing_single_line_c_to_cpp")
        self.label_option_cmt_trailing_single_line_c_to_cpp.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_trailing_single_line_c_to_cpp, 18, 0)
        self.option_cmt_trailing_single_line_c_to_cpp =  QtWidgets.QComboBox()
        self.option_cmt_trailing_single_line_c_to_cpp.addItems(['true','false'])
        self.option_cmt_trailing_single_line_c_to_cpp.setCurrentText("false")
        self.group_page_layout_9.addWidget(self.option_cmt_trailing_single_line_c_to_cpp, 18, 1)
        #--------------------------------------------
        self.label_cmt_c_group = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to group c-comments that look like they are in a block.", "cmt_c_group")))
        self.label_cmt_c_group.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_c_group, 19, 0, 1, 2)
        self.label_option_cmt_c_group = QtWidgets.QLabel("cmt_c_group")
        self.label_option_cmt_c_group.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_c_group, 20, 0)
        self.option_cmt_c_group =  QtWidgets.QComboBox()
        self.option_cmt_c_group.addItems(['true','false'])
        self.option_cmt_c_group.setCurrentText("false")
        self.group_page_layout_9.addWidget(self.option_cmt_c_group, 20, 1)
        #--------------------------------------------
        self.label_cmt_c_nl_start = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to put an empty '/*' on the first line of the combined c-comment.", "cmt_c_nl_start")))
        self.label_cmt_c_nl_start.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_c_nl_start, 21, 0, 1, 2)
        self.label_option_cmt_c_nl_start = QtWidgets.QLabel("cmt_c_nl_start")
        self.label_option_cmt_c_nl_start.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_c_nl_start, 22, 0)
        self.option_cmt_c_nl_start =  QtWidgets.QComboBox()
        self.option_cmt_c_nl_start.addItems(['true','false'])
        self.option_cmt_c_nl_start.setCurrentText("false")
        self.group_page_layout_9.addWidget(self.option_cmt_c_nl_start, 22, 1)
        #--------------------------------------------
        self.label_cmt_c_nl_end = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline before the closing '*/' of the combined c-comment.", "cmt_c_nl_end")))
        self.label_cmt_c_nl_end.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_c_nl_end, 23, 0, 1, 2)
        self.label_option_cmt_c_nl_end = QtWidgets.QLabel("cmt_c_nl_end")
        self.label_option_cmt_c_nl_end.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_c_nl_end, 24, 0)
        self.option_cmt_c_nl_end =  QtWidgets.QComboBox()
        self.option_cmt_c_nl_end.addItems(['true','false'])
        self.option_cmt_c_nl_end.setCurrentText("false")
        self.group_page_layout_9.addWidget(self.option_cmt_c_nl_end, 24, 1)
        #--------------------------------------------
        self.label_cmt_cpp_to_c = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to change cpp-comments into c-comments.", "cmt_cpp_to_c")))
        self.label_cmt_cpp_to_c.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_cpp_to_c, 25, 0, 1, 2)
        self.label_option_cmt_cpp_to_c = QtWidgets.QLabel("cmt_cpp_to_c")
        self.label_option_cmt_cpp_to_c.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_cpp_to_c, 26, 0)
        self.option_cmt_cpp_to_c =  QtWidgets.QComboBox()
        self.option_cmt_cpp_to_c.addItems(['true','false'])
        self.option_cmt_cpp_to_c.setCurrentText("false")
        self.group_page_layout_9.addWidget(self.option_cmt_cpp_to_c, 26, 1)
        #--------------------------------------------
        self.label_cmt_cpp_group = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to group cpp-comments that look like they are in a block. Only\nmeaningful if cmt_cpp_to_c=true.", "cmt_cpp_group")))
        self.label_cmt_cpp_group.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_cpp_group, 27, 0, 1, 2)
        self.label_option_cmt_cpp_group = QtWidgets.QLabel("cmt_cpp_group")
        self.label_option_cmt_cpp_group.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_cpp_group, 28, 0)
        self.option_cmt_cpp_group =  QtWidgets.QComboBox()
        self.option_cmt_cpp_group.addItems(['true','false'])
        self.option_cmt_cpp_group.setCurrentText("false")
        self.group_page_layout_9.addWidget(self.option_cmt_cpp_group, 28, 1)
        #--------------------------------------------
        self.label_cmt_cpp_nl_start = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to put an empty '/*' on the first line of the combined cpp-comment\nwhen converting to a c-comment.", "cmt_cpp_nl_start")+"\n\n"+self.tr("Requires cmt_cpp_to_c=true and cmt_cpp_group=true.", "cmt_cpp_nl_start")))
        self.label_cmt_cpp_nl_start.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_cpp_nl_start, 29, 0, 1, 2)
        self.label_option_cmt_cpp_nl_start = QtWidgets.QLabel("cmt_cpp_nl_start")
        self.label_option_cmt_cpp_nl_start.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_cpp_nl_start, 30, 0)
        self.option_cmt_cpp_nl_start =  QtWidgets.QComboBox()
        self.option_cmt_cpp_nl_start.addItems(['true','false'])
        self.option_cmt_cpp_nl_start.setCurrentText("false")
        self.group_page_layout_9.addWidget(self.option_cmt_cpp_nl_start, 30, 1)
        #--------------------------------------------
        self.label_cmt_cpp_nl_end = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add a newline before the closing '*/' of the combined cpp-comment\nwhen converting to a c-comment.", "cmt_cpp_nl_end")+"\n\n"+self.tr("Requires cmt_cpp_to_c=true and cmt_cpp_group=true.", "cmt_cpp_nl_end")))
        self.label_cmt_cpp_nl_end.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_cpp_nl_end, 31, 0, 1, 2)
        self.label_option_cmt_cpp_nl_end = QtWidgets.QLabel("cmt_cpp_nl_end")
        self.label_option_cmt_cpp_nl_end.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_cpp_nl_end, 32, 0)
        self.option_cmt_cpp_nl_end =  QtWidgets.QComboBox()
        self.option_cmt_cpp_nl_end.addItems(['true','false'])
        self.option_cmt_cpp_nl_end.setCurrentText("false")
        self.group_page_layout_9.addWidget(self.option_cmt_cpp_nl_end, 32, 1)
        #--------------------------------------------
        self.label_cmt_star_cont = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to put a star on subsequent comment lines.", "cmt_star_cont")))
        self.label_cmt_star_cont.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_star_cont, 33, 0, 1, 2)
        self.label_option_cmt_star_cont = QtWidgets.QLabel("cmt_star_cont")
        self.label_option_cmt_star_cont.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_star_cont, 34, 0)
        self.option_cmt_star_cont =  QtWidgets.QComboBox()
        self.option_cmt_star_cont.addItems(['true','false'])
        self.option_cmt_star_cont.setCurrentText("false")
        self.group_page_layout_9.addWidget(self.option_cmt_star_cont, 34, 1)
        #--------------------------------------------
        self.label_cmt_sp_before_star_cont = QtWidgets.QLabel(label("<hr>"+self.tr("The number of spaces to insert at the start of subsequent comment lines.", "cmt_sp_before_star_cont")))
        self.label_cmt_sp_before_star_cont.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_sp_before_star_cont, 35, 0, 1, 2)
        self.label_option_cmt_sp_before_star_cont = QtWidgets.QLabel("cmt_sp_before_star_cont")
        self.label_option_cmt_sp_before_star_cont.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_sp_before_star_cont, 36, 0)
        self.option_cmt_sp_before_star_cont =  QtWidgets.QSpinBox()
        self.option_cmt_sp_before_star_cont.setMinimum( 0)
        self.option_cmt_sp_before_star_cont.setMaximum( 16)
        self.option_cmt_sp_before_star_cont.setValue(0)
        self.group_page_layout_9.addWidget(self.option_cmt_sp_before_star_cont, 36, 1)
        #--------------------------------------------
        self.label_cmt_sp_after_star_cont = QtWidgets.QLabel(label("<hr>"+self.tr("The number of spaces to insert after the star on subsequent comment lines.", "cmt_sp_after_star_cont")))
        self.label_cmt_sp_after_star_cont.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_sp_after_star_cont, 37, 0, 1, 2)
        self.label_option_cmt_sp_after_star_cont = QtWidgets.QLabel("cmt_sp_after_star_cont")
        self.label_option_cmt_sp_after_star_cont.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_sp_after_star_cont, 38, 0)
        self.option_cmt_sp_after_star_cont =  QtWidgets.QSpinBox()
        self.option_cmt_sp_after_star_cont.setMinimum( 0)
        self.option_cmt_sp_after_star_cont.setMaximum( 16)
        self.option_cmt_sp_after_star_cont.setValue(0)
        self.group_page_layout_9.addWidget(self.option_cmt_sp_after_star_cont, 38, 1)
        #--------------------------------------------
        self.label_cmt_multi_check_last = QtWidgets.QLabel(label("<hr>"+self.tr("For multi-line comments with a '*' lead, remove leading spaces if the first\nand last lines of the comment are the same length.", "cmt_multi_check_last")))
        self.label_cmt_multi_check_last.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_multi_check_last, 39, 0, 1, 2)
        self.label_option_cmt_multi_check_last = QtWidgets.QLabel("cmt_multi_check_last")
        self.label_option_cmt_multi_check_last.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_multi_check_last, 40, 0)
        self.option_cmt_multi_check_last =  QtWidgets.QComboBox()
        self.option_cmt_multi_check_last.addItems(['true','false'])
        self.option_cmt_multi_check_last.setCurrentText("true")
        self.group_page_layout_9.addWidget(self.option_cmt_multi_check_last, 40, 1)
        #--------------------------------------------
        self.label_cmt_multi_first_len_minimum = QtWidgets.QLabel(label("<hr>"+self.tr("For multi-line comments with a '*' lead, remove leading spaces if the first\nand last lines of the comment are the same length AND if the length is\nbigger as the first_len minimum.", "cmt_multi_first_len_minimum")))
        self.label_cmt_multi_first_len_minimum.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_multi_first_len_minimum, 41, 0, 1, 2)
        self.label_option_cmt_multi_first_len_minimum = QtWidgets.QLabel("cmt_multi_first_len_minimum")
        self.label_option_cmt_multi_first_len_minimum.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_multi_first_len_minimum, 42, 0)
        self.option_cmt_multi_first_len_minimum =  QtWidgets.QSpinBox()
        self.option_cmt_multi_first_len_minimum.setMinimum( 1)
        self.option_cmt_multi_first_len_minimum.setMaximum( 20)
        self.option_cmt_multi_first_len_minimum.setValue(4)
        self.group_page_layout_9.addWidget(self.option_cmt_multi_first_len_minimum, 42, 1)
        #--------------------------------------------
        self.label_cmt_insert_file_header = QtWidgets.QLabel(label("<hr>"+self.tr("Path to a file that contains text to insert at the beginning of a file if\nthe file doesn't start with a C/C++ comment. If the inserted text contains\n'$(filename)', that will be replaced with the current file's name.", "cmt_insert_file_header")))
        self.label_cmt_insert_file_header.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_insert_file_header, 43, 0, 1, 2)
        self.label_option_cmt_insert_file_header = QtWidgets.QLabel("cmt_insert_file_header")
        self.label_option_cmt_insert_file_header.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_insert_file_header, 44, 0)
        self.option_cmt_insert_file_header =  QtWidgets.QLineEdit("")
        self.group_page_layout_9.addWidget(self.option_cmt_insert_file_header, 44, 1)
        #--------------------------------------------
        self.label_cmt_insert_file_footer = QtWidgets.QLabel(label("<hr>"+self.tr("Path to a file that contains text to insert at the end of a file if the\nfile doesn't end with a C/C++ comment. If the inserted text contains\n'$(filename)', that will be replaced with the current file's name.", "cmt_insert_file_footer")))
        self.label_cmt_insert_file_footer.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_insert_file_footer, 45, 0, 1, 2)
        self.label_option_cmt_insert_file_footer = QtWidgets.QLabel("cmt_insert_file_footer")
        self.label_option_cmt_insert_file_footer.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_insert_file_footer, 46, 0)
        self.option_cmt_insert_file_footer =  QtWidgets.QLineEdit("")
        self.group_page_layout_9.addWidget(self.option_cmt_insert_file_footer, 46, 1)
        #--------------------------------------------
        self.label_cmt_insert_func_header = QtWidgets.QLabel(label("<hr>"+self.tr("Path to a file that contains text to insert before a function definition if\nthe function isn't preceded by a C/C++ comment. If the inserted text\ncontains '$(function)', '$(javaparam)' or '$(fclass)', these will be\nreplaced with, respectively, the name of the function, the javadoc '@param'\nand '@return' stuff, or the name of the class to which the member function\nbelongs.", "cmt_insert_func_header")))
        self.label_cmt_insert_func_header.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_insert_func_header, 47, 0, 1, 2)
        self.label_option_cmt_insert_func_header = QtWidgets.QLabel("cmt_insert_func_header")
        self.label_option_cmt_insert_func_header.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_insert_func_header, 48, 0)
        self.option_cmt_insert_func_header =  QtWidgets.QLineEdit("")
        self.group_page_layout_9.addWidget(self.option_cmt_insert_func_header, 48, 1)
        #--------------------------------------------
        self.label_cmt_insert_class_header = QtWidgets.QLabel(label("<hr>"+self.tr("Path to a file that contains text to insert before a class if the class\nisn't preceded by a C/C++ comment. If the inserted text contains '$(class)',\nthat will be replaced with the class name.", "cmt_insert_class_header")))
        self.label_cmt_insert_class_header.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_insert_class_header, 49, 0, 1, 2)
        self.label_option_cmt_insert_class_header = QtWidgets.QLabel("cmt_insert_class_header")
        self.label_option_cmt_insert_class_header.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_insert_class_header, 50, 0)
        self.option_cmt_insert_class_header =  QtWidgets.QLineEdit("")
        self.group_page_layout_9.addWidget(self.option_cmt_insert_class_header, 50, 1)
        #--------------------------------------------
        self.label_cmt_insert_oc_msg_header = QtWidgets.QLabel(label("<hr>"+self.tr("Path to a file that contains text to insert before an Objective-C message\nspecification, if the method isn't preceded by a C/C++ comment. If the\ninserted text contains '$(message)' or '$(javaparam)', these will be\nreplaced with, respectively, the name of the function, or the javadoc\n'@param' and '@return' stuff.", "cmt_insert_oc_msg_header")))
        self.label_cmt_insert_oc_msg_header.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_insert_oc_msg_header, 51, 0, 1, 2)
        self.label_option_cmt_insert_oc_msg_header = QtWidgets.QLabel("cmt_insert_oc_msg_header")
        self.label_option_cmt_insert_oc_msg_header.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_insert_oc_msg_header, 52, 0)
        self.option_cmt_insert_oc_msg_header =  QtWidgets.QLineEdit("")
        self.group_page_layout_9.addWidget(self.option_cmt_insert_oc_msg_header, 52, 1)
        #--------------------------------------------
        self.label_cmt_insert_before_preproc = QtWidgets.QLabel(label("<hr>"+self.tr("Whether a comment should be inserted if a preprocessor is encountered when\nstepping backwards from a function name.", "cmt_insert_before_preproc")+"\n\n"+self.tr("Applies to cmt_insert_oc_msg_header, cmt_insert_func_header and\ncmt_insert_class_header.", "cmt_insert_before_preproc")))
        self.label_cmt_insert_before_preproc.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_insert_before_preproc, 53, 0, 1, 2)
        self.label_option_cmt_insert_before_preproc = QtWidgets.QLabel("cmt_insert_before_preproc")
        self.label_option_cmt_insert_before_preproc.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_insert_before_preproc, 54, 0)
        self.option_cmt_insert_before_preproc =  QtWidgets.QComboBox()
        self.option_cmt_insert_before_preproc.addItems(['true','false'])
        self.option_cmt_insert_before_preproc.setCurrentText("false")
        self.group_page_layout_9.addWidget(self.option_cmt_insert_before_preproc, 54, 1)
        #--------------------------------------------
        self.label_cmt_insert_before_inlines = QtWidgets.QLabel(label("<hr>"+self.tr("Whether a comment should be inserted if a function is declared inline to a\nclass definition.", "cmt_insert_before_inlines")+"\n\n"+self.tr("Applies to cmt_insert_func_header.", "cmt_insert_before_inlines")))
        self.label_cmt_insert_before_inlines.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_insert_before_inlines, 55, 0, 1, 2)
        self.label_option_cmt_insert_before_inlines = QtWidgets.QLabel("cmt_insert_before_inlines")
        self.label_option_cmt_insert_before_inlines.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_insert_before_inlines, 56, 0)
        self.option_cmt_insert_before_inlines =  QtWidgets.QComboBox()
        self.option_cmt_insert_before_inlines.addItems(['true','false'])
        self.option_cmt_insert_before_inlines.setCurrentText("true")
        self.group_page_layout_9.addWidget(self.option_cmt_insert_before_inlines, 56, 1)
        #--------------------------------------------
        self.label_cmt_insert_before_ctor_dtor = QtWidgets.QLabel(label("<hr>"+self.tr("Whether a comment should be inserted if the function is a class constructor\nor destructor.", "cmt_insert_before_ctor_dtor")+"\n\n"+self.tr("Applies to cmt_insert_func_header.", "cmt_insert_before_ctor_dtor")))
        self.label_cmt_insert_before_ctor_dtor.setWordWrap(True)
        self.group_page_layout_9.addWidget(self.label_cmt_insert_before_ctor_dtor, 57, 0, 1, 2)
        self.label_option_cmt_insert_before_ctor_dtor = QtWidgets.QLabel("cmt_insert_before_ctor_dtor")
        self.label_option_cmt_insert_before_ctor_dtor.setFont(font_name)
        self.group_page_layout_9.addWidget(self.label_option_cmt_insert_before_ctor_dtor, 58, 0)
        self.option_cmt_insert_before_ctor_dtor =  QtWidgets.QComboBox()
        self.option_cmt_insert_before_ctor_dtor.addItems(['true','false'])
        self.option_cmt_insert_before_ctor_dtor.setCurrentText("false")
        self.group_page_layout_9.addWidget(self.option_cmt_insert_before_ctor_dtor, 58, 1)
        self.group_page_layout_9.addItem(QtWidgets.QSpacerItem(10, 10, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding), 59,0)
        self.scroll_group_page_9 = QtWidgets.QScrollArea()
        self.scroll_group_page_9.setWidget(self.group_page_9)
        self.scroll_group_page_9.setWidgetResizable(True)
        self.addTab(self.scroll_group_page_9, self.tr("Comment modification options"))
        #================== Code modifying options (non-whitespace) =========================================
        self.group_page_10 = QtWidgets.QWidget()
        self.group_page_layout_10 = QtWidgets.QGridLayout(self.group_page_10)
        self.group_page_layout_10.addWidget(QtWidgets.QLabel(label(self.tr("Code modifying options (non-whitespace) help"))), 0, 0, 1, 2)
        #--------------------------------------------
        self.label_mod_full_brace_do = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove braces on a single-line 'do' statement.", "mod_full_brace_do")))
        self.label_mod_full_brace_do.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_full_brace_do, 1, 0, 1, 2)
        self.label_option_mod_full_brace_do = QtWidgets.QLabel("mod_full_brace_do")
        self.label_option_mod_full_brace_do.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_full_brace_do, 2, 0)
        self.option_mod_full_brace_do =  QtWidgets.QComboBox()
        self.option_mod_full_brace_do.addItems(['ignore','add','remove','force','not_defined'])
        self.option_mod_full_brace_do.setCurrentText("ignore")
        self.group_page_layout_10.addWidget(self.option_mod_full_brace_do, 2, 1)
        #--------------------------------------------
        self.label_mod_full_brace_for = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove braces on a single-line 'for' statement.", "mod_full_brace_for")))
        self.label_mod_full_brace_for.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_full_brace_for, 3, 0, 1, 2)
        self.label_option_mod_full_brace_for = QtWidgets.QLabel("mod_full_brace_for")
        self.label_option_mod_full_brace_for.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_full_brace_for, 4, 0)
        self.option_mod_full_brace_for =  QtWidgets.QComboBox()
        self.option_mod_full_brace_for.addItems(['ignore','add','remove','force','not_defined'])
        self.option_mod_full_brace_for.setCurrentText("ignore")
        self.group_page_layout_10.addWidget(self.option_mod_full_brace_for, 4, 1)
        #--------------------------------------------
        self.label_mod_full_brace_function = QtWidgets.QLabel(label("<hr>"+self.tr("(Pawn) Add or remove braces on a single-line function definition.", "mod_full_brace_function")))
        self.label_mod_full_brace_function.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_full_brace_function, 5, 0, 1, 2)
        self.label_option_mod_full_brace_function = QtWidgets.QLabel("mod_full_brace_function")
        self.label_option_mod_full_brace_function.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_full_brace_function, 6, 0)
        self.option_mod_full_brace_function =  QtWidgets.QComboBox()
        self.option_mod_full_brace_function.addItems(['ignore','add','remove','force','not_defined'])
        self.option_mod_full_brace_function.setCurrentText("ignore")
        self.group_page_layout_10.addWidget(self.option_mod_full_brace_function, 6, 1)
        #--------------------------------------------
        self.label_mod_full_brace_if = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove braces on a single-line 'if' statement. Braces will not be\nremoved if the braced statement contains an 'else'.", "mod_full_brace_if")))
        self.label_mod_full_brace_if.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_full_brace_if, 7, 0, 1, 2)
        self.label_option_mod_full_brace_if = QtWidgets.QLabel("mod_full_brace_if")
        self.label_option_mod_full_brace_if.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_full_brace_if, 8, 0)
        self.option_mod_full_brace_if =  QtWidgets.QComboBox()
        self.option_mod_full_brace_if.addItems(['ignore','add','remove','force','not_defined'])
        self.option_mod_full_brace_if.setCurrentText("ignore")
        self.group_page_layout_10.addWidget(self.option_mod_full_brace_if, 8, 1)
        #--------------------------------------------
        self.label_mod_full_brace_if_chain = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to enforce that all blocks of an 'if'/'else if'/'else' chain either\nhave, or do not have, braces. Overrides mod_full_brace_if.", "mod_full_brace_if_chain")+"\n\n"+self.tr("0: Don't override mod_full_brace_if\n1: Add braces to all blocks if any block needs braces and remove braces if\n   they can be removed from all blocks\n2: Add braces to all blocks if any block already has braces, regardless of\n   whether it needs them\n3: Add braces to all blocks if any block needs braces and remove braces if\n   they can be removed from all blocks, except if all blocks have braces\n   despite none needing them", "mod_full_brace_if_chain")))
        self.label_mod_full_brace_if_chain.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_full_brace_if_chain, 9, 0, 1, 2)
        self.label_option_mod_full_brace_if_chain = QtWidgets.QLabel("mod_full_brace_if_chain")
        self.label_option_mod_full_brace_if_chain.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_full_brace_if_chain, 10, 0)
        self.option_mod_full_brace_if_chain =  QtWidgets.QSpinBox()
        self.option_mod_full_brace_if_chain.setMinimum( 0)
        self.option_mod_full_brace_if_chain.setMaximum( 3)
        self.option_mod_full_brace_if_chain.setValue(0)
        self.group_page_layout_10.addWidget(self.option_mod_full_brace_if_chain, 10, 1)
        #--------------------------------------------
        self.label_mod_full_brace_if_chain_only = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to add braces to all blocks of an 'if'/'else if'/'else' chain.\nIf true, mod_full_brace_if_chain will only remove braces from an 'if' that\ndoes not have an 'else if' or 'else'.", "mod_full_brace_if_chain_only")))
        self.label_mod_full_brace_if_chain_only.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_full_brace_if_chain_only, 11, 0, 1, 2)
        self.label_option_mod_full_brace_if_chain_only = QtWidgets.QLabel("mod_full_brace_if_chain_only")
        self.label_option_mod_full_brace_if_chain_only.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_full_brace_if_chain_only, 12, 0)
        self.option_mod_full_brace_if_chain_only =  QtWidgets.QComboBox()
        self.option_mod_full_brace_if_chain_only.addItems(['true','false'])
        self.option_mod_full_brace_if_chain_only.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_full_brace_if_chain_only, 12, 1)
        #--------------------------------------------
        self.label_mod_full_brace_while = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove braces on single-line 'while' statement.", "mod_full_brace_while")))
        self.label_mod_full_brace_while.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_full_brace_while, 13, 0, 1, 2)
        self.label_option_mod_full_brace_while = QtWidgets.QLabel("mod_full_brace_while")
        self.label_option_mod_full_brace_while.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_full_brace_while, 14, 0)
        self.option_mod_full_brace_while =  QtWidgets.QComboBox()
        self.option_mod_full_brace_while.addItems(['ignore','add','remove','force','not_defined'])
        self.option_mod_full_brace_while.setCurrentText("ignore")
        self.group_page_layout_10.addWidget(self.option_mod_full_brace_while, 14, 1)
        #--------------------------------------------
        self.label_mod_full_brace_using = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove braces on single-line 'using ()' statement.", "mod_full_brace_using")))
        self.label_mod_full_brace_using.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_full_brace_using, 15, 0, 1, 2)
        self.label_option_mod_full_brace_using = QtWidgets.QLabel("mod_full_brace_using")
        self.label_option_mod_full_brace_using.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_full_brace_using, 16, 0)
        self.option_mod_full_brace_using =  QtWidgets.QComboBox()
        self.option_mod_full_brace_using.addItems(['ignore','add','remove','force','not_defined'])
        self.option_mod_full_brace_using.setCurrentText("ignore")
        self.group_page_layout_10.addWidget(self.option_mod_full_brace_using, 16, 1)
        #--------------------------------------------
        self.label_mod_full_brace_nl = QtWidgets.QLabel(label("<hr>"+self.tr("Don't remove braces around statements that span N newlines", "mod_full_brace_nl")))
        self.label_mod_full_brace_nl.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_full_brace_nl, 17, 0, 1, 2)
        self.label_option_mod_full_brace_nl = QtWidgets.QLabel("mod_full_brace_nl")
        self.label_option_mod_full_brace_nl.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_full_brace_nl, 18, 0)
        self.option_mod_full_brace_nl =  QtWidgets.QSpinBox()
        self.option_mod_full_brace_nl.setMinimum( 0)
        self.option_mod_full_brace_nl.setMaximum( 5000)
        self.option_mod_full_brace_nl.setValue(0)
        self.group_page_layout_10.addWidget(self.option_mod_full_brace_nl, 18, 1)
        #--------------------------------------------
        self.label_mod_full_brace_nl_block_rem_mlcond = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to prevent removal of braces from 'if'/'for'/'while'/etc. blocks\nwhich span multiple lines.", "mod_full_brace_nl_block_rem_mlcond")+"\n\n"+self.tr("Affects:\n  mod_full_brace_for\n  mod_full_brace_if\n  mod_full_brace_if_chain\n  mod_full_brace_if_chain_only\n  mod_full_brace_while\n  mod_full_brace_using", "mod_full_brace_nl_block_rem_mlcond")+"\n\n"+self.tr("Does not affect:\n  mod_full_brace_do\n  mod_full_brace_function", "mod_full_brace_nl_block_rem_mlcond")))
        self.label_mod_full_brace_nl_block_rem_mlcond.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_full_brace_nl_block_rem_mlcond, 19, 0, 1, 2)
        self.label_option_mod_full_brace_nl_block_rem_mlcond = QtWidgets.QLabel("mod_full_brace_nl_block_rem_mlcond")
        self.label_option_mod_full_brace_nl_block_rem_mlcond.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_full_brace_nl_block_rem_mlcond, 20, 0)
        self.option_mod_full_brace_nl_block_rem_mlcond =  QtWidgets.QComboBox()
        self.option_mod_full_brace_nl_block_rem_mlcond.addItems(['true','false'])
        self.option_mod_full_brace_nl_block_rem_mlcond.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_full_brace_nl_block_rem_mlcond, 20, 1)
        #--------------------------------------------
        self.label_mod_paren_on_return = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove unnecessary parentheses on 'return' statement.", "mod_paren_on_return")))
        self.label_mod_paren_on_return.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_paren_on_return, 21, 0, 1, 2)
        self.label_option_mod_paren_on_return = QtWidgets.QLabel("mod_paren_on_return")
        self.label_option_mod_paren_on_return.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_paren_on_return, 22, 0)
        self.option_mod_paren_on_return =  QtWidgets.QComboBox()
        self.option_mod_paren_on_return.addItems(['ignore','add','remove','force','not_defined'])
        self.option_mod_paren_on_return.setCurrentText("ignore")
        self.group_page_layout_10.addWidget(self.option_mod_paren_on_return, 22, 1)
        #--------------------------------------------
        self.label_mod_paren_on_throw = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove unnecessary parentheses on 'throw' statement.", "mod_paren_on_throw")))
        self.label_mod_paren_on_throw.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_paren_on_throw, 23, 0, 1, 2)
        self.label_option_mod_paren_on_throw = QtWidgets.QLabel("mod_paren_on_throw")
        self.label_option_mod_paren_on_throw.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_paren_on_throw, 24, 0)
        self.option_mod_paren_on_throw =  QtWidgets.QComboBox()
        self.option_mod_paren_on_throw.addItems(['ignore','add','remove','force','not_defined'])
        self.option_mod_paren_on_throw.setCurrentText("ignore")
        self.group_page_layout_10.addWidget(self.option_mod_paren_on_throw, 24, 1)
        #--------------------------------------------
        self.label_mod_pawn_semicolon = QtWidgets.QLabel(label("<hr>"+self.tr("(Pawn) Whether to change optional semicolons to real semicolons.", "mod_pawn_semicolon")))
        self.label_mod_pawn_semicolon.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_pawn_semicolon, 25, 0, 1, 2)
        self.label_option_mod_pawn_semicolon = QtWidgets.QLabel("mod_pawn_semicolon")
        self.label_option_mod_pawn_semicolon.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_pawn_semicolon, 26, 0)
        self.option_mod_pawn_semicolon =  QtWidgets.QComboBox()
        self.option_mod_pawn_semicolon.addItems(['true','false'])
        self.option_mod_pawn_semicolon.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_pawn_semicolon, 26, 1)
        #--------------------------------------------
        self.label_mod_full_paren_if_bool = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to fully parenthesize Boolean expressions in 'while' and 'if'\nstatement, as in 'if (a && b > c)' => 'if (a && (b > c))'.", "mod_full_paren_if_bool")))
        self.label_mod_full_paren_if_bool.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_full_paren_if_bool, 27, 0, 1, 2)
        self.label_option_mod_full_paren_if_bool = QtWidgets.QLabel("mod_full_paren_if_bool")
        self.label_option_mod_full_paren_if_bool.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_full_paren_if_bool, 28, 0)
        self.option_mod_full_paren_if_bool =  QtWidgets.QComboBox()
        self.option_mod_full_paren_if_bool.addItems(['true','false'])
        self.option_mod_full_paren_if_bool.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_full_paren_if_bool, 28, 1)
        #--------------------------------------------
        self.label_mod_full_paren_assign_bool = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to fully parenthesize Boolean expressions after '='\nstatement, as in 'x = a && b > c;' => 'x = (a && (b > c));'.", "mod_full_paren_assign_bool")))
        self.label_mod_full_paren_assign_bool.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_full_paren_assign_bool, 29, 0, 1, 2)
        self.label_option_mod_full_paren_assign_bool = QtWidgets.QLabel("mod_full_paren_assign_bool")
        self.label_option_mod_full_paren_assign_bool.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_full_paren_assign_bool, 30, 0)
        self.option_mod_full_paren_assign_bool =  QtWidgets.QComboBox()
        self.option_mod_full_paren_assign_bool.addItems(['true','false'])
        self.option_mod_full_paren_assign_bool.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_full_paren_assign_bool, 30, 1)
        #--------------------------------------------
        self.label_mod_full_paren_return_bool = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to fully parenthesize Boolean expressions after '='\nstatement, as in 'return  a && b > c;' => 'return (a && (b > c));'.", "mod_full_paren_return_bool")))
        self.label_mod_full_paren_return_bool.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_full_paren_return_bool, 31, 0, 1, 2)
        self.label_option_mod_full_paren_return_bool = QtWidgets.QLabel("mod_full_paren_return_bool")
        self.label_option_mod_full_paren_return_bool.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_full_paren_return_bool, 32, 0)
        self.option_mod_full_paren_return_bool =  QtWidgets.QComboBox()
        self.option_mod_full_paren_return_bool.addItems(['true','false'])
        self.option_mod_full_paren_return_bool.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_full_paren_return_bool, 32, 1)
        #--------------------------------------------
        self.label_mod_remove_extra_semicolon = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to remove superfluous semicolons.", "mod_remove_extra_semicolon")))
        self.label_mod_remove_extra_semicolon.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_remove_extra_semicolon, 33, 0, 1, 2)
        self.label_option_mod_remove_extra_semicolon = QtWidgets.QLabel("mod_remove_extra_semicolon")
        self.label_option_mod_remove_extra_semicolon.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_remove_extra_semicolon, 34, 0)
        self.option_mod_remove_extra_semicolon =  QtWidgets.QComboBox()
        self.option_mod_remove_extra_semicolon.addItems(['true','false'])
        self.option_mod_remove_extra_semicolon.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_remove_extra_semicolon, 34, 1)
        #--------------------------------------------
        self.label_mod_remove_duplicate_include = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to remove duplicate include.", "mod_remove_duplicate_include")))
        self.label_mod_remove_duplicate_include.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_remove_duplicate_include, 35, 0, 1, 2)
        self.label_option_mod_remove_duplicate_include = QtWidgets.QLabel("mod_remove_duplicate_include")
        self.label_option_mod_remove_duplicate_include.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_remove_duplicate_include, 36, 0)
        self.option_mod_remove_duplicate_include =  QtWidgets.QComboBox()
        self.option_mod_remove_duplicate_include.addItems(['true','false'])
        self.option_mod_remove_duplicate_include.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_remove_duplicate_include, 36, 1)
        #--------------------------------------------
        self.label_mod_add_force_c_closebrace_comment = QtWidgets.QLabel(label("<hr>"+self.tr("the following options (mod_XX_closebrace_comment) use different comment,\ndepending of the setting of the next option.\nfalse: Use the c comment (default)\ntrue : Use the cpp comment", "mod_add_force_c_closebrace_comment")))
        self.label_mod_add_force_c_closebrace_comment.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_add_force_c_closebrace_comment, 37, 0, 1, 2)
        self.label_option_mod_add_force_c_closebrace_comment = QtWidgets.QLabel("mod_add_force_c_closebrace_comment")
        self.label_option_mod_add_force_c_closebrace_comment.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_add_force_c_closebrace_comment, 38, 0)
        self.option_mod_add_force_c_closebrace_comment =  QtWidgets.QComboBox()
        self.option_mod_add_force_c_closebrace_comment.addItems(['true','false'])
        self.option_mod_add_force_c_closebrace_comment.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_add_force_c_closebrace_comment, 38, 1)
        #--------------------------------------------
        self.label_mod_add_long_function_closebrace_comment = QtWidgets.QLabel(label("<hr>"+self.tr("If a function body exceeds the specified number of newlines and doesn't have\na comment after the close brace, a comment will be added.", "mod_add_long_function_closebrace_comment")))
        self.label_mod_add_long_function_closebrace_comment.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_add_long_function_closebrace_comment, 39, 0, 1, 2)
        self.label_option_mod_add_long_function_closebrace_comment = QtWidgets.QLabel("mod_add_long_function_closebrace_comment")
        self.label_option_mod_add_long_function_closebrace_comment.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_add_long_function_closebrace_comment, 40, 0)
        self.option_mod_add_long_function_closebrace_comment =  QtWidgets.QSpinBox()
        self.option_mod_add_long_function_closebrace_comment.setMinimum( 0)
        self.option_mod_add_long_function_closebrace_comment.setMaximum( 255)
        self.option_mod_add_long_function_closebrace_comment.setValue(0)
        self.group_page_layout_10.addWidget(self.option_mod_add_long_function_closebrace_comment, 40, 1)
        #--------------------------------------------
        self.label_mod_add_long_namespace_closebrace_comment = QtWidgets.QLabel(label("<hr>"+self.tr("If a namespace body exceeds the specified number of newlines and doesn't\nhave a comment after the close brace, a comment will be added.", "mod_add_long_namespace_closebrace_comment")))
        self.label_mod_add_long_namespace_closebrace_comment.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_add_long_namespace_closebrace_comment, 41, 0, 1, 2)
        self.label_option_mod_add_long_namespace_closebrace_comment = QtWidgets.QLabel("mod_add_long_namespace_closebrace_comment")
        self.label_option_mod_add_long_namespace_closebrace_comment.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_add_long_namespace_closebrace_comment, 42, 0)
        self.option_mod_add_long_namespace_closebrace_comment =  QtWidgets.QSpinBox()
        self.option_mod_add_long_namespace_closebrace_comment.setMinimum( 0)
        self.option_mod_add_long_namespace_closebrace_comment.setMaximum( 255)
        self.option_mod_add_long_namespace_closebrace_comment.setValue(0)
        self.group_page_layout_10.addWidget(self.option_mod_add_long_namespace_closebrace_comment, 42, 1)
        #--------------------------------------------
        self.label_mod_add_long_class_closebrace_comment = QtWidgets.QLabel(label("<hr>"+self.tr("If a class body exceeds the specified number of newlines and doesn't have a\ncomment after the close brace, a comment will be added.", "mod_add_long_class_closebrace_comment")))
        self.label_mod_add_long_class_closebrace_comment.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_add_long_class_closebrace_comment, 43, 0, 1, 2)
        self.label_option_mod_add_long_class_closebrace_comment = QtWidgets.QLabel("mod_add_long_class_closebrace_comment")
        self.label_option_mod_add_long_class_closebrace_comment.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_add_long_class_closebrace_comment, 44, 0)
        self.option_mod_add_long_class_closebrace_comment =  QtWidgets.QSpinBox()
        self.option_mod_add_long_class_closebrace_comment.setMinimum( 0)
        self.option_mod_add_long_class_closebrace_comment.setMaximum( 255)
        self.option_mod_add_long_class_closebrace_comment.setValue(0)
        self.group_page_layout_10.addWidget(self.option_mod_add_long_class_closebrace_comment, 44, 1)
        #--------------------------------------------
        self.label_mod_add_long_switch_closebrace_comment = QtWidgets.QLabel(label("<hr>"+self.tr("If a switch body exceeds the specified number of newlines and doesn't have a\ncomment after the close brace, a comment will be added.", "mod_add_long_switch_closebrace_comment")))
        self.label_mod_add_long_switch_closebrace_comment.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_add_long_switch_closebrace_comment, 45, 0, 1, 2)
        self.label_option_mod_add_long_switch_closebrace_comment = QtWidgets.QLabel("mod_add_long_switch_closebrace_comment")
        self.label_option_mod_add_long_switch_closebrace_comment.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_add_long_switch_closebrace_comment, 46, 0)
        self.option_mod_add_long_switch_closebrace_comment =  QtWidgets.QSpinBox()
        self.option_mod_add_long_switch_closebrace_comment.setMinimum( 0)
        self.option_mod_add_long_switch_closebrace_comment.setMaximum( 255)
        self.option_mod_add_long_switch_closebrace_comment.setValue(0)
        self.group_page_layout_10.addWidget(self.option_mod_add_long_switch_closebrace_comment, 46, 1)
        #--------------------------------------------
        self.label_mod_add_long_ifdef_endif_comment = QtWidgets.QLabel(label("<hr>"+self.tr("If an #ifdef body exceeds the specified number of newlines and doesn't have\na comment after the #endif, a comment will be added.", "mod_add_long_ifdef_endif_comment")))
        self.label_mod_add_long_ifdef_endif_comment.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_add_long_ifdef_endif_comment, 47, 0, 1, 2)
        self.label_option_mod_add_long_ifdef_endif_comment = QtWidgets.QLabel("mod_add_long_ifdef_endif_comment")
        self.label_option_mod_add_long_ifdef_endif_comment.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_add_long_ifdef_endif_comment, 48, 0)
        self.option_mod_add_long_ifdef_endif_comment =  QtWidgets.QSpinBox()
        self.option_mod_add_long_ifdef_endif_comment.setMinimum( 0)
        self.option_mod_add_long_ifdef_endif_comment.setMaximum( 255)
        self.option_mod_add_long_ifdef_endif_comment.setValue(0)
        self.group_page_layout_10.addWidget(self.option_mod_add_long_ifdef_endif_comment, 48, 1)
        #--------------------------------------------
        self.label_mod_add_long_ifdef_else_comment = QtWidgets.QLabel(label("<hr>"+self.tr("If an #ifdef or #else body exceeds the specified number of newlines and\ndoesn't have a comment after the #else, a comment will be added.", "mod_add_long_ifdef_else_comment")))
        self.label_mod_add_long_ifdef_else_comment.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_add_long_ifdef_else_comment, 49, 0, 1, 2)
        self.label_option_mod_add_long_ifdef_else_comment = QtWidgets.QLabel("mod_add_long_ifdef_else_comment")
        self.label_option_mod_add_long_ifdef_else_comment.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_add_long_ifdef_else_comment, 50, 0)
        self.option_mod_add_long_ifdef_else_comment =  QtWidgets.QSpinBox()
        self.option_mod_add_long_ifdef_else_comment.setMinimum( 0)
        self.option_mod_add_long_ifdef_else_comment.setMaximum( 255)
        self.option_mod_add_long_ifdef_else_comment.setValue(0)
        self.group_page_layout_10.addWidget(self.option_mod_add_long_ifdef_else_comment, 50, 1)
        #--------------------------------------------
        self.label_mod_sort_case_sensitive = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to take care of the case by the mod_sort_xx options.", "mod_sort_case_sensitive")))
        self.label_mod_sort_case_sensitive.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_sort_case_sensitive, 51, 0, 1, 2)
        self.label_option_mod_sort_case_sensitive = QtWidgets.QLabel("mod_sort_case_sensitive")
        self.label_option_mod_sort_case_sensitive.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_sort_case_sensitive, 52, 0)
        self.option_mod_sort_case_sensitive =  QtWidgets.QComboBox()
        self.option_mod_sort_case_sensitive.addItems(['true','false'])
        self.option_mod_sort_case_sensitive.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_sort_case_sensitive, 52, 1)
        #--------------------------------------------
        self.label_mod_sort_import = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to sort consecutive single-line 'import' statements.", "mod_sort_import")))
        self.label_mod_sort_import.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_sort_import, 53, 0, 1, 2)
        self.label_option_mod_sort_import = QtWidgets.QLabel("mod_sort_import")
        self.label_option_mod_sort_import.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_sort_import, 54, 0)
        self.option_mod_sort_import =  QtWidgets.QComboBox()
        self.option_mod_sort_import.addItems(['true','false'])
        self.option_mod_sort_import.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_sort_import, 54, 1)
        #--------------------------------------------
        self.label_mod_sort_using = QtWidgets.QLabel(label("<hr>"+self.tr("(C#) Whether to sort consecutive single-line 'using' statements.", "mod_sort_using")))
        self.label_mod_sort_using.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_sort_using, 55, 0, 1, 2)
        self.label_option_mod_sort_using = QtWidgets.QLabel("mod_sort_using")
        self.label_option_mod_sort_using.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_sort_using, 56, 0)
        self.option_mod_sort_using =  QtWidgets.QComboBox()
        self.option_mod_sort_using.addItems(['true','false'])
        self.option_mod_sort_using.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_sort_using, 56, 1)
        #--------------------------------------------
        self.label_mod_sort_include = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to sort consecutive single-line '#include' statements (C/C++) and\n'#import' statements (Objective-C). Be aware that this has the potential to\nbreak your code if your includes/imports have ordering dependencies.", "mod_sort_include")))
        self.label_mod_sort_include.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_sort_include, 57, 0, 1, 2)
        self.label_option_mod_sort_include = QtWidgets.QLabel("mod_sort_include")
        self.label_option_mod_sort_include.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_sort_include, 58, 0)
        self.option_mod_sort_include =  QtWidgets.QComboBox()
        self.option_mod_sort_include.addItems(['true','false'])
        self.option_mod_sort_include.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_sort_include, 58, 1)
        #--------------------------------------------
        self.label_mod_sort_incl_import_prioritize_filename = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to prioritize '#include' and '#import' statements that contain\nfilename without extension when sorting is enabled.", "mod_sort_incl_import_prioritize_filename")))
        self.label_mod_sort_incl_import_prioritize_filename.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_sort_incl_import_prioritize_filename, 59, 0, 1, 2)
        self.label_option_mod_sort_incl_import_prioritize_filename = QtWidgets.QLabel("mod_sort_incl_import_prioritize_filename")
        self.label_option_mod_sort_incl_import_prioritize_filename.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_sort_incl_import_prioritize_filename, 60, 0)
        self.option_mod_sort_incl_import_prioritize_filename =  QtWidgets.QComboBox()
        self.option_mod_sort_incl_import_prioritize_filename.addItems(['true','false'])
        self.option_mod_sort_incl_import_prioritize_filename.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_sort_incl_import_prioritize_filename, 60, 1)
        #--------------------------------------------
        self.label_mod_sort_incl_import_prioritize_extensionless = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to prioritize '#include' and '#import' statements that does not\ncontain extensions when sorting is enabled.", "mod_sort_incl_import_prioritize_extensionless")))
        self.label_mod_sort_incl_import_prioritize_extensionless.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_sort_incl_import_prioritize_extensionless, 61, 0, 1, 2)
        self.label_option_mod_sort_incl_import_prioritize_extensionless = QtWidgets.QLabel("mod_sort_incl_import_prioritize_extensionless")
        self.label_option_mod_sort_incl_import_prioritize_extensionless.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_sort_incl_import_prioritize_extensionless, 62, 0)
        self.option_mod_sort_incl_import_prioritize_extensionless =  QtWidgets.QComboBox()
        self.option_mod_sort_incl_import_prioritize_extensionless.addItems(['true','false'])
        self.option_mod_sort_incl_import_prioritize_extensionless.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_sort_incl_import_prioritize_extensionless, 62, 1)
        #--------------------------------------------
        self.label_mod_sort_incl_import_prioritize_angle_over_quotes = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to prioritize '#include' and '#import' statements that contain\nangle over quotes when sorting is enabled.", "mod_sort_incl_import_prioritize_angle_over_quotes")))
        self.label_mod_sort_incl_import_prioritize_angle_over_quotes.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_sort_incl_import_prioritize_angle_over_quotes, 63, 0, 1, 2)
        self.label_option_mod_sort_incl_import_prioritize_angle_over_quotes = QtWidgets.QLabel("mod_sort_incl_import_prioritize_angle_over_quotes")
        self.label_option_mod_sort_incl_import_prioritize_angle_over_quotes.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_sort_incl_import_prioritize_angle_over_quotes, 64, 0)
        self.option_mod_sort_incl_import_prioritize_angle_over_quotes =  QtWidgets.QComboBox()
        self.option_mod_sort_incl_import_prioritize_angle_over_quotes.addItems(['true','false'])
        self.option_mod_sort_incl_import_prioritize_angle_over_quotes.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_sort_incl_import_prioritize_angle_over_quotes, 64, 1)
        #--------------------------------------------
        self.label_mod_sort_incl_import_ignore_extension = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to ignore file extension in '#include' and '#import' statements\nfor sorting comparison.", "mod_sort_incl_import_ignore_extension")))
        self.label_mod_sort_incl_import_ignore_extension.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_sort_incl_import_ignore_extension, 65, 0, 1, 2)
        self.label_option_mod_sort_incl_import_ignore_extension = QtWidgets.QLabel("mod_sort_incl_import_ignore_extension")
        self.label_option_mod_sort_incl_import_ignore_extension.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_sort_incl_import_ignore_extension, 66, 0)
        self.option_mod_sort_incl_import_ignore_extension =  QtWidgets.QComboBox()
        self.option_mod_sort_incl_import_ignore_extension.addItems(['true','false'])
        self.option_mod_sort_incl_import_ignore_extension.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_sort_incl_import_ignore_extension, 66, 1)
        #--------------------------------------------
        self.label_mod_sort_incl_import_grouping_enabled = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to group '#include' and '#import' statements when sorting is enabled.", "mod_sort_incl_import_grouping_enabled")))
        self.label_mod_sort_incl_import_grouping_enabled.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_sort_incl_import_grouping_enabled, 67, 0, 1, 2)
        self.label_option_mod_sort_incl_import_grouping_enabled = QtWidgets.QLabel("mod_sort_incl_import_grouping_enabled")
        self.label_option_mod_sort_incl_import_grouping_enabled.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_sort_incl_import_grouping_enabled, 68, 0)
        self.option_mod_sort_incl_import_grouping_enabled =  QtWidgets.QComboBox()
        self.option_mod_sort_incl_import_grouping_enabled.addItems(['true','false'])
        self.option_mod_sort_incl_import_grouping_enabled.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_sort_incl_import_grouping_enabled, 68, 1)
        #--------------------------------------------
        self.label_mod_move_case_break = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to move a 'break' that appears after a fully braced 'case' before\nthe close brace, as in 'case X: { ... } break;' => 'case X: { ... break; }'.", "mod_move_case_break")))
        self.label_mod_move_case_break.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_move_case_break, 69, 0, 1, 2)
        self.label_option_mod_move_case_break = QtWidgets.QLabel("mod_move_case_break")
        self.label_option_mod_move_case_break.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_move_case_break, 70, 0)
        self.option_mod_move_case_break =  QtWidgets.QComboBox()
        self.option_mod_move_case_break.addItems(['true','false'])
        self.option_mod_move_case_break.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_move_case_break, 70, 1)
        #--------------------------------------------
        self.label_mod_move_case_return = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to move a 'return' that appears after a fully braced 'case' before\nthe close brace, as in 'case X: { ... } return;' => 'case X: { ... return; }'.", "mod_move_case_return")))
        self.label_mod_move_case_return.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_move_case_return, 71, 0, 1, 2)
        self.label_option_mod_move_case_return = QtWidgets.QLabel("mod_move_case_return")
        self.label_option_mod_move_case_return.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_move_case_return, 72, 0)
        self.option_mod_move_case_return =  QtWidgets.QComboBox()
        self.option_mod_move_case_return.addItems(['true','false'])
        self.option_mod_move_case_return.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_move_case_return, 72, 1)
        #--------------------------------------------
        self.label_mod_case_brace = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove braces around a fully braced case statement. Will only remove\nbraces if there are no variable declarations in the block.", "mod_case_brace")))
        self.label_mod_case_brace.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_case_brace, 73, 0, 1, 2)
        self.label_option_mod_case_brace = QtWidgets.QLabel("mod_case_brace")
        self.label_option_mod_case_brace.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_case_brace, 74, 0)
        self.option_mod_case_brace =  QtWidgets.QComboBox()
        self.option_mod_case_brace.addItems(['ignore','add','remove','force','not_defined'])
        self.option_mod_case_brace.setCurrentText("ignore")
        self.group_page_layout_10.addWidget(self.option_mod_case_brace, 74, 1)
        #--------------------------------------------
        self.label_mod_remove_empty_return = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to remove a void 'return;' that appears as the last statement in a\nfunction.", "mod_remove_empty_return")))
        self.label_mod_remove_empty_return.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_remove_empty_return, 75, 0, 1, 2)
        self.label_option_mod_remove_empty_return = QtWidgets.QLabel("mod_remove_empty_return")
        self.label_option_mod_remove_empty_return.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_remove_empty_return, 76, 0)
        self.option_mod_remove_empty_return =  QtWidgets.QComboBox()
        self.option_mod_remove_empty_return.addItems(['true','false'])
        self.option_mod_remove_empty_return.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_remove_empty_return, 76, 1)
        #--------------------------------------------
        self.label_mod_enum_last_comma = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove the comma after the last value of an enumeration.", "mod_enum_last_comma")))
        self.label_mod_enum_last_comma.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_enum_last_comma, 77, 0, 1, 2)
        self.label_option_mod_enum_last_comma = QtWidgets.QLabel("mod_enum_last_comma")
        self.label_option_mod_enum_last_comma.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_enum_last_comma, 78, 0)
        self.option_mod_enum_last_comma =  QtWidgets.QComboBox()
        self.option_mod_enum_last_comma.addItems(['ignore','add','remove','force','not_defined'])
        self.option_mod_enum_last_comma.setCurrentText("ignore")
        self.group_page_layout_10.addWidget(self.option_mod_enum_last_comma, 78, 1)
        #--------------------------------------------
        self.label_mod_infinite_loop = QtWidgets.QLabel(label("<hr>"+self.tr("Syntax to use for infinite loops.", "mod_infinite_loop")+"\n\n"+self.tr("0: Leave syntax alone (default)\n1: Rewrite as `for(;;)`\n2: Rewrite as `while(true)`\n3: Rewrite as `do`...`while(true);`\n4: Rewrite as `while(1)`\n5: Rewrite as `do`...`while(1);`", "mod_infinite_loop")+"\n\n"+self.tr("Infinite loops that do not already match one of these syntaxes are ignored.\nOther options that affect loop formatting will be applied after transforming\nthe syntax.", "mod_infinite_loop")))
        self.label_mod_infinite_loop.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_infinite_loop, 79, 0, 1, 2)
        self.label_option_mod_infinite_loop = QtWidgets.QLabel("mod_infinite_loop")
        self.label_option_mod_infinite_loop.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_infinite_loop, 80, 0)
        self.option_mod_infinite_loop =  QtWidgets.QSpinBox()
        self.option_mod_infinite_loop.setMinimum( 0)
        self.option_mod_infinite_loop.setMaximum( 5)
        self.option_mod_infinite_loop.setValue(0)
        self.group_page_layout_10.addWidget(self.option_mod_infinite_loop, 80, 1)
        #--------------------------------------------
        self.label_mod_int_short = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove the 'int' keyword in 'int short'.", "mod_int_short")))
        self.label_mod_int_short.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_int_short, 81, 0, 1, 2)
        self.label_option_mod_int_short = QtWidgets.QLabel("mod_int_short")
        self.label_option_mod_int_short.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_int_short, 82, 0)
        self.option_mod_int_short =  QtWidgets.QComboBox()
        self.option_mod_int_short.addItems(['ignore','add','remove','force','not_defined'])
        self.option_mod_int_short.setCurrentText("ignore")
        self.group_page_layout_10.addWidget(self.option_mod_int_short, 82, 1)
        #--------------------------------------------
        self.label_mod_short_int = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove the 'int' keyword in 'short int'.", "mod_short_int")))
        self.label_mod_short_int.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_short_int, 83, 0, 1, 2)
        self.label_option_mod_short_int = QtWidgets.QLabel("mod_short_int")
        self.label_option_mod_short_int.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_short_int, 84, 0)
        self.option_mod_short_int =  QtWidgets.QComboBox()
        self.option_mod_short_int.addItems(['ignore','add','remove','force','not_defined'])
        self.option_mod_short_int.setCurrentText("ignore")
        self.group_page_layout_10.addWidget(self.option_mod_short_int, 84, 1)
        #--------------------------------------------
        self.label_mod_int_long = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove the 'int' keyword in 'int long'.", "mod_int_long")))
        self.label_mod_int_long.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_int_long, 85, 0, 1, 2)
        self.label_option_mod_int_long = QtWidgets.QLabel("mod_int_long")
        self.label_option_mod_int_long.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_int_long, 86, 0)
        self.option_mod_int_long =  QtWidgets.QComboBox()
        self.option_mod_int_long.addItems(['ignore','add','remove','force','not_defined'])
        self.option_mod_int_long.setCurrentText("ignore")
        self.group_page_layout_10.addWidget(self.option_mod_int_long, 86, 1)
        #--------------------------------------------
        self.label_mod_long_int = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove the 'int' keyword in 'long int'.", "mod_long_int")))
        self.label_mod_long_int.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_long_int, 87, 0, 1, 2)
        self.label_option_mod_long_int = QtWidgets.QLabel("mod_long_int")
        self.label_option_mod_long_int.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_long_int, 88, 0)
        self.option_mod_long_int =  QtWidgets.QComboBox()
        self.option_mod_long_int.addItems(['ignore','add','remove','force','not_defined'])
        self.option_mod_long_int.setCurrentText("ignore")
        self.group_page_layout_10.addWidget(self.option_mod_long_int, 88, 1)
        #--------------------------------------------
        self.label_mod_int_signed = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove the 'int' keyword in 'int signed'.", "mod_int_signed")))
        self.label_mod_int_signed.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_int_signed, 89, 0, 1, 2)
        self.label_option_mod_int_signed = QtWidgets.QLabel("mod_int_signed")
        self.label_option_mod_int_signed.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_int_signed, 90, 0)
        self.option_mod_int_signed =  QtWidgets.QComboBox()
        self.option_mod_int_signed.addItems(['ignore','add','remove','force','not_defined'])
        self.option_mod_int_signed.setCurrentText("ignore")
        self.group_page_layout_10.addWidget(self.option_mod_int_signed, 90, 1)
        #--------------------------------------------
        self.label_mod_signed_int = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove the 'int' keyword in 'signed int'.", "mod_signed_int")))
        self.label_mod_signed_int.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_signed_int, 91, 0, 1, 2)
        self.label_option_mod_signed_int = QtWidgets.QLabel("mod_signed_int")
        self.label_option_mod_signed_int.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_signed_int, 92, 0)
        self.option_mod_signed_int =  QtWidgets.QComboBox()
        self.option_mod_signed_int.addItems(['ignore','add','remove','force','not_defined'])
        self.option_mod_signed_int.setCurrentText("ignore")
        self.group_page_layout_10.addWidget(self.option_mod_signed_int, 92, 1)
        #--------------------------------------------
        self.label_mod_int_unsigned = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove the 'int' keyword in 'int unsigned'.", "mod_int_unsigned")))
        self.label_mod_int_unsigned.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_int_unsigned, 93, 0, 1, 2)
        self.label_option_mod_int_unsigned = QtWidgets.QLabel("mod_int_unsigned")
        self.label_option_mod_int_unsigned.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_int_unsigned, 94, 0)
        self.option_mod_int_unsigned =  QtWidgets.QComboBox()
        self.option_mod_int_unsigned.addItems(['ignore','add','remove','force','not_defined'])
        self.option_mod_int_unsigned.setCurrentText("ignore")
        self.group_page_layout_10.addWidget(self.option_mod_int_unsigned, 94, 1)
        #--------------------------------------------
        self.label_mod_unsigned_int = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove the 'int' keyword in 'unsigned int'.", "mod_unsigned_int")))
        self.label_mod_unsigned_int.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_unsigned_int, 95, 0, 1, 2)
        self.label_option_mod_unsigned_int = QtWidgets.QLabel("mod_unsigned_int")
        self.label_option_mod_unsigned_int.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_unsigned_int, 96, 0)
        self.option_mod_unsigned_int =  QtWidgets.QComboBox()
        self.option_mod_unsigned_int.addItems(['ignore','add','remove','force','not_defined'])
        self.option_mod_unsigned_int.setCurrentText("ignore")
        self.group_page_layout_10.addWidget(self.option_mod_unsigned_int, 96, 1)
        #--------------------------------------------
        self.label_mod_int_prefer_int_on_left = QtWidgets.QLabel(label("<hr>"+self.tr("If there is a situation where mod_int_* and mod_*_int would result in\nmultiple int keywords, whether to keep the rightmost int (the default) or the\nleftmost int.", "mod_int_prefer_int_on_left")))
        self.label_mod_int_prefer_int_on_left.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_int_prefer_int_on_left, 97, 0, 1, 2)
        self.label_option_mod_int_prefer_int_on_left = QtWidgets.QLabel("mod_int_prefer_int_on_left")
        self.label_option_mod_int_prefer_int_on_left.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_int_prefer_int_on_left, 98, 0)
        self.option_mod_int_prefer_int_on_left =  QtWidgets.QComboBox()
        self.option_mod_int_prefer_int_on_left.addItems(['true','false'])
        self.option_mod_int_prefer_int_on_left.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_int_prefer_int_on_left, 98, 1)
        #--------------------------------------------
        self.label_mod_sort_oc_properties = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Whether to organize the properties. If true, properties will be\nrearranged according to the mod_sort_oc_property_*_weight factors.", "mod_sort_oc_properties")))
        self.label_mod_sort_oc_properties.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_sort_oc_properties, 99, 0, 1, 2)
        self.label_option_mod_sort_oc_properties = QtWidgets.QLabel("mod_sort_oc_properties")
        self.label_option_mod_sort_oc_properties.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_sort_oc_properties, 100, 0)
        self.option_mod_sort_oc_properties =  QtWidgets.QComboBox()
        self.option_mod_sort_oc_properties.addItems(['true','false'])
        self.option_mod_sort_oc_properties.setCurrentText("false")
        self.group_page_layout_10.addWidget(self.option_mod_sort_oc_properties, 100, 1)
        #--------------------------------------------
        self.label_mod_sort_oc_property_class_weight = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Weight of a class property modifier.", "mod_sort_oc_property_class_weight")))
        self.label_mod_sort_oc_property_class_weight.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_sort_oc_property_class_weight, 101, 0, 1, 2)
        self.label_option_mod_sort_oc_property_class_weight = QtWidgets.QLabel("mod_sort_oc_property_class_weight")
        self.label_option_mod_sort_oc_property_class_weight.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_sort_oc_property_class_weight, 102, 0)
        self.option_mod_sort_oc_property_class_weight =  QtWidgets.QSpinBox()
        self.option_mod_sort_oc_property_class_weight.setMinimum(-1000)
        self.option_mod_sort_oc_property_class_weight.setMaximum(1000)
        self.option_mod_sort_oc_property_class_weight.setValue(0)
        self.group_page_layout_10.addWidget(self.option_mod_sort_oc_property_class_weight, 102, 1)
        #--------------------------------------------
        self.label_mod_sort_oc_property_thread_safe_weight = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Weight of 'atomic' and 'nonatomic'.", "mod_sort_oc_property_thread_safe_weight")))
        self.label_mod_sort_oc_property_thread_safe_weight.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_sort_oc_property_thread_safe_weight, 103, 0, 1, 2)
        self.label_option_mod_sort_oc_property_thread_safe_weight = QtWidgets.QLabel("mod_sort_oc_property_thread_safe_weight")
        self.label_option_mod_sort_oc_property_thread_safe_weight.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_sort_oc_property_thread_safe_weight, 104, 0)
        self.option_mod_sort_oc_property_thread_safe_weight =  QtWidgets.QSpinBox()
        self.option_mod_sort_oc_property_thread_safe_weight.setMinimum(-1000)
        self.option_mod_sort_oc_property_thread_safe_weight.setMaximum(1000)
        self.option_mod_sort_oc_property_thread_safe_weight.setValue(0)
        self.group_page_layout_10.addWidget(self.option_mod_sort_oc_property_thread_safe_weight, 104, 1)
        #--------------------------------------------
        self.label_mod_sort_oc_property_readwrite_weight = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Weight of 'readwrite' when organizing properties.", "mod_sort_oc_property_readwrite_weight")))
        self.label_mod_sort_oc_property_readwrite_weight.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_sort_oc_property_readwrite_weight, 105, 0, 1, 2)
        self.label_option_mod_sort_oc_property_readwrite_weight = QtWidgets.QLabel("mod_sort_oc_property_readwrite_weight")
        self.label_option_mod_sort_oc_property_readwrite_weight.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_sort_oc_property_readwrite_weight, 106, 0)
        self.option_mod_sort_oc_property_readwrite_weight =  QtWidgets.QSpinBox()
        self.option_mod_sort_oc_property_readwrite_weight.setMinimum(-1000)
        self.option_mod_sort_oc_property_readwrite_weight.setMaximum(1000)
        self.option_mod_sort_oc_property_readwrite_weight.setValue(0)
        self.group_page_layout_10.addWidget(self.option_mod_sort_oc_property_readwrite_weight, 106, 1)
        #--------------------------------------------
        self.label_mod_sort_oc_property_reference_weight = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Weight of a reference type specifier ('retain', 'copy', 'assign',\n'weak', 'strong') when organizing properties.", "mod_sort_oc_property_reference_weight")))
        self.label_mod_sort_oc_property_reference_weight.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_sort_oc_property_reference_weight, 107, 0, 1, 2)
        self.label_option_mod_sort_oc_property_reference_weight = QtWidgets.QLabel("mod_sort_oc_property_reference_weight")
        self.label_option_mod_sort_oc_property_reference_weight.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_sort_oc_property_reference_weight, 108, 0)
        self.option_mod_sort_oc_property_reference_weight =  QtWidgets.QSpinBox()
        self.option_mod_sort_oc_property_reference_weight.setMinimum(-1000)
        self.option_mod_sort_oc_property_reference_weight.setMaximum(1000)
        self.option_mod_sort_oc_property_reference_weight.setValue(0)
        self.group_page_layout_10.addWidget(self.option_mod_sort_oc_property_reference_weight, 108, 1)
        #--------------------------------------------
        self.label_mod_sort_oc_property_getter_weight = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Weight of getter type ('getter=') when organizing properties.", "mod_sort_oc_property_getter_weight")))
        self.label_mod_sort_oc_property_getter_weight.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_sort_oc_property_getter_weight, 109, 0, 1, 2)
        self.label_option_mod_sort_oc_property_getter_weight = QtWidgets.QLabel("mod_sort_oc_property_getter_weight")
        self.label_option_mod_sort_oc_property_getter_weight.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_sort_oc_property_getter_weight, 110, 0)
        self.option_mod_sort_oc_property_getter_weight =  QtWidgets.QSpinBox()
        self.option_mod_sort_oc_property_getter_weight.setMinimum(-1000)
        self.option_mod_sort_oc_property_getter_weight.setMaximum(1000)
        self.option_mod_sort_oc_property_getter_weight.setValue(0)
        self.group_page_layout_10.addWidget(self.option_mod_sort_oc_property_getter_weight, 110, 1)
        #--------------------------------------------
        self.label_mod_sort_oc_property_setter_weight = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Weight of setter type ('setter=') when organizing properties.", "mod_sort_oc_property_setter_weight")))
        self.label_mod_sort_oc_property_setter_weight.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_sort_oc_property_setter_weight, 111, 0, 1, 2)
        self.label_option_mod_sort_oc_property_setter_weight = QtWidgets.QLabel("mod_sort_oc_property_setter_weight")
        self.label_option_mod_sort_oc_property_setter_weight.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_sort_oc_property_setter_weight, 112, 0)
        self.option_mod_sort_oc_property_setter_weight =  QtWidgets.QSpinBox()
        self.option_mod_sort_oc_property_setter_weight.setMinimum(-1000)
        self.option_mod_sort_oc_property_setter_weight.setMaximum(1000)
        self.option_mod_sort_oc_property_setter_weight.setValue(0)
        self.group_page_layout_10.addWidget(self.option_mod_sort_oc_property_setter_weight, 112, 1)
        #--------------------------------------------
        self.label_mod_sort_oc_property_nullability_weight = QtWidgets.QLabel(label("<hr>"+self.tr("(OC) Weight of nullability type ('nullable', 'nonnull', 'null_unspecified',\n'null_resettable') when organizing properties.", "mod_sort_oc_property_nullability_weight")))
        self.label_mod_sort_oc_property_nullability_weight.setWordWrap(True)
        self.group_page_layout_10.addWidget(self.label_mod_sort_oc_property_nullability_weight, 113, 0, 1, 2)
        self.label_option_mod_sort_oc_property_nullability_weight = QtWidgets.QLabel("mod_sort_oc_property_nullability_weight")
        self.label_option_mod_sort_oc_property_nullability_weight.setFont(font_name)
        self.group_page_layout_10.addWidget(self.label_option_mod_sort_oc_property_nullability_weight, 114, 0)
        self.option_mod_sort_oc_property_nullability_weight =  QtWidgets.QSpinBox()
        self.option_mod_sort_oc_property_nullability_weight.setMinimum(-1000)
        self.option_mod_sort_oc_property_nullability_weight.setMaximum(1000)
        self.option_mod_sort_oc_property_nullability_weight.setValue(0)
        self.group_page_layout_10.addWidget(self.option_mod_sort_oc_property_nullability_weight, 114, 1)
        self.group_page_layout_10.addItem(QtWidgets.QSpacerItem(10, 10, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding), 115,0)
        self.scroll_group_page_10 = QtWidgets.QScrollArea()
        self.scroll_group_page_10.setWidget(self.group_page_10)
        self.scroll_group_page_10.setWidgetResizable(True)
        self.addTab(self.scroll_group_page_10, self.tr("Code modifying options (non-whitespace)"))
        #================== Preprocessor options ============================================================
        self.group_page_11 = QtWidgets.QWidget()
        self.group_page_layout_11 = QtWidgets.QGridLayout(self.group_page_11)
        self.group_page_layout_11.addWidget(QtWidgets.QLabel(label(self.tr("Preprocessor options help"))), 0, 0, 1, 2)
        #--------------------------------------------
        self.label_pp_indent_with_tabs = QtWidgets.QLabel(label("<hr>"+self.tr("How to use tabs when indenting preprocessor code.", "pp_indent_with_tabs")+"\n\n"+self.tr("-1: Use 'indent_with_tabs' setting (default)\n 0: Spaces only\n 1: Indent with tabs to brace level, align with spaces\n 2: Indent and align with tabs, using spaces when not on a tabstop", "pp_indent_with_tabs")))
        self.label_pp_indent_with_tabs.setWordWrap(True)
        self.group_page_layout_11.addWidget(self.label_pp_indent_with_tabs, 1, 0, 1, 2)
        self.label_option_pp_indent_with_tabs = QtWidgets.QLabel("pp_indent_with_tabs")
        self.label_option_pp_indent_with_tabs.setFont(font_name)
        self.group_page_layout_11.addWidget(self.label_option_pp_indent_with_tabs, 2, 0)
        self.option_pp_indent_with_tabs =  QtWidgets.QSpinBox()
        self.option_pp_indent_with_tabs.setMinimum( -1)
        self.option_pp_indent_with_tabs.setMaximum( 2)
        self.option_pp_indent_with_tabs.setValue(-1)
        self.group_page_layout_11.addWidget(self.option_pp_indent_with_tabs, 2, 1)
        #--------------------------------------------
        self.label_pp_indent = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove indentation of preprocessor directives inside #if blocks\nat brace level 0 (file-level).", "pp_indent")))
        self.label_pp_indent.setWordWrap(True)
        self.group_page_layout_11.addWidget(self.label_pp_indent, 3, 0, 1, 2)
        self.label_option_pp_indent = QtWidgets.QLabel("pp_indent")
        self.label_option_pp_indent.setFont(font_name)
        self.group_page_layout_11.addWidget(self.label_option_pp_indent, 4, 0)
        self.option_pp_indent =  QtWidgets.QComboBox()
        self.option_pp_indent.addItems(['ignore','add','remove','force','not_defined'])
        self.option_pp_indent.setCurrentText("ignore")
        self.group_page_layout_11.addWidget(self.option_pp_indent, 4, 1)
        #--------------------------------------------
        self.label_pp_indent_at_level = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent #if/#else/#endif at the brace level. If false, these are\nindented from column 1.", "pp_indent_at_level")))
        self.label_pp_indent_at_level.setWordWrap(True)
        self.group_page_layout_11.addWidget(self.label_pp_indent_at_level, 5, 0, 1, 2)
        self.label_option_pp_indent_at_level = QtWidgets.QLabel("pp_indent_at_level")
        self.label_option_pp_indent_at_level.setFont(font_name)
        self.group_page_layout_11.addWidget(self.label_option_pp_indent_at_level, 6, 0)
        self.option_pp_indent_at_level =  QtWidgets.QComboBox()
        self.option_pp_indent_at_level.addItems(['true','false'])
        self.option_pp_indent_at_level.setCurrentText("false")
        self.group_page_layout_11.addWidget(self.option_pp_indent_at_level, 6, 1)
        #--------------------------------------------
        self.label_pp_indent_at_level0 = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent #if/#else/#endif at the parenthesis level if the brace\nlevel is 0. If false, these are indented from column 1.", "pp_indent_at_level0")))
        self.label_pp_indent_at_level0.setWordWrap(True)
        self.group_page_layout_11.addWidget(self.label_pp_indent_at_level0, 7, 0, 1, 2)
        self.label_option_pp_indent_at_level0 = QtWidgets.QLabel("pp_indent_at_level0")
        self.label_option_pp_indent_at_level0.setFont(font_name)
        self.group_page_layout_11.addWidget(self.label_option_pp_indent_at_level0, 8, 0)
        self.option_pp_indent_at_level0 =  QtWidgets.QComboBox()
        self.option_pp_indent_at_level0.addItems(['true','false'])
        self.option_pp_indent_at_level0.setCurrentText("false")
        self.group_page_layout_11.addWidget(self.option_pp_indent_at_level0, 8, 1)
        #--------------------------------------------
        self.label_pp_indent_count = QtWidgets.QLabel(label("<hr>"+self.tr("Specifies the number of columns to indent preprocessors per level\nat brace level 0 (file-level). If pp_indent_at_level=false, also specifies\nthe number of columns to indent preprocessors per level\nat brace level > 0 (function-level).", "pp_indent_count")))
        self.label_pp_indent_count.setWordWrap(True)
        self.group_page_layout_11.addWidget(self.label_pp_indent_count, 9, 0, 1, 2)
        self.label_option_pp_indent_count = QtWidgets.QLabel("pp_indent_count")
        self.label_option_pp_indent_count.setFont(font_name)
        self.group_page_layout_11.addWidget(self.label_option_pp_indent_count, 10, 0)
        self.option_pp_indent_count =  QtWidgets.QSpinBox()
        self.option_pp_indent_count.setMinimum( 0)
        self.option_pp_indent_count.setMaximum( 16)
        self.option_pp_indent_count.setValue(1)
        self.group_page_layout_11.addWidget(self.option_pp_indent_count, 10, 1)
        #--------------------------------------------
        self.label_pp_space_after = QtWidgets.QLabel(label("<hr>"+self.tr("Add or remove space after # based on pp level of #if blocks.", "pp_space_after")))
        self.label_pp_space_after.setWordWrap(True)
        self.group_page_layout_11.addWidget(self.label_pp_space_after, 11, 0, 1, 2)
        self.label_option_pp_space_after = QtWidgets.QLabel("pp_space_after")
        self.label_option_pp_space_after.setFont(font_name)
        self.group_page_layout_11.addWidget(self.label_option_pp_space_after, 12, 0)
        self.option_pp_space_after =  QtWidgets.QComboBox()
        self.option_pp_space_after.addItems(['ignore','add','remove','force','not_defined'])
        self.option_pp_space_after.setCurrentText("ignore")
        self.group_page_layout_11.addWidget(self.option_pp_space_after, 12, 1)
        #--------------------------------------------
        self.label_pp_space_count = QtWidgets.QLabel(label("<hr>"+self.tr("Sets the number of spaces per level added with pp_space_after.", "pp_space_count")))
        self.label_pp_space_count.setWordWrap(True)
        self.group_page_layout_11.addWidget(self.label_pp_space_count, 13, 0, 1, 2)
        self.label_option_pp_space_count = QtWidgets.QLabel("pp_space_count")
        self.label_option_pp_space_count.setFont(font_name)
        self.group_page_layout_11.addWidget(self.label_option_pp_space_count, 14, 0)
        self.option_pp_space_count =  QtWidgets.QSpinBox()
        self.option_pp_space_count.setMinimum( 0)
        self.option_pp_space_count.setMaximum( 16)
        self.option_pp_space_count.setValue(0)
        self.group_page_layout_11.addWidget(self.option_pp_space_count, 14, 1)
        #--------------------------------------------
        self.label_pp_indent_region = QtWidgets.QLabel(label("<hr>"+self.tr("The indent for '#region' and '#endregion' in C# and '#pragma region' in\nC/C++. Negative values decrease indent down to the first column.", "pp_indent_region")))
        self.label_pp_indent_region.setWordWrap(True)
        self.group_page_layout_11.addWidget(self.label_pp_indent_region, 15, 0, 1, 2)
        self.label_option_pp_indent_region = QtWidgets.QLabel("pp_indent_region")
        self.label_option_pp_indent_region.setFont(font_name)
        self.group_page_layout_11.addWidget(self.label_option_pp_indent_region, 16, 0)
        self.option_pp_indent_region =  QtWidgets.QSpinBox()
        self.option_pp_indent_region.setMinimum( -16)
        self.option_pp_indent_region.setMaximum( 16)
        self.option_pp_indent_region.setValue(0)
        self.group_page_layout_11.addWidget(self.option_pp_indent_region, 16, 1)
        #--------------------------------------------
        self.label_pp_region_indent_code = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent the code between #region and #endregion.", "pp_region_indent_code")))
        self.label_pp_region_indent_code.setWordWrap(True)
        self.group_page_layout_11.addWidget(self.label_pp_region_indent_code, 17, 0, 1, 2)
        self.label_option_pp_region_indent_code = QtWidgets.QLabel("pp_region_indent_code")
        self.label_option_pp_region_indent_code.setFont(font_name)
        self.group_page_layout_11.addWidget(self.label_option_pp_region_indent_code, 18, 0)
        self.option_pp_region_indent_code =  QtWidgets.QComboBox()
        self.option_pp_region_indent_code.addItems(['true','false'])
        self.option_pp_region_indent_code.setCurrentText("false")
        self.group_page_layout_11.addWidget(self.option_pp_region_indent_code, 18, 1)
        #--------------------------------------------
        self.label_pp_indent_if = QtWidgets.QLabel(label("<hr>"+self.tr("If pp_indent_at_level=true, sets the indent for #if, #else and #endif when\nnot at file-level. Negative values decrease indent down to the first column.", "pp_indent_if")+"\n\n"+self.tr("=0: Indent preprocessors using output_tab_size\n>0: Column at which all preprocessors will be indented", "pp_indent_if")))
        self.label_pp_indent_if.setWordWrap(True)
        self.group_page_layout_11.addWidget(self.label_pp_indent_if, 19, 0, 1, 2)
        self.label_option_pp_indent_if = QtWidgets.QLabel("pp_indent_if")
        self.label_option_pp_indent_if.setFont(font_name)
        self.group_page_layout_11.addWidget(self.label_option_pp_indent_if, 20, 0)
        self.option_pp_indent_if =  QtWidgets.QSpinBox()
        self.option_pp_indent_if.setMinimum( -16)
        self.option_pp_indent_if.setMaximum( 16)
        self.option_pp_indent_if.setValue(0)
        self.group_page_layout_11.addWidget(self.option_pp_indent_if, 20, 1)
        #--------------------------------------------
        self.label_pp_if_indent_code = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent the code between #if, #else and #endif.", "pp_if_indent_code")))
        self.label_pp_if_indent_code.setWordWrap(True)
        self.group_page_layout_11.addWidget(self.label_pp_if_indent_code, 21, 0, 1, 2)
        self.label_option_pp_if_indent_code = QtWidgets.QLabel("pp_if_indent_code")
        self.label_option_pp_if_indent_code.setFont(font_name)
        self.group_page_layout_11.addWidget(self.label_option_pp_if_indent_code, 22, 0)
        self.option_pp_if_indent_code =  QtWidgets.QComboBox()
        self.option_pp_if_indent_code.addItems(['true','false'])
        self.option_pp_if_indent_code.setCurrentText("false")
        self.group_page_layout_11.addWidget(self.option_pp_if_indent_code, 22, 1)
        #--------------------------------------------
        self.label_pp_indent_in_guard = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent the body of an #if that encompasses all the code in the file.", "pp_indent_in_guard")))
        self.label_pp_indent_in_guard.setWordWrap(True)
        self.group_page_layout_11.addWidget(self.label_pp_indent_in_guard, 23, 0, 1, 2)
        self.label_option_pp_indent_in_guard = QtWidgets.QLabel("pp_indent_in_guard")
        self.label_option_pp_indent_in_guard.setFont(font_name)
        self.group_page_layout_11.addWidget(self.label_option_pp_indent_in_guard, 24, 0)
        self.option_pp_indent_in_guard =  QtWidgets.QComboBox()
        self.option_pp_indent_in_guard.addItems(['true','false'])
        self.option_pp_indent_in_guard.setCurrentText("false")
        self.group_page_layout_11.addWidget(self.option_pp_indent_in_guard, 24, 1)
        #--------------------------------------------
        self.label_pp_define_at_level = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent '#define' at the brace level. If false, these are\nindented from column 1.", "pp_define_at_level")))
        self.label_pp_define_at_level.setWordWrap(True)
        self.group_page_layout_11.addWidget(self.label_pp_define_at_level, 25, 0, 1, 2)
        self.label_option_pp_define_at_level = QtWidgets.QLabel("pp_define_at_level")
        self.label_option_pp_define_at_level.setFont(font_name)
        self.group_page_layout_11.addWidget(self.label_option_pp_define_at_level, 26, 0)
        self.option_pp_define_at_level =  QtWidgets.QComboBox()
        self.option_pp_define_at_level.addItems(['true','false'])
        self.option_pp_define_at_level.setCurrentText("false")
        self.group_page_layout_11.addWidget(self.option_pp_define_at_level, 26, 1)
        #--------------------------------------------
        self.label_pp_include_at_level = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent '#include' at the brace level.", "pp_include_at_level")))
        self.label_pp_include_at_level.setWordWrap(True)
        self.group_page_layout_11.addWidget(self.label_pp_include_at_level, 27, 0, 1, 2)
        self.label_option_pp_include_at_level = QtWidgets.QLabel("pp_include_at_level")
        self.label_option_pp_include_at_level.setFont(font_name)
        self.group_page_layout_11.addWidget(self.label_option_pp_include_at_level, 28, 0)
        self.option_pp_include_at_level =  QtWidgets.QComboBox()
        self.option_pp_include_at_level.addItems(['true','false'])
        self.option_pp_include_at_level.setCurrentText("false")
        self.group_page_layout_11.addWidget(self.option_pp_include_at_level, 28, 1)
        #--------------------------------------------
        self.label_pp_ignore_define_body = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to ignore the '#define' body while formatting.", "pp_ignore_define_body")))
        self.label_pp_ignore_define_body.setWordWrap(True)
        self.group_page_layout_11.addWidget(self.label_pp_ignore_define_body, 29, 0, 1, 2)
        self.label_option_pp_ignore_define_body = QtWidgets.QLabel("pp_ignore_define_body")
        self.label_option_pp_ignore_define_body.setFont(font_name)
        self.group_page_layout_11.addWidget(self.label_option_pp_ignore_define_body, 30, 0)
        self.option_pp_ignore_define_body =  QtWidgets.QComboBox()
        self.option_pp_ignore_define_body.addItems(['true','false'])
        self.option_pp_ignore_define_body.setCurrentText("false")
        self.group_page_layout_11.addWidget(self.option_pp_ignore_define_body, 30, 1)
        #--------------------------------------------
        self.label_pp_multiline_define_body_indent = QtWidgets.QLabel(label("<hr>"+self.tr("An offset value that controls the indentation of the body of a multiline #define.\n'body' refers to all the lines of a multiline #define except the first line.\nRequires 'pp_ignore_define_body = false'.", "pp_multiline_define_body_indent")+"\n\n"+self.tr(" <0: Absolute column: the body indentation starts off at the specified column\n     (ex. -3 ==> the body is indented starting from column 3)\n>=0: Relative to the column of the '#' of '#define'\n     (ex.  3 ==> the body is indented starting 3 columns at the right of '#')", "pp_multiline_define_body_indent")))
        self.label_pp_multiline_define_body_indent.setWordWrap(True)
        self.group_page_layout_11.addWidget(self.label_pp_multiline_define_body_indent, 31, 0, 1, 2)
        self.label_option_pp_multiline_define_body_indent = QtWidgets.QLabel("pp_multiline_define_body_indent")
        self.label_option_pp_multiline_define_body_indent.setFont(font_name)
        self.group_page_layout_11.addWidget(self.label_option_pp_multiline_define_body_indent, 32, 0)
        self.option_pp_multiline_define_body_indent =  QtWidgets.QSpinBox()
        self.option_pp_multiline_define_body_indent.setMinimum( -32)
        self.option_pp_multiline_define_body_indent.setMaximum( 32)
        self.option_pp_multiline_define_body_indent.setValue(8)
        self.group_page_layout_11.addWidget(self.option_pp_multiline_define_body_indent, 32, 1)
        #--------------------------------------------
        self.label_pp_indent_case = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent case statements between #if, #else, and #endif.\nOnly applies to the indent of the preprocessor that the case statements\ndirectly inside of.", "pp_indent_case")))
        self.label_pp_indent_case.setWordWrap(True)
        self.group_page_layout_11.addWidget(self.label_pp_indent_case, 33, 0, 1, 2)
        self.label_option_pp_indent_case = QtWidgets.QLabel("pp_indent_case")
        self.label_option_pp_indent_case.setFont(font_name)
        self.group_page_layout_11.addWidget(self.label_option_pp_indent_case, 34, 0)
        self.option_pp_indent_case =  QtWidgets.QComboBox()
        self.option_pp_indent_case.addItems(['true','false'])
        self.option_pp_indent_case.setCurrentText("true")
        self.group_page_layout_11.addWidget(self.option_pp_indent_case, 34, 1)
        #--------------------------------------------
        self.label_pp_indent_func_def = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent whole function definitions between #if, #else, and #endif.\nOnly applies to the indent of the preprocessor that the function definition\nis directly inside of.", "pp_indent_func_def")))
        self.label_pp_indent_func_def.setWordWrap(True)
        self.group_page_layout_11.addWidget(self.label_pp_indent_func_def, 35, 0, 1, 2)
        self.label_option_pp_indent_func_def = QtWidgets.QLabel("pp_indent_func_def")
        self.label_option_pp_indent_func_def.setFont(font_name)
        self.group_page_layout_11.addWidget(self.label_option_pp_indent_func_def, 36, 0)
        self.option_pp_indent_func_def =  QtWidgets.QComboBox()
        self.option_pp_indent_func_def.addItems(['true','false'])
        self.option_pp_indent_func_def.setCurrentText("true")
        self.group_page_layout_11.addWidget(self.option_pp_indent_func_def, 36, 1)
        #--------------------------------------------
        self.label_pp_indent_extern = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to indent extern C blocks between #if, #else, and #endif.\nOnly applies to the indent of the preprocessor that the extern block is\ndirectly inside of.", "pp_indent_extern")))
        self.label_pp_indent_extern.setWordWrap(True)
        self.group_page_layout_11.addWidget(self.label_pp_indent_extern, 37, 0, 1, 2)
        self.label_option_pp_indent_extern = QtWidgets.QLabel("pp_indent_extern")
        self.label_option_pp_indent_extern.setFont(font_name)
        self.group_page_layout_11.addWidget(self.label_option_pp_indent_extern, 38, 0)
        self.option_pp_indent_extern =  QtWidgets.QComboBox()
        self.option_pp_indent_extern.addItems(['true','false'])
        self.option_pp_indent_extern.setCurrentText("true")
        self.group_page_layout_11.addWidget(self.option_pp_indent_extern, 38, 1)
        #--------------------------------------------
        self.label_pp_indent_brace = QtWidgets.QLabel(label("<hr>"+self.tr("How to indent braces directly inside #if, #else, and #endif.\nRequires pp_if_indent_code=true and only applies to the indent of the\npreprocessor that the braces are directly inside of.\n 0: No extra indent\n 1: Indent by one level\n-1: Preserve original indentation", "pp_indent_brace")))
        self.label_pp_indent_brace.setWordWrap(True)
        self.group_page_layout_11.addWidget(self.label_pp_indent_brace, 39, 0, 1, 2)
        self.label_option_pp_indent_brace = QtWidgets.QLabel("pp_indent_brace")
        self.label_option_pp_indent_brace.setFont(font_name)
        self.group_page_layout_11.addWidget(self.label_option_pp_indent_brace, 40, 0)
        self.option_pp_indent_brace =  QtWidgets.QSpinBox()
        self.option_pp_indent_brace.setMinimum( -1)
        self.option_pp_indent_brace.setMaximum( 1)
        self.option_pp_indent_brace.setValue(1)
        self.group_page_layout_11.addWidget(self.option_pp_indent_brace, 40, 1)
        #--------------------------------------------
        self.label_pp_unbalanced_if_action = QtWidgets.QLabel(label("<hr>"+self.tr("Action to perform when unbalanced #if and #else blocks are found.\n0: do nothing\n1: print a warning message\n2: terminate the program with an error (EX_SOFTWARE)", "pp_unbalanced_if_action")+"\n\n"+self.tr("The action will be triggered in the following cases:\n- if an #ifdef block ends on a different indent level than\n  where it started from. Example:", "pp_unbalanced_if_action")+"\n\n"+self.tr("   #ifdef TEST\n     int i;\n     {\n       int j;\n   #endif", "pp_unbalanced_if_action")+"\n\n"+self.tr("- an #elif/#else block ends on a different indent level than\n  the corresponding #ifdef block. Example:", "pp_unbalanced_if_action")+"\n\n"+self.tr("   #ifdef TEST\n       int i;\n   #else\n       }\n     int j;\n   #endif", "pp_unbalanced_if_action")))
        self.label_pp_unbalanced_if_action.setWordWrap(True)
        self.group_page_layout_11.addWidget(self.label_pp_unbalanced_if_action, 41, 0, 1, 2)
        self.label_option_pp_unbalanced_if_action = QtWidgets.QLabel("pp_unbalanced_if_action")
        self.label_option_pp_unbalanced_if_action.setFont(font_name)
        self.group_page_layout_11.addWidget(self.label_option_pp_unbalanced_if_action, 42, 0)
        self.option_pp_unbalanced_if_action =  QtWidgets.QSpinBox()
        self.option_pp_unbalanced_if_action.setMinimum( 0)
        self.option_pp_unbalanced_if_action.setMaximum( 2)
        self.option_pp_unbalanced_if_action.setValue(0)
        self.group_page_layout_11.addWidget(self.option_pp_unbalanced_if_action, 42, 1)
        self.group_page_layout_11.addItem(QtWidgets.QSpacerItem(10, 10, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding), 43,0)
        self.scroll_group_page_11 = QtWidgets.QScrollArea()
        self.scroll_group_page_11.setWidget(self.group_page_11)
        self.scroll_group_page_11.setWidgetResizable(True)
        self.addTab(self.scroll_group_page_11, self.tr("Preprocessor options"))
        #================== Sort includes options ===========================================================
        self.group_page_12 = QtWidgets.QWidget()
        self.group_page_layout_12 = QtWidgets.QGridLayout(self.group_page_12)
        self.group_page_layout_12.addWidget(QtWidgets.QLabel(label(self.tr("Sort includes options help"))), 0, 0, 1, 2)
        #--------------------------------------------
        self.label_include_category_0 = QtWidgets.QLabel(label("<hr>"+self.tr("The regex for include category with priority 0.", "include_category_0")))
        self.label_include_category_0.setWordWrap(True)
        self.group_page_layout_12.addWidget(self.label_include_category_0, 1, 0, 1, 2)
        self.label_option_include_category_0 = QtWidgets.QLabel("include_category_0")
        self.label_option_include_category_0.setFont(font_name)
        self.group_page_layout_12.addWidget(self.label_option_include_category_0, 2, 0)
        self.option_include_category_0 =  QtWidgets.QLineEdit("")
        self.group_page_layout_12.addWidget(self.option_include_category_0, 2, 1)
        #--------------------------------------------
        self.label_include_category_1 = QtWidgets.QLabel(label("<hr>"+self.tr("The regex for include category with priority 1.", "include_category_1")))
        self.label_include_category_1.setWordWrap(True)
        self.group_page_layout_12.addWidget(self.label_include_category_1, 3, 0, 1, 2)
        self.label_option_include_category_1 = QtWidgets.QLabel("include_category_1")
        self.label_option_include_category_1.setFont(font_name)
        self.group_page_layout_12.addWidget(self.label_option_include_category_1, 4, 0)
        self.option_include_category_1 =  QtWidgets.QLineEdit("")
        self.group_page_layout_12.addWidget(self.option_include_category_1, 4, 1)
        #--------------------------------------------
        self.label_include_category_2 = QtWidgets.QLabel(label("<hr>"+self.tr("The regex for include category with priority 2.", "include_category_2")))
        self.label_include_category_2.setWordWrap(True)
        self.group_page_layout_12.addWidget(self.label_include_category_2, 5, 0, 1, 2)
        self.label_option_include_category_2 = QtWidgets.QLabel("include_category_2")
        self.label_option_include_category_2.setFont(font_name)
        self.group_page_layout_12.addWidget(self.label_option_include_category_2, 6, 0)
        self.option_include_category_2 =  QtWidgets.QLineEdit("")
        self.group_page_layout_12.addWidget(self.option_include_category_2, 6, 1)
        self.group_page_layout_12.addItem(QtWidgets.QSpacerItem(10, 10, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding), 7,0)
        self.scroll_group_page_12 = QtWidgets.QScrollArea()
        self.scroll_group_page_12.setWidget(self.group_page_12)
        self.scroll_group_page_12.setWidgetResizable(True)
        self.addTab(self.scroll_group_page_12, self.tr("Sort includes options"))
        #================== Use or Do not Use options =======================================================
        self.group_page_13 = QtWidgets.QWidget()
        self.group_page_layout_13 = QtWidgets.QGridLayout(self.group_page_13)
        self.group_page_layout_13.addWidget(QtWidgets.QLabel(label(self.tr("Use or Do not Use options help"))), 0, 0, 1, 2)
        #--------------------------------------------
        self.label_use_indent_func_call_param = QtWidgets.QLabel(label("<hr>"+self.tr("true:  indent_func_call_param will be used (default)\nfalse: indent_func_call_param will NOT be used", "use_indent_func_call_param")))
        self.label_use_indent_func_call_param.setWordWrap(True)
        self.group_page_layout_13.addWidget(self.label_use_indent_func_call_param, 1, 0, 1, 2)
        self.label_option_use_indent_func_call_param = QtWidgets.QLabel("use_indent_func_call_param")
        self.label_option_use_indent_func_call_param.setFont(font_name)
        self.group_page_layout_13.addWidget(self.label_option_use_indent_func_call_param, 2, 0)
        self.option_use_indent_func_call_param =  QtWidgets.QComboBox()
        self.option_use_indent_func_call_param.addItems(['true','false'])
        self.option_use_indent_func_call_param.setCurrentText("true")
        self.group_page_layout_13.addWidget(self.option_use_indent_func_call_param, 2, 1)
        #--------------------------------------------
        self.label_use_indent_continue_only_once = QtWidgets.QLabel(label("<hr>"+self.tr("The value of the indentation for a continuation line is calculated\ndifferently if the statement is:\n- a declaration: your case with QString fileName ...\n- an assignment: your case with pSettings = new QSettings( ...", "use_indent_continue_only_once")+"\n\n"+self.tr("At the second case the indentation value might be used twice:\n- at the assignment\n- at the function call (if present)", "use_indent_continue_only_once")+"\n\n"+self.tr("To prevent the double use of the indentation value, use this option with the\nvalue 'true'.", "use_indent_continue_only_once")+"\n\n"+self.tr("true:  indent_continue will be used only once\nfalse: indent_continue will be used every time (default)", "use_indent_continue_only_once")+"\n\n"+self.tr("Requires indent_ignore_first_continue=false.", "use_indent_continue_only_once")))
        self.label_use_indent_continue_only_once.setWordWrap(True)
        self.group_page_layout_13.addWidget(self.label_use_indent_continue_only_once, 3, 0, 1, 2)
        self.label_option_use_indent_continue_only_once = QtWidgets.QLabel("use_indent_continue_only_once")
        self.label_option_use_indent_continue_only_once.setFont(font_name)
        self.group_page_layout_13.addWidget(self.label_option_use_indent_continue_only_once, 4, 0)
        self.option_use_indent_continue_only_once =  QtWidgets.QComboBox()
        self.option_use_indent_continue_only_once.addItems(['true','false'])
        self.option_use_indent_continue_only_once.setCurrentText("false")
        self.group_page_layout_13.addWidget(self.option_use_indent_continue_only_once, 4, 1)
        #--------------------------------------------
        self.label_indent_cpp_lambda_only_once = QtWidgets.QLabel(label("<hr>"+self.tr("The indentation can be:\n- after the assignment, at the '[' character\n- at the beginning of the lambda body", "indent_cpp_lambda_only_once")+"\n\n"+self.tr("true:  indentation will be at the beginning of the lambda body\nfalse: indentation will be after the assignment (default)", "indent_cpp_lambda_only_once")))
        self.label_indent_cpp_lambda_only_once.setWordWrap(True)
        self.group_page_layout_13.addWidget(self.label_indent_cpp_lambda_only_once, 5, 0, 1, 2)
        self.label_option_indent_cpp_lambda_only_once = QtWidgets.QLabel("indent_cpp_lambda_only_once")
        self.label_option_indent_cpp_lambda_only_once.setFont(font_name)
        self.group_page_layout_13.addWidget(self.label_option_indent_cpp_lambda_only_once, 6, 0)
        self.option_indent_cpp_lambda_only_once =  QtWidgets.QComboBox()
        self.option_indent_cpp_lambda_only_once.addItems(['true','false'])
        self.option_indent_cpp_lambda_only_once.setCurrentText("false")
        self.group_page_layout_13.addWidget(self.option_indent_cpp_lambda_only_once, 6, 1)
        #--------------------------------------------
        self.label_use_sp_after_angle_always = QtWidgets.QLabel(label("<hr>"+self.tr("Whether sp_after_angle takes precedence over sp_inside_fparen. This was the\nhistoric behavior, but is probably not the desired behavior, so this is off\nby default.", "use_sp_after_angle_always")))
        self.label_use_sp_after_angle_always.setWordWrap(True)
        self.group_page_layout_13.addWidget(self.label_use_sp_after_angle_always, 7, 0, 1, 2)
        self.label_option_use_sp_after_angle_always = QtWidgets.QLabel("use_sp_after_angle_always")
        self.label_option_use_sp_after_angle_always.setFont(font_name)
        self.group_page_layout_13.addWidget(self.label_option_use_sp_after_angle_always, 8, 0)
        self.option_use_sp_after_angle_always =  QtWidgets.QComboBox()
        self.option_use_sp_after_angle_always.addItems(['true','false'])
        self.option_use_sp_after_angle_always.setCurrentText("false")
        self.group_page_layout_13.addWidget(self.option_use_sp_after_angle_always, 8, 1)
        #--------------------------------------------
        self.label_use_options_overriding_for_qt_macros = QtWidgets.QLabel(label("<hr>"+self.tr("Whether to apply special formatting for Qt SIGNAL/SLOT macros. Essentially,\nthis tries to format these so that they match Qt's normalized form (i.e. the\nresult of QMetaObject::normalizedSignature), which can slightly improve the\nperformance of the QObject::connect call, rather than how they would\notherwise be formatted.", "use_options_overriding_for_qt_macros")+"\n\n"+self.tr("See options_for_QT.cpp for details.", "use_options_overriding_for_qt_macros")))
        self.label_use_options_overriding_for_qt_macros.setWordWrap(True)
        self.group_page_layout_13.addWidget(self.label_use_options_overriding_for_qt_macros, 9, 0, 1, 2)
        self.label_option_use_options_overriding_for_qt_macros = QtWidgets.QLabel("use_options_overriding_for_qt_macros")
        self.label_option_use_options_overriding_for_qt_macros.setFont(font_name)
        self.group_page_layout_13.addWidget(self.label_option_use_options_overriding_for_qt_macros, 10, 0)
        self.option_use_options_overriding_for_qt_macros =  QtWidgets.QComboBox()
        self.option_use_options_overriding_for_qt_macros.addItems(['true','false'])
        self.option_use_options_overriding_for_qt_macros.setCurrentText("true")
        self.group_page_layout_13.addWidget(self.option_use_options_overriding_for_qt_macros, 10, 1)
        #--------------------------------------------
        self.label_use_form_feed_no_more_as_whitespace_character = QtWidgets.QLabel(label("<hr>"+self.tr("If true: the form feed character is removed from the list of whitespace\ncharacters. See https://en.cppreference.com/w/cpp/string/byte/isspace.", "use_form_feed_no_more_as_whitespace_character")))
        self.label_use_form_feed_no_more_as_whitespace_character.setWordWrap(True)
        self.group_page_layout_13.addWidget(self.label_use_form_feed_no_more_as_whitespace_character, 11, 0, 1, 2)
        self.label_option_use_form_feed_no_more_as_whitespace_character = QtWidgets.QLabel("use_form_feed_no_more_as_whitespace_character")
        self.label_option_use_form_feed_no_more_as_whitespace_character.setFont(font_name)
        self.group_page_layout_13.addWidget(self.label_option_use_form_feed_no_more_as_whitespace_character, 12, 0)
        self.option_use_form_feed_no_more_as_whitespace_character =  QtWidgets.QComboBox()
        self.option_use_form_feed_no_more_as_whitespace_character.addItems(['true','false'])
        self.option_use_form_feed_no_more_as_whitespace_character.setCurrentText("false")
        self.group_page_layout_13.addWidget(self.option_use_form_feed_no_more_as_whitespace_character, 12, 1)
        self.group_page_layout_13.addItem(QtWidgets.QSpacerItem(10, 10, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding), 13,0)
        self.scroll_group_page_13 = QtWidgets.QScrollArea()
        self.scroll_group_page_13.setWidget(self.group_page_13)
        self.scroll_group_page_13.setWidgetResizable(True)
        self.addTab(self.scroll_group_page_13, self.tr("Use or Do not Use options"))
        #================== Warn levels - 1: error, 2: warning (default), 3: note ===========================
        self.group_page_14 = QtWidgets.QWidget()
        self.group_page_layout_14 = QtWidgets.QGridLayout(self.group_page_14)
        self.group_page_layout_14.addWidget(QtWidgets.QLabel(label(self.tr("Warn levels - 1: error, 2: warning (default), 3: note help"))), 0, 0, 1, 2)
        #--------------------------------------------
        self.label_warn_level_tabs_found_in_verbatim_string_literals = QtWidgets.QLabel(label("<hr>"+self.tr("(C#) Warning is given if doing tab-to-\\t replacement and we have found one\nin a C# verbatim string literal.", "warn_level_tabs_found_in_verbatim_string_literals")))
        self.label_warn_level_tabs_found_in_verbatim_string_literals.setWordWrap(True)
        self.group_page_layout_14.addWidget(self.label_warn_level_tabs_found_in_verbatim_string_literals, 1, 0, 1, 2)
        self.label_option_warn_level_tabs_found_in_verbatim_string_literals = QtWidgets.QLabel("warn_level_tabs_found_in_verbatim_string_literals")
        self.label_option_warn_level_tabs_found_in_verbatim_string_literals.setFont(font_name)
        self.group_page_layout_14.addWidget(self.label_option_warn_level_tabs_found_in_verbatim_string_literals, 2, 0)
        self.option_warn_level_tabs_found_in_verbatim_string_literals =  QtWidgets.QSpinBox()
        self.option_warn_level_tabs_found_in_verbatim_string_literals.setMinimum( 1)
        self.option_warn_level_tabs_found_in_verbatim_string_literals.setMaximum( 3)
        self.option_warn_level_tabs_found_in_verbatim_string_literals.setValue(2)
        self.group_page_layout_14.addWidget(self.option_warn_level_tabs_found_in_verbatim_string_literals, 2, 1)
        #--------------------------------------------
        self.label_debug_max_number_of_loops = QtWidgets.QLabel(label("<hr>"+self.tr("Limit the number of loops.\nUsed by uncrustify.cpp to exit from infinite loop.\n0: no limit.", "debug_max_number_of_loops")))
        self.label_debug_max_number_of_loops.setWordWrap(True)
        self.group_page_layout_14.addWidget(self.label_debug_max_number_of_loops, 3, 0, 1, 2)
        self.label_option_debug_max_number_of_loops = QtWidgets.QLabel("debug_max_number_of_loops")
        self.label_option_debug_max_number_of_loops.setFont(font_name)
        self.group_page_layout_14.addWidget(self.label_option_debug_max_number_of_loops, 4, 0)
        self.option_debug_max_number_of_loops =  QtWidgets.QSpinBox()
        self.option_debug_max_number_of_loops.setMinimum(-1000)
        self.option_debug_max_number_of_loops.setMaximum(1000)
        self.option_debug_max_number_of_loops.setValue(0)
        self.group_page_layout_14.addWidget(self.option_debug_max_number_of_loops, 4, 1)
        #--------------------------------------------
        self.label_debug_line_number_to_protocol = QtWidgets.QLabel(label("<hr>"+self.tr("Set the number of the line to protocol;\nUsed in the function prot_the_line if the 2. parameter is zero.\n0: nothing protocol.", "debug_line_number_to_protocol")))
        self.label_debug_line_number_to_protocol.setWordWrap(True)
        self.group_page_layout_14.addWidget(self.label_debug_line_number_to_protocol, 5, 0, 1, 2)
        self.label_option_debug_line_number_to_protocol = QtWidgets.QLabel("debug_line_number_to_protocol")
        self.label_option_debug_line_number_to_protocol.setFont(font_name)
        self.group_page_layout_14.addWidget(self.label_option_debug_line_number_to_protocol, 6, 0)
        self.option_debug_line_number_to_protocol =  QtWidgets.QSpinBox()
        self.option_debug_line_number_to_protocol.setMinimum(-1000)
        self.option_debug_line_number_to_protocol.setMaximum(1000)
        self.option_debug_line_number_to_protocol.setValue(0)
        self.group_page_layout_14.addWidget(self.option_debug_line_number_to_protocol, 6, 1)
        #--------------------------------------------
        self.label_debug_timeout = QtWidgets.QLabel(label("<hr>"+self.tr("Set the number of second(s) before terminating formatting the current file,\n0: no timeout.\nonly for linux", "debug_timeout")))
        self.label_debug_timeout.setWordWrap(True)
        self.group_page_layout_14.addWidget(self.label_debug_timeout, 7, 0, 1, 2)
        self.label_option_debug_timeout = QtWidgets.QLabel("debug_timeout")
        self.label_option_debug_timeout.setFont(font_name)
        self.group_page_layout_14.addWidget(self.label_option_debug_timeout, 8, 0)
        self.option_debug_timeout =  QtWidgets.QSpinBox()
        self.option_debug_timeout.setMinimum(-1000)
        self.option_debug_timeout.setMaximum(1000)
        self.option_debug_timeout.setValue(0)
        self.group_page_layout_14.addWidget(self.option_debug_timeout, 8, 1)
        #--------------------------------------------
        self.label_debug_truncate = QtWidgets.QLabel(label("<hr>"+self.tr("Set the number of characters to be printed if the text is too long,\n0: do not truncate.", "debug_truncate")))
        self.label_debug_truncate.setWordWrap(True)
        self.group_page_layout_14.addWidget(self.label_debug_truncate, 9, 0, 1, 2)
        self.label_option_debug_truncate = QtWidgets.QLabel("debug_truncate")
        self.label_option_debug_truncate.setFont(font_name)
        self.group_page_layout_14.addWidget(self.label_option_debug_truncate, 10, 0)
        self.option_debug_truncate =  QtWidgets.QSpinBox()
        self.option_debug_truncate.setMinimum( 0)
        self.option_debug_truncate.setMaximum( 960)
        self.option_debug_truncate.setValue(0)
        self.group_page_layout_14.addWidget(self.option_debug_truncate, 10, 1)
        #--------------------------------------------
        self.label_debug_sort_the_tracks = QtWidgets.QLabel(label("<hr>"+self.tr("sort (or not) the tracking info.", "debug_sort_the_tracks")))
        self.label_debug_sort_the_tracks.setWordWrap(True)
        self.group_page_layout_14.addWidget(self.label_debug_sort_the_tracks, 11, 0, 1, 2)
        self.label_option_debug_sort_the_tracks = QtWidgets.QLabel("debug_sort_the_tracks")
        self.label_option_debug_sort_the_tracks.setFont(font_name)
        self.group_page_layout_14.addWidget(self.label_option_debug_sort_the_tracks, 12, 0)
        self.option_debug_sort_the_tracks =  QtWidgets.QComboBox()
        self.option_debug_sort_the_tracks.addItems(['true','false'])
        self.option_debug_sort_the_tracks.setCurrentText("true")
        self.group_page_layout_14.addWidget(self.option_debug_sort_the_tracks, 12, 1)
        #--------------------------------------------
        self.label_debug_decode_the_flags = QtWidgets.QLabel(label("<hr>"+self.tr("decode (or not) the flags as a new line.\nonly if the -p option is set.", "debug_decode_the_flags")))
        self.label_debug_decode_the_flags.setWordWrap(True)
        self.group_page_layout_14.addWidget(self.label_debug_decode_the_flags, 13, 0, 1, 2)
        self.label_option_debug_decode_the_flags = QtWidgets.QLabel("debug_decode_the_flags")
        self.label_option_debug_decode_the_flags.setFont(font_name)
        self.group_page_layout_14.addWidget(self.label_option_debug_decode_the_flags, 14, 0)
        self.option_debug_decode_the_flags =  QtWidgets.QComboBox()
        self.option_debug_decode_the_flags.addItems(['true','false'])
        self.option_debug_decode_the_flags.setCurrentText("false")
        self.group_page_layout_14.addWidget(self.option_debug_decode_the_flags, 14, 1)
        #--------------------------------------------
        self.label_debug_use_the_exit_function_pop = QtWidgets.QLabel(label("<hr>"+self.tr("use (or not) the exit(EX_SOFTWARE) function.", "debug_use_the_exit_function_pop")))
        self.label_debug_use_the_exit_function_pop.setWordWrap(True)
        self.group_page_layout_14.addWidget(self.label_debug_use_the_exit_function_pop, 15, 0, 1, 2)
        self.label_option_debug_use_the_exit_function_pop = QtWidgets.QLabel("debug_use_the_exit_function_pop")
        self.label_option_debug_use_the_exit_function_pop.setFont(font_name)
        self.group_page_layout_14.addWidget(self.label_option_debug_use_the_exit_function_pop, 16, 0)
        self.option_debug_use_the_exit_function_pop =  QtWidgets.QComboBox()
        self.option_debug_use_the_exit_function_pop.addItems(['true','false'])
        self.option_debug_use_the_exit_function_pop.setCurrentText("true")
        self.group_page_layout_14.addWidget(self.option_debug_use_the_exit_function_pop, 16, 1)
        #--------------------------------------------
        self.label_debug_print_version = QtWidgets.QLabel(label("<hr>"+self.tr("print (or not) the version in the file defined at the command option -o.", "debug_print_version")))
        self.label_debug_print_version.setWordWrap(True)
        self.group_page_layout_14.addWidget(self.label_debug_print_version, 17, 0, 1, 2)
        self.label_option_debug_print_version = QtWidgets.QLabel("debug_print_version")
        self.label_option_debug_print_version.setFont(font_name)
        self.group_page_layout_14.addWidget(self.label_option_debug_print_version, 18, 0)
        self.option_debug_print_version =  QtWidgets.QComboBox()
        self.option_debug_print_version.addItems(['true','false'])
        self.option_debug_print_version.setCurrentText("false")
        self.group_page_layout_14.addWidget(self.option_debug_print_version, 18, 1)
        #--------------------------------------------
        self.label_set_numbering_for_html_output = QtWidgets.QLabel(label("<hr>"+self.tr("insert the number of the line at the beginning of each line", "set_numbering_for_html_output")))
        self.label_set_numbering_for_html_output.setWordWrap(True)
        self.group_page_layout_14.addWidget(self.label_set_numbering_for_html_output, 19, 0, 1, 2)
        self.label_option_set_numbering_for_html_output = QtWidgets.QLabel("set_numbering_for_html_output")
        self.label_option_set_numbering_for_html_output.setFont(font_name)
        self.group_page_layout_14.addWidget(self.label_option_set_numbering_for_html_output, 20, 0)
        self.option_set_numbering_for_html_output =  QtWidgets.QComboBox()
        self.option_set_numbering_for_html_output.addItems(['true','false'])
        self.option_set_numbering_for_html_output.setCurrentText("false")
        self.group_page_layout_14.addWidget(self.option_set_numbering_for_html_output, 20, 1)
        self.group_page_layout_14.addItem(QtWidgets.QSpacerItem(10, 10, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Expanding), 21,0)
        self.scroll_group_page_14 = QtWidgets.QScrollArea()
        self.scroll_group_page_14.setWidget(self.group_page_14)
        self.scroll_group_page_14.setWidgetResizable(True)
        self.addTab(self.scroll_group_page_14, self.tr("Warn levels - 1: error, 2: warning (default), 3: note"))
    ###########################################################################################
    ###########################################################################################
    ###########################################################################################
    ###########################################################################################
    ###########################################################################################
    def get(self, full=True, comment=True):
        s=[]
        if self.comment_type==1:
            self.tr=self.no_tr
        else:
            self.tr=super(Widget, self).tr

        #================== General options =================================================================
        if full or  comment: s.append('\n\n'+'#'*80+self.wrap(self.tr("General options"))+'\n'+'#'*80)
        if full or  'auto'!=self.option_newlines.currentText():
            if comment:
                s.append(self.wrap(self.tr("The type of line endings.", "newlines")))
                s.append("#\n# Type: lf/crlf/cr/auto")
                s.append("# Default: auto ")
            s.append('newlines = ' + self.option_newlines.currentText())
        if full or  8!=self.option_input_tab_size.value():
            if comment:
                s.append(self.wrap(self.tr("The original size of tabs in the input.", "input_tab_size")))
                s.append("#\n# Type: unsigned  1  32")
                s.append("# Default: 8 ")
            s.append('input_tab_size = ' + str(self.option_input_tab_size.value()))
        if full or  8!=self.option_output_tab_size.value():
            if comment:
                s.append(self.wrap(self.tr("The size of tabs in the output (only used if align_with_tabs=true).", "output_tab_size")))
                s.append("#\n# Type: unsigned  1  32")
                s.append("# Default: 8 ")
            s.append('output_tab_size = ' + str(self.option_output_tab_size.value()))
        if full or  92!=self.option_string_escape_char.value():
            if comment:
                s.append(self.wrap(self.tr("The ASCII value of the string escape char, usually 92 (\\) or (Pawn) 94 (^).", "string_escape_char")))
                s.append("#\n# Type: unsigned  0  255")
                s.append("# Default: 92 ")
            s.append('string_escape_char = ' + str(self.option_string_escape_char.value()))
        if full or  0!=self.option_string_escape_char2.value():
            if comment:
                s.append(self.wrap(self.tr("Alternate string escape char (usually only used for Pawn).\nOnly works right before the quote char.", "string_escape_char2")))
                s.append("#\n# Type: unsigned  0  255")
                s.append("# Default: 0 ")
            s.append('string_escape_char2 = ' + str(self.option_string_escape_char2.value()))
        if full or  'false'!=self.option_string_replace_tab_chars.currentText():
            if comment:
                s.append(self.wrap(self.tr("Replace tab characters found in string literals with the escape sequence \\t\ninstead.", "string_replace_tab_chars")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('string_replace_tab_chars = ' + self.option_string_replace_tab_chars.currentText())
        if full or  'false'!=self.option_tok_split_gte.currentText():
            if comment:
                s.append(self.wrap(self.tr("Allow interpreting '>=' and '>>=' as part of a template in code like\n'void f(list<list<B>>=val);'. If true, 'assert(x<0 && y>=3)' will be broken.\nImprovements to template detection may make this option obsolete.", "tok_split_gte")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('tok_split_gte = ' + self.option_tok_split_gte.currentText())
        if full or  'false'!=self.option_disable_processing_nl_cont.currentText():
            if comment:
                s.append(self.wrap(self.tr("Disable formatting of NL_CONT ('\\\\n') ended lines (e.g. multi-line macros).", "disable_processing_nl_cont")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('disable_processing_nl_cont = ' + self.option_disable_processing_nl_cont.currentText())
        if full or  'UNCRUSTIFY_OFF_TEXT'!=self.option_disable_processing_cmt.text():
            if comment:
                s.append(self.wrap(self.tr("Specify the marker used in comments to disable processing of part of the\nfile.", "disable_processing_cmt")))
                s.append("#\n# Type: string")
                s.append("# Default: UNCRUSTIFY_OFF_TEXT ")
            s.append('disable_processing_cmt = "' + self.option_disable_processing_cmt.text()+'"\n')
        if full or  'UNCRUSTIFY_ON_TEXT'!=self.option_enable_processing_cmt.text():
            if comment:
                s.append(self.wrap(self.tr("Specify the marker used in comments to (re)enable processing in a file.", "enable_processing_cmt")))
                s.append("#\n# Type: string")
                s.append("# Default: UNCRUSTIFY_ON_TEXT ")
            s.append('enable_processing_cmt = "' + self.option_enable_processing_cmt.text()+'"\n')
        if full or  'false'!=self.option_enable_digraphs.currentText():
            if comment:
                s.append(self.wrap(self.tr("Enable parsing of digraphs.", "enable_digraphs")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('enable_digraphs = ' + self.option_enable_digraphs.currentText())
        if full or  'false'!=self.option_processing_cmt_as_regex.currentText():
            if comment:
                s.append(self.wrap(self.tr("Option to allow both disable_processing_cmt and enable_processing_cmt\nstrings, if specified, to be interpreted as ECMAScript regular expressions.\nIf true, a regex search will be performed within comments according to the\nspecified patterns in order to disable/enable processing.", "processing_cmt_as_regex")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('processing_cmt_as_regex = ' + self.option_processing_cmt_as_regex.currentText())
        if full or  'ignore'!=self.option_utf8_bom.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove the UTF-8 BOM (recommend 'remove').", "utf8_bom")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('utf8_bom = ' + self.option_utf8_bom.currentText())
        if full or  'false'!=self.option_utf8_byte.currentText():
            if comment:
                s.append(self.wrap(self.tr("If the file contains bytes with values between 128 and 255, but is not\nUTF-8, then output as UTF-8.", "utf8_byte")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('utf8_byte = ' + self.option_utf8_byte.currentText())
        if full or  'false'!=self.option_utf8_force.currentText():
            if comment:
                s.append(self.wrap(self.tr("Force the output encoding to UTF-8.", "utf8_force")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('utf8_force = ' + self.option_utf8_force.currentText())
        #================== Spacing options =================================================================
        if full or  comment: s.append('\n\n'+'#'*80+self.wrap(self.tr("Spacing options"))+'\n'+'#'*80)
        if full or  'ignore'!=self.option_sp_arith.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space around non-assignment symbolic operators ('+', '/', '%',\n'<<', and so forth).", "sp_arith")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_arith = ' + self.option_sp_arith.currentText())
        if full or  'ignore'!=self.option_sp_arith_additive.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space around arithmetic operators '+' and '-'.", "sp_arith_additive"))+"\n#"+self.wrap(self.tr("Overrides sp_arith.", "sp_arith_additive")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_arith_additive = ' + self.option_sp_arith_additive.currentText())
        if full or  'ignore'!=self.option_sp_assign.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space around assignment operator '=', '+=', etc.", "sp_assign")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_assign = ' + self.option_sp_assign.currentText())
        if full or  'ignore'!=self.option_sp_cpp_lambda_assign.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space around '=' in C++11 lambda capture specifications.", "sp_cpp_lambda_assign"))+"\n#"+self.wrap(self.tr("Overrides sp_assign.", "sp_cpp_lambda_assign")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_cpp_lambda_assign = ' + self.option_sp_cpp_lambda_assign.currentText())
        if full or  'ignore'!=self.option_sp_cpp_lambda_square_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after the capture specification of a C++11 lambda when\nan argument list is present, as in '[] <here> (int x){ ... }'.", "sp_cpp_lambda_square_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_cpp_lambda_square_paren = ' + self.option_sp_cpp_lambda_square_paren.currentText())
        if full or  'ignore'!=self.option_sp_cpp_lambda_square_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after the capture specification of a C++11 lambda with\nno argument list is present, as in '[] <here> { ... }'.", "sp_cpp_lambda_square_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_cpp_lambda_square_brace = ' + self.option_sp_cpp_lambda_square_brace.currentText())
        if full or  'ignore'!=self.option_sp_cpp_lambda_argument_list_empty.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after the opening parenthesis and before the closing\nparenthesis of a argument list of a C++11 lambda, as in\n'[]( <here> ){ ... }'\nwith an empty list.", "sp_cpp_lambda_argument_list_empty")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_cpp_lambda_argument_list_empty = ' + self.option_sp_cpp_lambda_argument_list_empty.currentText())
        if full or  'ignore'!=self.option_sp_cpp_lambda_argument_list.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after the opening parenthesis and before the closing\nparenthesis of a argument list of a C++11 lambda, as in\n'[]( <here> int x <here> ){ ... }'.", "sp_cpp_lambda_argument_list")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_cpp_lambda_argument_list = ' + self.option_sp_cpp_lambda_argument_list.currentText())
        if full or  'ignore'!=self.option_sp_cpp_lambda_paren_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after the argument list of a C++11 lambda, as in\n'[](int x) <here> { ... }'.", "sp_cpp_lambda_paren_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_cpp_lambda_paren_brace = ' + self.option_sp_cpp_lambda_paren_brace.currentText())
        if full or  'ignore'!=self.option_sp_cpp_lambda_fparen.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between a lambda body and its call operator of an\nimmediately invoked lambda, as in '[]( ... ){ ... } <here> ( ... )'.", "sp_cpp_lambda_fparen")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_cpp_lambda_fparen = ' + self.option_sp_cpp_lambda_fparen.currentText())
        if full or  'ignore'!=self.option_sp_assign_default.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space around assignment operator '=' in a prototype.", "sp_assign_default"))+"\n#"+self.wrap(self.tr("If set to ignore, use sp_assign.", "sp_assign_default")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_assign_default = ' + self.option_sp_assign_default.currentText())
        if full or  'ignore'!=self.option_sp_before_assign.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before assignment operator '=', '+=', etc.", "sp_before_assign"))+"\n#"+self.wrap(self.tr("Overrides sp_assign.", "sp_before_assign")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_assign = ' + self.option_sp_before_assign.currentText())
        if full or  'ignore'!=self.option_sp_after_assign.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after assignment operator '=', '+=', etc.", "sp_after_assign"))+"\n#"+self.wrap(self.tr("Overrides sp_assign.", "sp_after_assign")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_assign = ' + self.option_sp_after_assign.currentText())
        if full or  'add'!=self.option_sp_enum_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space in 'enum {'.", "sp_enum_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: add ")
            s.append('sp_enum_brace = ' + self.option_sp_enum_brace.currentText())
        if full or  'ignore'!=self.option_sp_enum_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space in 'NS_ENUM ('.", "sp_enum_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_enum_paren = ' + self.option_sp_enum_paren.currentText())
        if full or  'ignore'!=self.option_sp_enum_assign.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space around assignment '=' in enum.", "sp_enum_assign")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_enum_assign = ' + self.option_sp_enum_assign.currentText())
        if full or  'ignore'!=self.option_sp_enum_before_assign.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before assignment '=' in enum.", "sp_enum_before_assign"))+"\n#"+self.wrap(self.tr("Overrides sp_enum_assign.", "sp_enum_before_assign")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_enum_before_assign = ' + self.option_sp_enum_before_assign.currentText())
        if full or  'ignore'!=self.option_sp_enum_after_assign.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after assignment '=' in enum.", "sp_enum_after_assign"))+"\n#"+self.wrap(self.tr("Overrides sp_enum_assign.", "sp_enum_after_assign")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_enum_after_assign = ' + self.option_sp_enum_after_assign.currentText())
        if full or  'ignore'!=self.option_sp_enum_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space around assignment ':' in enum.", "sp_enum_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_enum_colon = ' + self.option_sp_enum_colon.currentText())
        if full or  'add'!=self.option_sp_pp_concat.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space around preprocessor '##' concatenation operator.", "sp_pp_concat")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: add ")
            s.append('sp_pp_concat = ' + self.option_sp_pp_concat.currentText())
        if full or  'ignore'!=self.option_sp_pp_stringify.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after preprocessor '#' stringify operator.\nAlso affects the '#@' charizing operator.", "sp_pp_stringify")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_pp_stringify = ' + self.option_sp_pp_stringify.currentText())
        if full or  'ignore'!=self.option_sp_before_pp_stringify.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before preprocessor '#' stringify operator\nas in '#define x(y) L#y'.", "sp_before_pp_stringify")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_pp_stringify = ' + self.option_sp_before_pp_stringify.currentText())
        if full or  'ignore'!=self.option_sp_bool.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space around boolean operators '&&' and '||'.", "sp_bool")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_bool = ' + self.option_sp_bool.currentText())
        if full or  'ignore'!=self.option_sp_compare.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space around compare operator '<', '>', '==', etc.", "sp_compare")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_compare = ' + self.option_sp_compare.currentText())
        if full or  'ignore'!=self.option_sp_inside_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space inside '(' and ')'.", "sp_inside_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_paren = ' + self.option_sp_inside_paren.currentText())
        if full or  'ignore'!=self.option_sp_paren_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between nested parentheses, i.e. '((' vs. ') )'.", "sp_paren_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_paren_paren = ' + self.option_sp_paren_paren.currentText())
        if full or  'ignore'!=self.option_sp_cparen_oparen.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between back-to-back parentheses, i.e. ')(' vs. ') ('.", "sp_cparen_oparen")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_cparen_oparen = ' + self.option_sp_cparen_oparen.currentText())
        if full or  'ignore'!=self.option_sp_paren_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between ')' and '{'.", "sp_paren_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_paren_brace = ' + self.option_sp_paren_brace.currentText())
        if full or  'ignore'!=self.option_sp_brace_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between nested braces, i.e. '{{' vs. '{ {'.", "sp_brace_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_brace_brace = ' + self.option_sp_brace_brace.currentText())
        if full or  'ignore'!=self.option_sp_before_ptr_star.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before pointer star '*'.", "sp_before_ptr_star")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_ptr_star = ' + self.option_sp_before_ptr_star.currentText())
        if full or  'ignore'!=self.option_sp_before_unnamed_ptr_star.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before pointer star '*' that isn't followed by a\nvariable name. If set to ignore, sp_before_ptr_star is used instead.", "sp_before_unnamed_ptr_star")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_unnamed_ptr_star = ' + self.option_sp_before_unnamed_ptr_star.currentText())
        if full or  'ignore'!=self.option_sp_before_qualifier_ptr_star.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before pointer star '*' that is followed by a qualifier.\nIf set to ignore, sp_before_unnamed_ptr_star is used instead.", "sp_before_qualifier_ptr_star")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_qualifier_ptr_star = ' + self.option_sp_before_qualifier_ptr_star.currentText())
        if full or  'ignore'!=self.option_sp_before_operator_ptr_star.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before pointer star '*' that is followed by 'operator' keyword.\nIf set to ignore, sp_before_unnamed_ptr_star is used instead.", "sp_before_operator_ptr_star")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_operator_ptr_star = ' + self.option_sp_before_operator_ptr_star.currentText())
        if full or  'ignore'!=self.option_sp_before_scope_ptr_star.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before pointer star '*' that is followed by\na class scope (as in 'int *MyClass::method()') or namespace scope\n(as in 'int *my_ns::func()').\nIf set to ignore, sp_before_unnamed_ptr_star is used instead.", "sp_before_scope_ptr_star")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_scope_ptr_star = ' + self.option_sp_before_scope_ptr_star.currentText())
        if full or  'ignore'!=self.option_sp_before_global_scope_ptr_star.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before pointer star '*' that is followed by '::',\nas in 'int *::func()'.\nIf set to ignore, sp_before_unnamed_ptr_star is used instead.", "sp_before_global_scope_ptr_star")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_global_scope_ptr_star = ' + self.option_sp_before_global_scope_ptr_star.currentText())
        if full or  'ignore'!=self.option_sp_qualifier_unnamed_ptr_star.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between a qualifier and a pointer star '*' that isn't\nfollowed by a variable name, as in '(char const *)'. If set to ignore,\nsp_before_ptr_star is used instead.", "sp_qualifier_unnamed_ptr_star")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_qualifier_unnamed_ptr_star = ' + self.option_sp_qualifier_unnamed_ptr_star.currentText())
        if full or  'ignore'!=self.option_sp_between_ptr_star.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between pointer stars '*', as in 'int ***a;'.", "sp_between_ptr_star")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_between_ptr_star = ' + self.option_sp_between_ptr_star.currentText())
        if full or  'ignore'!=self.option_sp_between_ptr_ref.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between pointer star '*' and reference '&', as in 'int *& a;'.", "sp_between_ptr_ref")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_between_ptr_ref = ' + self.option_sp_between_ptr_ref.currentText())
        if full or  'ignore'!=self.option_sp_after_ptr_star.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after pointer star '*', if followed by a word.", "sp_after_ptr_star"))+"\n#"+self.wrap(self.tr("Overrides sp_type_func.", "sp_after_ptr_star")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_ptr_star = ' + self.option_sp_after_ptr_star.currentText())
        if full or  'ignore'!=self.option_sp_after_ptr_block_caret.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after pointer caret '^', if followed by a word.", "sp_after_ptr_block_caret")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_ptr_block_caret = ' + self.option_sp_after_ptr_block_caret.currentText())
        if full or  'ignore'!=self.option_sp_after_ptr_star_qualifier.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after pointer star '*', if followed by a qualifier.", "sp_after_ptr_star_qualifier")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_ptr_star_qualifier = ' + self.option_sp_after_ptr_star_qualifier.currentText())
        if full or  'ignore'!=self.option_sp_after_ptr_star_func.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after a pointer star '*', if followed by a function\nprototype or function definition.", "sp_after_ptr_star_func"))+"\n#"+self.wrap(self.tr("Overrides sp_after_ptr_star and sp_type_func.", "sp_after_ptr_star_func")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_ptr_star_func = ' + self.option_sp_after_ptr_star_func.currentText())
        if full or  'ignore'!=self.option_sp_after_ptr_star_trailing.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after a pointer star '*' in the trailing return of a\nfunction prototype or function definition.", "sp_after_ptr_star_trailing")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_ptr_star_trailing = ' + self.option_sp_after_ptr_star_trailing.currentText())
        if full or  'ignore'!=self.option_sp_ptr_star_func_var.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between the pointer star '*' and the name of the variable\nin a function pointer definition.", "sp_ptr_star_func_var")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_ptr_star_func_var = ' + self.option_sp_ptr_star_func_var.currentText())
        if full or  'ignore'!=self.option_sp_ptr_star_func_type.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between the pointer star '*' and the name of the type\nin a function pointer type definition.", "sp_ptr_star_func_type")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_ptr_star_func_type = ' + self.option_sp_ptr_star_func_type.currentText())
        if full or  'ignore'!=self.option_sp_ptr_star_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after a pointer star '*', if followed by an open\nparenthesis, as in 'void* (*)()'.", "sp_ptr_star_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_ptr_star_paren = ' + self.option_sp_ptr_star_paren.currentText())
        if full or  'ignore'!=self.option_sp_before_ptr_star_func.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before a pointer star '*', if followed by a function\nprototype or function definition. If set to ignore, sp_before_ptr_star is\nused instead.", "sp_before_ptr_star_func")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_ptr_star_func = ' + self.option_sp_before_ptr_star_func.currentText())
        if full or  'ignore'!=self.option_sp_qualifier_ptr_star_func.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between a qualifier and a pointer star '*' followed by\nthe name of the function in a function prototype or definition, as in\n'char const *foo()`. If set to ignore, sp_before_ptr_star is used instead.", "sp_qualifier_ptr_star_func")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_qualifier_ptr_star_func = ' + self.option_sp_qualifier_ptr_star_func.currentText())
        if full or  'ignore'!=self.option_sp_before_ptr_star_trailing.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before a pointer star '*' in the trailing return of a\nfunction prototype or function definition.", "sp_before_ptr_star_trailing")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_ptr_star_trailing = ' + self.option_sp_before_ptr_star_trailing.currentText())
        if full or  'ignore'!=self.option_sp_qualifier_ptr_star_trailing.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between a qualifier and a pointer star '*' in the\ntrailing return of a function prototype or function definition, as in\n'auto foo() -> char const *'.", "sp_qualifier_ptr_star_trailing")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_qualifier_ptr_star_trailing = ' + self.option_sp_qualifier_ptr_star_trailing.currentText())
        if full or  'ignore'!=self.option_sp_before_byref.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before a reference sign '&'.", "sp_before_byref")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_byref = ' + self.option_sp_before_byref.currentText())
        if full or  'ignore'!=self.option_sp_before_unnamed_byref.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before a reference sign '&' that isn't followed by a\nvariable name. If set to ignore, sp_before_byref is used instead.", "sp_before_unnamed_byref")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_unnamed_byref = ' + self.option_sp_before_unnamed_byref.currentText())
        if full or  'ignore'!=self.option_sp_after_byref.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after reference sign '&', if followed by a word.", "sp_after_byref"))+"\n#"+self.wrap(self.tr("Overrides sp_type_func.", "sp_after_byref")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_byref = ' + self.option_sp_after_byref.currentText())
        if full or  'ignore'!=self.option_sp_after_byref_func.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after a reference sign '&', if followed by a function\nprototype or function definition.", "sp_after_byref_func"))+"\n#"+self.wrap(self.tr("Overrides sp_after_byref and sp_type_func.", "sp_after_byref_func")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_byref_func = ' + self.option_sp_after_byref_func.currentText())
        if full or  'ignore'!=self.option_sp_before_byref_func.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before a reference sign '&', if followed by a function\nprototype or function definition.", "sp_before_byref_func")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_byref_func = ' + self.option_sp_before_byref_func.currentText())
        if full or  'ignore'!=self.option_sp_byref_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after a reference sign '&', if followed by an open\nparenthesis, as in 'char& (*)()'.", "sp_byref_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_byref_paren = ' + self.option_sp_byref_paren.currentText())
        if full or  'force'!=self.option_sp_after_type.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between type and word. In cases where total removal of\nwhitespace would be a syntax error, a value of 'remove' is treated the same\nas 'force'.", "sp_after_type"))+"\n#"+self.wrap(self.tr("This also affects some other instances of space following a type that are\nnot covered by other options; for example, between the return type and\nparenthesis of a function type template argument, between the type and\nparenthesis of an array parameter, or between 'decltype(...)' and the\nfollowing word.", "sp_after_type")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: force ")
            s.append('sp_after_type = ' + self.option_sp_after_type.currentText())
        if full or  'ignore'!=self.option_sp_after_decltype.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between 'decltype(...)' and word,\nbrace or function call.", "sp_after_decltype")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_decltype = ' + self.option_sp_after_decltype.currentText())
        if full or  'ignore'!=self.option_sp_before_template_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("(D) Add or remove space before the parenthesis in the D constructs\n'template Foo(' and 'class Foo('.", "sp_before_template_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_template_paren = ' + self.option_sp_before_template_paren.currentText())
        if full or  'ignore'!=self.option_sp_template_angle.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between 'template' and '<'.\nIf set to ignore, sp_before_angle is used.", "sp_template_angle")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_template_angle = ' + self.option_sp_template_angle.currentText())
        if full or  'ignore'!=self.option_sp_before_angle.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before '<'.", "sp_before_angle")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_angle = ' + self.option_sp_before_angle.currentText())
        if full or  'ignore'!=self.option_sp_inside_angle.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space inside '<' and '>'.", "sp_inside_angle")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_angle = ' + self.option_sp_inside_angle.currentText())
        if full or  'ignore'!=self.option_sp_inside_angle_empty.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space inside '<>'.\nif empty.", "sp_inside_angle_empty")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_angle_empty = ' + self.option_sp_inside_angle_empty.currentText())
        if full or  'ignore'!=self.option_sp_angle_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between '>' and ':'.", "sp_angle_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_angle_colon = ' + self.option_sp_angle_colon.currentText())
        if full or  'ignore'!=self.option_sp_after_angle.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after '>'.", "sp_after_angle")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_angle = ' + self.option_sp_after_angle.currentText())
        if full or  'ignore'!=self.option_sp_angle_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between '>' and '(' as found in 'new List<byte>(foo);'.", "sp_angle_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_angle_paren = ' + self.option_sp_angle_paren.currentText())
        if full or  'ignore'!=self.option_sp_angle_paren_empty.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between '>' and '()' as found in 'new List<byte>();'.", "sp_angle_paren_empty")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_angle_paren_empty = ' + self.option_sp_angle_paren_empty.currentText())
        if full or  'ignore'!=self.option_sp_angle_word.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between '>' and a word as in 'List<byte> m;' or\n'template <typename T> static ...'.", "sp_angle_word")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_angle_word = ' + self.option_sp_angle_word.currentText())
        if full or  'add'!=self.option_sp_angle_shift.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between '>' and '>' in '>>' (template stuff).", "sp_angle_shift")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: add ")
            s.append('sp_angle_shift = ' + self.option_sp_angle_shift.currentText())
        if full or  'false'!=self.option_sp_permit_cpp11_shift.currentText():
            if comment:
                s.append(self.wrap(self.tr("(C++11) Permit removal of the space between '>>' in 'foo<bar<int> >'. Note\nthat sp_angle_shift cannot remove the space without this option.", "sp_permit_cpp11_shift")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('sp_permit_cpp11_shift = ' + self.option_sp_permit_cpp11_shift.currentText())
        if full or  'ignore'!=self.option_sp_before_sparen.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before '(' of control statements ('if', 'for', 'switch',\n'while', etc.).", "sp_before_sparen")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_sparen = ' + self.option_sp_before_sparen.currentText())
        if full or  'ignore'!=self.option_sp_inside_sparen.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space inside '(' and ')' of control statements other than\n'for'.", "sp_inside_sparen")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_sparen = ' + self.option_sp_inside_sparen.currentText())
        if full or  'ignore'!=self.option_sp_inside_sparen_open.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after '(' of control statements other than 'for'.", "sp_inside_sparen_open"))+"\n#"+self.wrap(self.tr("Overrides sp_inside_sparen.", "sp_inside_sparen_open")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_sparen_open = ' + self.option_sp_inside_sparen_open.currentText())
        if full or  'ignore'!=self.option_sp_inside_sparen_close.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before ')' of control statements other than 'for'.", "sp_inside_sparen_close"))+"\n#"+self.wrap(self.tr("Overrides sp_inside_sparen.", "sp_inside_sparen_close")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_sparen_close = ' + self.option_sp_inside_sparen_close.currentText())
        if full or  'ignore'!=self.option_sp_inside_for.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space inside '(' and ')' of 'for' statements.", "sp_inside_for")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_for = ' + self.option_sp_inside_for.currentText())
        if full or  'ignore'!=self.option_sp_inside_for_open.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after '(' of 'for' statements.", "sp_inside_for_open"))+"\n#"+self.wrap(self.tr("Overrides sp_inside_for.", "sp_inside_for_open")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_for_open = ' + self.option_sp_inside_for_open.currentText())
        if full or  'ignore'!=self.option_sp_inside_for_close.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before ')' of 'for' statements.", "sp_inside_for_close"))+"\n#"+self.wrap(self.tr("Overrides sp_inside_for.", "sp_inside_for_close")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_for_close = ' + self.option_sp_inside_for_close.currentText())
        if full or  'ignore'!=self.option_sp_sparen_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between '((' or '))' of control statements.", "sp_sparen_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_sparen_paren = ' + self.option_sp_sparen_paren.currentText())
        if full or  'ignore'!=self.option_sp_after_sparen.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after ')' of control statements.", "sp_after_sparen")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_sparen = ' + self.option_sp_after_sparen.currentText())
        if full or  'ignore'!=self.option_sp_sparen_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between ')' and '{' of control statements.", "sp_sparen_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_sparen_brace = ' + self.option_sp_sparen_brace.currentText())
        if full or  'ignore'!=self.option_sp_do_brace_open.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between 'do' and '{'.", "sp_do_brace_open")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_do_brace_open = ' + self.option_sp_do_brace_open.currentText())
        if full or  'ignore'!=self.option_sp_brace_close_while.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between '}' and 'while'.", "sp_brace_close_while")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_brace_close_while = ' + self.option_sp_brace_close_while.currentText())
        if full or  'ignore'!=self.option_sp_while_paren_open.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between 'while' and '('. Overrides sp_before_sparen.", "sp_while_paren_open")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_while_paren_open = ' + self.option_sp_while_paren_open.currentText())
        if full or  'ignore'!=self.option_sp_invariant_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("(D) Add or remove space between 'invariant' and '('.", "sp_invariant_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_invariant_paren = ' + self.option_sp_invariant_paren.currentText())
        if full or  'ignore'!=self.option_sp_after_invariant_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("(D) Add or remove space after the ')' in 'invariant (C) c'.", "sp_after_invariant_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_invariant_paren = ' + self.option_sp_after_invariant_paren.currentText())
        if full or  'ignore'!=self.option_sp_special_semi.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before empty statement ';' on 'if', 'for' and 'while'.\nexamples:\n  if (b) <here> ;\n  for (a=1; a<10; a++) <here> ;\n  while (*p++ = ' ') <here> ;", "sp_special_semi")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_special_semi = ' + self.option_sp_special_semi.currentText())
        if full or  'remove'!=self.option_sp_before_semi.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before ';'.", "sp_before_semi")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: remove ")
            s.append('sp_before_semi = ' + self.option_sp_before_semi.currentText())
        if full or  'ignore'!=self.option_sp_before_semi_for.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before ';' in non-empty 'for' statements.", "sp_before_semi_for")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_semi_for = ' + self.option_sp_before_semi_for.currentText())
        if full or  'ignore'!=self.option_sp_before_semi_for_empty.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before a semicolon of an empty left part of a for\nstatement, as in 'for ( <here> ; ; )'.", "sp_before_semi_for_empty")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_semi_for_empty = ' + self.option_sp_before_semi_for_empty.currentText())
        if full or  'ignore'!=self.option_sp_between_semi_for_empty.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between the semicolons of an empty middle part of a for\nstatement, as in 'for ( ; <here> ; )'.", "sp_between_semi_for_empty")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_between_semi_for_empty = ' + self.option_sp_between_semi_for_empty.currentText())
        if full or  'add'!=self.option_sp_after_semi.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after ';', except when followed by a comment.", "sp_after_semi")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: add ")
            s.append('sp_after_semi = ' + self.option_sp_after_semi.currentText())
        if full or  'force'!=self.option_sp_after_semi_for.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after ';' in non-empty 'for' statements.", "sp_after_semi_for")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: force ")
            s.append('sp_after_semi_for = ' + self.option_sp_after_semi_for.currentText())
        if full or  'ignore'!=self.option_sp_after_semi_for_empty.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after the final semicolon of an empty part of a for\nstatement, as in 'for ( ; ; <here> )'.", "sp_after_semi_for_empty")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_semi_for_empty = ' + self.option_sp_after_semi_for_empty.currentText())
        if full or  'ignore'!=self.option_sp_before_square.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before '[' (except '[]').", "sp_before_square")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_square = ' + self.option_sp_before_square.currentText())
        if full or  'remove'!=self.option_sp_before_vardef_square.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before '[' for a variable definition.", "sp_before_vardef_square")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: remove ")
            s.append('sp_before_vardef_square = ' + self.option_sp_before_vardef_square.currentText())
        if full or  'ignore'!=self.option_sp_before_square_asm_block.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before '[' for asm block.", "sp_before_square_asm_block")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_square_asm_block = ' + self.option_sp_before_square_asm_block.currentText())
        if full or  'ignore'!=self.option_sp_before_squares.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before '[]'.", "sp_before_squares")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_squares = ' + self.option_sp_before_squares.currentText())
        if full or  'ignore'!=self.option_sp_cpp_before_struct_binding_after_byref.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before C++17 structured bindings\nafter byref.", "sp_cpp_before_struct_binding_after_byref")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_cpp_before_struct_binding_after_byref = ' + self.option_sp_cpp_before_struct_binding_after_byref.currentText())
        if full or  'ignore'!=self.option_sp_cpp_before_struct_binding.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before C++17 structured bindings.", "sp_cpp_before_struct_binding")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_cpp_before_struct_binding = ' + self.option_sp_cpp_before_struct_binding.currentText())
        if full or  'ignore'!=self.option_sp_inside_square.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space inside a non-empty '[' and ']'.", "sp_inside_square")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_square = ' + self.option_sp_inside_square.currentText())
        if full or  'ignore'!=self.option_sp_inside_square_empty.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space inside '[]'.\nif empty.", "sp_inside_square_empty")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_square_empty = ' + self.option_sp_inside_square_empty.currentText())
        if full or  'ignore'!=self.option_sp_inside_square_oc_array.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space inside a non-empty Objective-C boxed array '@[' and\n']'. If set to ignore, sp_inside_square is used.", "sp_inside_square_oc_array")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_square_oc_array = ' + self.option_sp_inside_square_oc_array.currentText())
        if full or  'ignore'!=self.option_sp_after_comma.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after ',', i.e. 'a,b' vs. 'a, b'.", "sp_after_comma")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_comma = ' + self.option_sp_after_comma.currentText())
        if full or  'remove'!=self.option_sp_before_comma.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before ',', i.e. 'a,b' vs. 'a ,b'.", "sp_before_comma")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: remove ")
            s.append('sp_before_comma = ' + self.option_sp_before_comma.currentText())
        if full or  'ignore'!=self.option_sp_after_mdatype_commas.currentText():
            if comment:
                s.append(self.wrap(self.tr("(C#, Vala) Add or remove space between ',' and ']' in multidimensional array type\nlike 'int[,,]'.", "sp_after_mdatype_commas")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_mdatype_commas = ' + self.option_sp_after_mdatype_commas.currentText())
        if full or  'ignore'!=self.option_sp_before_mdatype_commas.currentText():
            if comment:
                s.append(self.wrap(self.tr("(C#, Vala) Add or remove space between '[' and ',' in multidimensional array type\nlike 'int[,,]'.", "sp_before_mdatype_commas")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_mdatype_commas = ' + self.option_sp_before_mdatype_commas.currentText())
        if full or  'ignore'!=self.option_sp_between_mdatype_commas.currentText():
            if comment:
                s.append(self.wrap(self.tr("(C#, Vala) Add or remove space between ',' in multidimensional array type\nlike 'int[,,]'.", "sp_between_mdatype_commas")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_between_mdatype_commas = ' + self.option_sp_between_mdatype_commas.currentText())
        if full or  'force'!=self.option_sp_paren_comma.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between an open parenthesis and comma,\ni.e. '(,' vs. '( ,'.", "sp_paren_comma")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: force ")
            s.append('sp_paren_comma = ' + self.option_sp_paren_comma.currentText())
        if full or  'ignore'!=self.option_sp_type_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between a type and ':'.", "sp_type_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_type_colon = ' + self.option_sp_type_colon.currentText())
        if full or  'ignore'!=self.option_sp_after_ellipsis.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after the variadic '...' when preceded by a\nnon-punctuator.\nThe value REMOVE will be overridden with FORCE", "sp_after_ellipsis")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_ellipsis = ' + self.option_sp_after_ellipsis.currentText())
        if full or  'ignore'!=self.option_sp_before_ellipsis.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before the variadic '...' when preceded by a\nnon-punctuator.\nThe value REMOVE will be overridden with FORCE", "sp_before_ellipsis")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_ellipsis = ' + self.option_sp_before_ellipsis.currentText())
        if full or  'ignore'!=self.option_sp_type_ellipsis.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between a type and '...'.", "sp_type_ellipsis")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_type_ellipsis = ' + self.option_sp_type_ellipsis.currentText())
        if full or  'ignore'!=self.option_sp_ptr_type_ellipsis.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between a '*' and '...'.", "sp_ptr_type_ellipsis")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_ptr_type_ellipsis = ' + self.option_sp_ptr_type_ellipsis.currentText())
        if full or  'ignore'!=self.option_sp_paren_ellipsis.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between ')' and '...'.", "sp_paren_ellipsis")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_paren_ellipsis = ' + self.option_sp_paren_ellipsis.currentText())
        if full or  'ignore'!=self.option_sp_byref_ellipsis.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between '&&' and '...'.", "sp_byref_ellipsis")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_byref_ellipsis = ' + self.option_sp_byref_ellipsis.currentText())
        if full or  'ignore'!=self.option_sp_paren_qualifier.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between ')' and a qualifier such as 'const'.", "sp_paren_qualifier")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_paren_qualifier = ' + self.option_sp_paren_qualifier.currentText())
        if full or  'ignore'!=self.option_sp_paren_noexcept.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between ')' and 'noexcept'.", "sp_paren_noexcept")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_paren_noexcept = ' + self.option_sp_paren_noexcept.currentText())
        if full or  'ignore'!=self.option_sp_after_class_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after class ':'.", "sp_after_class_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_class_colon = ' + self.option_sp_after_class_colon.currentText())
        if full or  'ignore'!=self.option_sp_before_class_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before class ':'.", "sp_before_class_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_class_colon = ' + self.option_sp_before_class_colon.currentText())
        if full or  'add'!=self.option_sp_after_constr_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after class constructor ':'.", "sp_after_constr_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: add ")
            s.append('sp_after_constr_colon = ' + self.option_sp_after_constr_colon.currentText())
        if full or  'add'!=self.option_sp_before_constr_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before class constructor ':'.", "sp_before_constr_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: add ")
            s.append('sp_before_constr_colon = ' + self.option_sp_before_constr_colon.currentText())
        if full or  'remove'!=self.option_sp_before_case_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before case ':'.", "sp_before_case_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: remove ")
            s.append('sp_before_case_colon = ' + self.option_sp_before_case_colon.currentText())
        if full or  'ignore'!=self.option_sp_after_operator.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between 'operator' and operator sign.", "sp_after_operator")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_operator = ' + self.option_sp_after_operator.currentText())
        if full or  'ignore'!=self.option_sp_after_operator_sym.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between the operator symbol and the open parenthesis, as\nin 'operator ++('.", "sp_after_operator_sym")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_operator_sym = ' + self.option_sp_after_operator_sym.currentText())
        if full or  'ignore'!=self.option_sp_after_operator_sym_empty.currentText():
            if comment:
                s.append(self.wrap(self.tr("Overrides sp_after_operator_sym when the operator has no arguments, as in\n'operator *()'.", "sp_after_operator_sym_empty")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_operator_sym_empty = ' + self.option_sp_after_operator_sym_empty.currentText())
        if full or  'ignore'!=self.option_sp_after_cast.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after C/D cast, i.e. 'cast(int)a' vs. 'cast(int) a' or\n'(int)a' vs. '(int) a'.", "sp_after_cast")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_cast = ' + self.option_sp_after_cast.currentText())
        if full or  'ignore'!=self.option_sp_inside_paren_cast.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove spaces inside cast parentheses.", "sp_inside_paren_cast")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_paren_cast = ' + self.option_sp_inside_paren_cast.currentText())
        if full or  'ignore'!=self.option_sp_cpp_cast_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between the type and open parenthesis in a C++ cast,\ni.e. 'int(exp)' vs. 'int (exp)'.", "sp_cpp_cast_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_cpp_cast_paren = ' + self.option_sp_cpp_cast_paren.currentText())
        if full or  'ignore'!=self.option_sp_sizeof_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between 'sizeof' and '('.", "sp_sizeof_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_sizeof_paren = ' + self.option_sp_sizeof_paren.currentText())
        if full or  'ignore'!=self.option_sp_sizeof_ellipsis.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between 'sizeof' and '...'.", "sp_sizeof_ellipsis")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_sizeof_ellipsis = ' + self.option_sp_sizeof_ellipsis.currentText())
        if full or  'ignore'!=self.option_sp_sizeof_ellipsis_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between 'sizeof...' and '('.", "sp_sizeof_ellipsis_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_sizeof_ellipsis_paren = ' + self.option_sp_sizeof_ellipsis_paren.currentText())
        if full or  'ignore'!=self.option_sp_ellipsis_parameter_pack.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between '...' and a parameter pack.", "sp_ellipsis_parameter_pack")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_ellipsis_parameter_pack = ' + self.option_sp_ellipsis_parameter_pack.currentText())
        if full or  'ignore'!=self.option_sp_parameter_pack_ellipsis.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between a parameter pack and '...'.", "sp_parameter_pack_ellipsis")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_parameter_pack_ellipsis = ' + self.option_sp_parameter_pack_ellipsis.currentText())
        if full or  'ignore'!=self.option_sp_decltype_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between 'decltype' and '('.", "sp_decltype_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_decltype_paren = ' + self.option_sp_decltype_paren.currentText())
        if full or  'ignore'!=self.option_sp_after_tag.currentText():
            if comment:
                s.append(self.wrap(self.tr("(Pawn) Add or remove space after the tag keyword.", "sp_after_tag")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_tag = ' + self.option_sp_after_tag.currentText())
        if full or  'ignore'!=self.option_sp_inside_braces_enum.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space inside enum '{' and '}'.", "sp_inside_braces_enum")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_braces_enum = ' + self.option_sp_inside_braces_enum.currentText())
        if full or  'ignore'!=self.option_sp_inside_braces_struct.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space inside struct/union '{' and '}'.", "sp_inside_braces_struct")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_braces_struct = ' + self.option_sp_inside_braces_struct.currentText())
        if full or  'ignore'!=self.option_sp_inside_braces_oc_dict.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space inside Objective-C boxed dictionary '{' and '}'", "sp_inside_braces_oc_dict")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_braces_oc_dict = ' + self.option_sp_inside_braces_oc_dict.currentText())
        if full or  'ignore'!=self.option_sp_after_type_brace_init_lst_open.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after open brace in an unnamed temporary\ndirect-list-initialization\nif statement is a brace_init_lst\nworks only if sp_brace_brace is set to ignore.", "sp_after_type_brace_init_lst_open")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_type_brace_init_lst_open = ' + self.option_sp_after_type_brace_init_lst_open.currentText())
        if full or  'ignore'!=self.option_sp_before_type_brace_init_lst_close.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before close brace in an unnamed temporary\ndirect-list-initialization\nif statement is a brace_init_lst\nworks only if sp_brace_brace is set to ignore.", "sp_before_type_brace_init_lst_close")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_type_brace_init_lst_close = ' + self.option_sp_before_type_brace_init_lst_close.currentText())
        if full or  'ignore'!=self.option_sp_inside_type_brace_init_lst.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space inside an unnamed temporary direct-list-initialization\nif statement is a brace_init_lst\nworks only if sp_brace_brace is set to ignore\nworks only if sp_before_type_brace_init_lst_close is set to ignore.", "sp_inside_type_brace_init_lst")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_type_brace_init_lst = ' + self.option_sp_inside_type_brace_init_lst.currentText())
        if full or  'ignore'!=self.option_sp_inside_braces.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space inside '{' and '}'.", "sp_inside_braces")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_braces = ' + self.option_sp_inside_braces.currentText())
        if full or  'ignore'!=self.option_sp_inside_braces_empty.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space inside '{}'.\nif empty.", "sp_inside_braces_empty")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_braces_empty = ' + self.option_sp_inside_braces_empty.currentText())
        if full or  'ignore'!=self.option_sp_trailing_return.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space around trailing return operator '->'.", "sp_trailing_return")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_trailing_return = ' + self.option_sp_trailing_return.currentText())
        if full or  'ignore'!=self.option_sp_type_func.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between return type and function name. A minimum of 1\nis forced except for pointer return types.", "sp_type_func")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_type_func = ' + self.option_sp_type_func.currentText())
        if full or  'ignore'!=self.option_sp_type_brace_init_lst.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between type and open brace of an unnamed temporary\ndirect-list-initialization.", "sp_type_brace_init_lst")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_type_brace_init_lst = ' + self.option_sp_type_brace_init_lst.currentText())
        if full or  'ignore'!=self.option_sp_func_proto_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between function name and '(' on function declaration.", "sp_func_proto_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_func_proto_paren = ' + self.option_sp_func_proto_paren.currentText())
        if full or  'ignore'!=self.option_sp_func_proto_paren_empty.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between function name and '()' on function declaration\nif empty.", "sp_func_proto_paren_empty")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_func_proto_paren_empty = ' + self.option_sp_func_proto_paren_empty.currentText())
        if full or  'ignore'!=self.option_sp_func_type_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between function name and '(' with a typedef specifier.", "sp_func_type_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_func_type_paren = ' + self.option_sp_func_type_paren.currentText())
        if full or  'ignore'!=self.option_sp_func_def_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between alias name and '(' of a non-pointer function type typedef.", "sp_func_def_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_func_def_paren = ' + self.option_sp_func_def_paren.currentText())
        if full or  'ignore'!=self.option_sp_func_def_paren_empty.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between function name and '()' on function definition\nif empty.", "sp_func_def_paren_empty")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_func_def_paren_empty = ' + self.option_sp_func_def_paren_empty.currentText())
        if full or  'ignore'!=self.option_sp_inside_fparens.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space inside empty function '()'.\nOverrides sp_after_angle unless use_sp_after_angle_always is set to true.", "sp_inside_fparens")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_fparens = ' + self.option_sp_inside_fparens.currentText())
        if full or  'ignore'!=self.option_sp_inside_fparen.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space inside function '(' and ')'.", "sp_inside_fparen")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_fparen = ' + self.option_sp_inside_fparen.currentText())
        if full or  'ignore'!=self.option_sp_func_call_user_inside_rparen.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space inside user functor '(' and ')'.", "sp_func_call_user_inside_rparen")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_func_call_user_inside_rparen = ' + self.option_sp_func_call_user_inside_rparen.currentText())
        if full or  'ignore'!=self.option_sp_inside_rparens.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space inside empty functor '()'.\nOverrides sp_after_angle unless use_sp_after_angle_always is set to true.", "sp_inside_rparens")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_rparens = ' + self.option_sp_inside_rparens.currentText())
        if full or  'ignore'!=self.option_sp_inside_rparen.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space inside functor '(' and ')'.", "sp_inside_rparen")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_rparen = ' + self.option_sp_inside_rparen.currentText())
        if full or  'ignore'!=self.option_sp_inside_tparen.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space inside the first parentheses in a function type, as in\n'void (*x)(...)'.", "sp_inside_tparen")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_tparen = ' + self.option_sp_inside_tparen.currentText())
        if full or  'ignore'!=self.option_sp_after_tparen_close.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between the ')' and '(' in a function type, as in\n'void (*x)(...)'.", "sp_after_tparen_close")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_tparen_close = ' + self.option_sp_after_tparen_close.currentText())
        if full or  'ignore'!=self.option_sp_square_fparen.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between ']' and '(' when part of a function call.", "sp_square_fparen")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_square_fparen = ' + self.option_sp_square_fparen.currentText())
        if full or  'ignore'!=self.option_sp_fparen_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between ')' and '{' of function.", "sp_fparen_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_fparen_brace = ' + self.option_sp_fparen_brace.currentText())
        if full or  'ignore'!=self.option_sp_fparen_brace_initializer.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between ')' and '{' of a function call in object\ninitialization.", "sp_fparen_brace_initializer"))+"\n#"+self.wrap(self.tr("Overrides sp_fparen_brace.", "sp_fparen_brace_initializer")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_fparen_brace_initializer = ' + self.option_sp_fparen_brace_initializer.currentText())
        if full or  'ignore'!=self.option_sp_fparen_dbrace.currentText():
            if comment:
                s.append(self.wrap(self.tr("(Java) Add or remove space between ')' and '{{' of double brace initializer.", "sp_fparen_dbrace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_fparen_dbrace = ' + self.option_sp_fparen_dbrace.currentText())
        if full or  'ignore'!=self.option_sp_func_call_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between function name and '(' on function calls.", "sp_func_call_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_func_call_paren = ' + self.option_sp_func_call_paren.currentText())
        if full or  'ignore'!=self.option_sp_func_call_paren_empty.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between function name and '()' on function calls without\nparameters. If set to ignore (the default), sp_func_call_paren is used.", "sp_func_call_paren_empty")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_func_call_paren_empty = ' + self.option_sp_func_call_paren_empty.currentText())
        if full or  'ignore'!=self.option_sp_func_call_user_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between the user function name and '(' on function\ncalls. You need to set a keyword to be a user function in the config file,\nlike:\n  set func_call_user tr _ i18n", "sp_func_call_user_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_func_call_user_paren = ' + self.option_sp_func_call_user_paren.currentText())
        if full or  'ignore'!=self.option_sp_func_call_user_inside_fparen.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space inside user function '(' and ')'.", "sp_func_call_user_inside_fparen")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_func_call_user_inside_fparen = ' + self.option_sp_func_call_user_inside_fparen.currentText())
        if full or  'ignore'!=self.option_sp_func_call_user_paren_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between nested parentheses with user functions,\ni.e. '((' vs. '( ('.", "sp_func_call_user_paren_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_func_call_user_paren_paren = ' + self.option_sp_func_call_user_paren_paren.currentText())
        if full or  'ignore'!=self.option_sp_func_class_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between a constructor/destructor and the open\nparenthesis.", "sp_func_class_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_func_class_paren = ' + self.option_sp_func_class_paren.currentText())
        if full or  'ignore'!=self.option_sp_func_class_paren_empty.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between a constructor without parameters or destructor\nand '()'.", "sp_func_class_paren_empty")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_func_class_paren_empty = ' + self.option_sp_func_class_paren_empty.currentText())
        if full or  'force'!=self.option_sp_return.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after 'return'.", "sp_return")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: force ")
            s.append('sp_return = ' + self.option_sp_return.currentText())
        if full or  'ignore'!=self.option_sp_return_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between 'return' and '('.", "sp_return_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_return_paren = ' + self.option_sp_return_paren.currentText())
        if full or  'ignore'!=self.option_sp_return_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between 'return' and '{'.", "sp_return_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_return_brace = ' + self.option_sp_return_brace.currentText())
        if full or  'ignore'!=self.option_sp_attribute_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between '__attribute__' and '('.", "sp_attribute_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_attribute_paren = ' + self.option_sp_attribute_paren.currentText())
        if full or  'ignore'!=self.option_sp_defined_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between 'defined' and '(' in '#if defined (FOO)'.", "sp_defined_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_defined_paren = ' + self.option_sp_defined_paren.currentText())
        if full or  'ignore'!=self.option_sp_throw_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between 'throw' and '(' in 'throw (something)'.", "sp_throw_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_throw_paren = ' + self.option_sp_throw_paren.currentText())
        if full or  'ignore'!=self.option_sp_after_throw.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between 'throw' and anything other than '(' as in\n'@throw [...];'.", "sp_after_throw")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_throw = ' + self.option_sp_after_throw.currentText())
        if full or  'ignore'!=self.option_sp_catch_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between 'catch' and '(' in 'catch (something) { }'.\nIf set to ignore, sp_before_sparen is used.", "sp_catch_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_catch_paren = ' + self.option_sp_catch_paren.currentText())
        if full or  'ignore'!=self.option_sp_oc_catch_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space between '@catch' and '('\nin '@catch (something) { }'. If set to ignore, sp_catch_paren is used.", "sp_oc_catch_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_oc_catch_paren = ' + self.option_sp_oc_catch_paren.currentText())
        if full or  'ignore'!=self.option_sp_before_oc_proto_list.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space before Objective-C protocol list\nas in '@protocol Protocol<here><Protocol_A>' or '@interface MyClass : NSObject<here><MyProtocol>'.", "sp_before_oc_proto_list")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_oc_proto_list = ' + self.option_sp_before_oc_proto_list.currentText())
        if full or  'ignore'!=self.option_sp_oc_classname_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space between class name and '('\nin '@interface className(categoryName)<ProtocolName>:BaseClass'", "sp_oc_classname_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_oc_classname_paren = ' + self.option_sp_oc_classname_paren.currentText())
        if full or  'ignore'!=self.option_sp_version_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("(D) Add or remove space between 'version' and '('\nin 'version (something) { }'. If set to ignore, sp_before_sparen is used.", "sp_version_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_version_paren = ' + self.option_sp_version_paren.currentText())
        if full or  'ignore'!=self.option_sp_scope_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("(D) Add or remove space between 'scope' and '('\nin 'scope (something) { }'. If set to ignore, sp_before_sparen is used.", "sp_scope_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_scope_paren = ' + self.option_sp_scope_paren.currentText())
        if full or  'remove'!=self.option_sp_super_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between 'super' and '(' in 'super (something)'.", "sp_super_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: remove ")
            s.append('sp_super_paren = ' + self.option_sp_super_paren.currentText())
        if full or  'remove'!=self.option_sp_this_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between 'this' and '(' in 'this (something)'.", "sp_this_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: remove ")
            s.append('sp_this_paren = ' + self.option_sp_this_paren.currentText())
        if full or  'ignore'!=self.option_sp_macro.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between a macro name and its definition.", "sp_macro")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_macro = ' + self.option_sp_macro.currentText())
        if full or  'ignore'!=self.option_sp_macro_func.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between a macro function ')' and its definition.", "sp_macro_func")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_macro_func = ' + self.option_sp_macro_func.currentText())
        if full or  'ignore'!=self.option_sp_else_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between 'else' and '{' if on the same line.", "sp_else_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_else_brace = ' + self.option_sp_else_brace.currentText())
        if full or  'ignore'!=self.option_sp_brace_else.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between '}' and 'else' if on the same line.", "sp_brace_else")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_brace_else = ' + self.option_sp_brace_else.currentText())
        if full or  'ignore'!=self.option_sp_brace_typedef.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between '}' and the name of a typedef on the same line.", "sp_brace_typedef")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_brace_typedef = ' + self.option_sp_brace_typedef.currentText())
        if full or  'ignore'!=self.option_sp_catch_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before the '{' of a 'catch' statement, if the '{' and\n'catch' are on the same line, as in 'catch (decl) <here> {'.", "sp_catch_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_catch_brace = ' + self.option_sp_catch_brace.currentText())
        if full or  'ignore'!=self.option_sp_oc_catch_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space before the '{' of a '@catch' statement, if the '{'\nand '@catch' are on the same line, as in '@catch (decl) <here> {'.\nIf set to ignore, sp_catch_brace is used.", "sp_oc_catch_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_oc_catch_brace = ' + self.option_sp_oc_catch_brace.currentText())
        if full or  'ignore'!=self.option_sp_brace_catch.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between '}' and 'catch' if on the same line.", "sp_brace_catch")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_brace_catch = ' + self.option_sp_brace_catch.currentText())
        if full or  'ignore'!=self.option_sp_oc_brace_catch.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space between '}' and '@catch' if on the same line.\nIf set to ignore, sp_brace_catch is used.", "sp_oc_brace_catch")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_oc_brace_catch = ' + self.option_sp_oc_brace_catch.currentText())
        if full or  'ignore'!=self.option_sp_finally_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between 'finally' and '{' if on the same line.", "sp_finally_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_finally_brace = ' + self.option_sp_finally_brace.currentText())
        if full or  'ignore'!=self.option_sp_brace_finally.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between '}' and 'finally' if on the same line.", "sp_brace_finally")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_brace_finally = ' + self.option_sp_brace_finally.currentText())
        if full or  'ignore'!=self.option_sp_try_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between 'try' and '{' if on the same line.", "sp_try_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_try_brace = ' + self.option_sp_try_brace.currentText())
        if full or  'ignore'!=self.option_sp_getset_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between get/set and '{' if on the same line.", "sp_getset_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_getset_brace = ' + self.option_sp_getset_brace.currentText())
        if full or  'ignore'!=self.option_sp_word_brace_init_lst.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between a variable and '{' for C++ uniform\ninitialization.", "sp_word_brace_init_lst")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_word_brace_init_lst = ' + self.option_sp_word_brace_init_lst.currentText())
        if full or  'add'!=self.option_sp_word_brace_ns.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between a variable and '{' for a namespace.", "sp_word_brace_ns")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: add ")
            s.append('sp_word_brace_ns = ' + self.option_sp_word_brace_ns.currentText())
        if full or  'ignore'!=self.option_sp_before_dc.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before the '::' operator.", "sp_before_dc")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_dc = ' + self.option_sp_before_dc.currentText())
        if full or  'ignore'!=self.option_sp_after_dc.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after the '::' operator.", "sp_after_dc")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_dc = ' + self.option_sp_after_dc.currentText())
        if full or  'ignore'!=self.option_sp_d_array_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("(D) Add or remove around the D named array initializer ':' operator.", "sp_d_array_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_d_array_colon = ' + self.option_sp_d_array_colon.currentText())
        if full or  'remove'!=self.option_sp_not.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after the '!' (not) unary operator.", "sp_not")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: remove ")
            s.append('sp_not = ' + self.option_sp_not.currentText())
        if full or  'ignore'!=self.option_sp_not_not.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between two '!' (not) unary operators.\nIf set to ignore, sp_not will be used.", "sp_not_not")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_not_not = ' + self.option_sp_not_not.currentText())
        if full or  'remove'!=self.option_sp_inv.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after the '~' (invert) unary operator.", "sp_inv")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: remove ")
            s.append('sp_inv = ' + self.option_sp_inv.currentText())
        if full or  'remove'!=self.option_sp_addr.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after the '&' (address-of) unary operator. This does not\naffect the spacing after a '&' that is part of a type.", "sp_addr")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: remove ")
            s.append('sp_addr = ' + self.option_sp_addr.currentText())
        if full or  'remove'!=self.option_sp_member.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space around the '.' or '->' operators.", "sp_member")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: remove ")
            s.append('sp_member = ' + self.option_sp_member.currentText())
        if full or  'remove'!=self.option_sp_deref.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after the '*' (dereference) unary operator. This does\nnot affect the spacing after a '*' that is part of a type.", "sp_deref")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: remove ")
            s.append('sp_deref = ' + self.option_sp_deref.currentText())
        if full or  'remove'!=self.option_sp_sign.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after '+' or '-', as in 'x = -5' or 'y = +7'.", "sp_sign")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: remove ")
            s.append('sp_sign = ' + self.option_sp_sign.currentText())
        if full or  'remove'!=self.option_sp_incdec.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between '++' and '--' the word to which it is being\napplied, as in '(--x)' or 'y++;'.", "sp_incdec")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: remove ")
            s.append('sp_incdec = ' + self.option_sp_incdec.currentText())
        if full or  'add'!=self.option_sp_before_nl_cont.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before a backslash-newline at the end of a line.", "sp_before_nl_cont")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: add ")
            s.append('sp_before_nl_cont = ' + self.option_sp_before_nl_cont.currentText())
        if full or  'ignore'!=self.option_sp_after_oc_scope.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space after the scope '+' or '-', as in '-(void) foo;'\nor '+(int) bar;'.", "sp_after_oc_scope")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_oc_scope = ' + self.option_sp_after_oc_scope.currentText())
        if full or  'ignore'!=self.option_sp_after_oc_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space after the colon in message specs,\ni.e. '-(int) f:(int) x;' vs. '-(int) f: (int) x;'.", "sp_after_oc_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_oc_colon = ' + self.option_sp_after_oc_colon.currentText())
        if full or  'ignore'!=self.option_sp_before_oc_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space before the colon in message specs,\ni.e. '-(int) f: (int) x;' vs. '-(int) f : (int) x;'.", "sp_before_oc_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_oc_colon = ' + self.option_sp_before_oc_colon.currentText())
        if full or  'ignore'!=self.option_sp_after_oc_dict_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space after the colon in immutable dictionary expression\n'NSDictionary *test = @{@\"foo\" :@\"bar\"};'.", "sp_after_oc_dict_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_oc_dict_colon = ' + self.option_sp_after_oc_dict_colon.currentText())
        if full or  'ignore'!=self.option_sp_before_oc_dict_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space before the colon in immutable dictionary expression\n'NSDictionary *test = @{@\"foo\" :@\"bar\"};'.", "sp_before_oc_dict_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_oc_dict_colon = ' + self.option_sp_before_oc_dict_colon.currentText())
        if full or  'ignore'!=self.option_sp_after_send_oc_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space after the colon in message specs,\ni.e. '[object setValue:1];' vs. '[object setValue: 1];'.", "sp_after_send_oc_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_send_oc_colon = ' + self.option_sp_after_send_oc_colon.currentText())
        if full or  'ignore'!=self.option_sp_before_send_oc_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space before the colon in message specs,\ni.e. '[object setValue:1];' vs. '[object setValue :1];'.", "sp_before_send_oc_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_send_oc_colon = ' + self.option_sp_before_send_oc_colon.currentText())
        if full or  'ignore'!=self.option_sp_after_oc_type.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space after the (type) in message specs,\ni.e. '-(int)f: (int) x;' vs. '-(int)f: (int)x;'.", "sp_after_oc_type")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_oc_type = ' + self.option_sp_after_oc_type.currentText())
        if full or  'ignore'!=self.option_sp_after_oc_return_type.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space after the first (type) in message specs,\ni.e. '-(int) f:(int)x;' vs. '-(int)f:(int)x;'.", "sp_after_oc_return_type")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_oc_return_type = ' + self.option_sp_after_oc_return_type.currentText())
        if full or  'ignore'!=self.option_sp_after_oc_at_sel.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space between '@selector' and '(',\ni.e. '@selector(msgName)' vs. '@selector (msgName)'.\nAlso applies to '@protocol()' constructs.", "sp_after_oc_at_sel")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_oc_at_sel = ' + self.option_sp_after_oc_at_sel.currentText())
        if full or  'ignore'!=self.option_sp_after_oc_at_sel_parens.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space between '@selector(x)' and the following word,\ni.e. '@selector(foo) a:' vs. '@selector(foo)a:'.", "sp_after_oc_at_sel_parens")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_oc_at_sel_parens = ' + self.option_sp_after_oc_at_sel_parens.currentText())
        if full or  'ignore'!=self.option_sp_inside_oc_at_sel_parens.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space inside '@selector' parentheses,\ni.e. '@selector(foo)' vs. '@selector( foo )'.\nAlso applies to '@protocol()' constructs.", "sp_inside_oc_at_sel_parens")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_oc_at_sel_parens = ' + self.option_sp_inside_oc_at_sel_parens.currentText())
        if full or  'ignore'!=self.option_sp_before_oc_block_caret.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space before a block pointer caret,\ni.e. '^int (int arg){...}' vs. ' ^int (int arg){...}'.", "sp_before_oc_block_caret")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_oc_block_caret = ' + self.option_sp_before_oc_block_caret.currentText())
        if full or  'ignore'!=self.option_sp_after_oc_block_caret.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space after a block pointer caret,\ni.e. '^int (int arg){...}' vs. '^ int (int arg){...}'.", "sp_after_oc_block_caret")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_oc_block_caret = ' + self.option_sp_after_oc_block_caret.currentText())
        if full or  'ignore'!=self.option_sp_after_oc_msg_receiver.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space between the receiver and selector in a message,\nas in '[receiver selector ...]'.", "sp_after_oc_msg_receiver")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_oc_msg_receiver = ' + self.option_sp_after_oc_msg_receiver.currentText())
        if full or  'ignore'!=self.option_sp_after_oc_property.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space after '@property'.", "sp_after_oc_property")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_oc_property = ' + self.option_sp_after_oc_property.currentText())
        if full or  'ignore'!=self.option_sp_after_oc_synchronized.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove space between '@synchronized' and the open parenthesis,\ni.e. '@synchronized(foo)' vs. '@synchronized (foo)'.", "sp_after_oc_synchronized")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_oc_synchronized = ' + self.option_sp_after_oc_synchronized.currentText())
        if full or  'ignore'!=self.option_sp_cond_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space around the ':' in 'b ? t : f'.", "sp_cond_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_cond_colon = ' + self.option_sp_cond_colon.currentText())
        if full or  'ignore'!=self.option_sp_cond_colon_before.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before the ':' in 'b ? t : f'.", "sp_cond_colon_before"))+"\n#"+self.wrap(self.tr("Overrides sp_cond_colon.", "sp_cond_colon_before")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_cond_colon_before = ' + self.option_sp_cond_colon_before.currentText())
        if full or  'ignore'!=self.option_sp_cond_colon_after.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after the ':' in 'b ? t : f'.", "sp_cond_colon_after"))+"\n#"+self.wrap(self.tr("Overrides sp_cond_colon.", "sp_cond_colon_after")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_cond_colon_after = ' + self.option_sp_cond_colon_after.currentText())
        if full or  'ignore'!=self.option_sp_cond_question.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space around the '?' in 'b ? t : f'.", "sp_cond_question")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_cond_question = ' + self.option_sp_cond_question.currentText())
        if full or  'ignore'!=self.option_sp_cond_question_before.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before the '?' in 'b ? t : f'.", "sp_cond_question_before"))+"\n#"+self.wrap(self.tr("Overrides sp_cond_question.", "sp_cond_question_before")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_cond_question_before = ' + self.option_sp_cond_question_before.currentText())
        if full or  'ignore'!=self.option_sp_cond_question_after.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after the '?' in 'b ? t : f'.", "sp_cond_question_after"))+"\n#"+self.wrap(self.tr("Overrides sp_cond_question.", "sp_cond_question_after")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_cond_question_after = ' + self.option_sp_cond_question_after.currentText())
        if full or  'ignore'!=self.option_sp_cond_ternary_short.currentText():
            if comment:
                s.append(self.wrap(self.tr("In the abbreviated ternary form '(a ?: b)', add or remove space between '?'\nand ':'.", "sp_cond_ternary_short"))+"\n#"+self.wrap(self.tr("Overrides all other sp_cond_* options.", "sp_cond_ternary_short")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_cond_ternary_short = ' + self.option_sp_cond_ternary_short.currentText())
        if full or  'ignore'!=self.option_sp_case_label.currentText():
            if comment:
                s.append(self.wrap(self.tr("Fix the spacing between 'case' and the label. Only 'ignore' and 'force' make\nsense here.", "sp_case_label")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_case_label = ' + self.option_sp_case_label.currentText())
        if full or  'ignore'!=self.option_sp_range.currentText():
            if comment:
                s.append(self.wrap(self.tr("(D) Add or remove space around the D '..' operator.", "sp_range")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_range = ' + self.option_sp_range.currentText())
        if full or  'ignore'!=self.option_sp_after_for_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after ':' in a Java/C++11 range-based 'for',\nas in 'for (Type var : <here> expr)'.", "sp_after_for_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_for_colon = ' + self.option_sp_after_for_colon.currentText())
        if full or  'ignore'!=self.option_sp_before_for_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before ':' in a Java/C++11 range-based 'for',\nas in 'for (Type var <here> : expr)'.", "sp_before_for_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_for_colon = ' + self.option_sp_before_for_colon.currentText())
        if full or  'ignore'!=self.option_sp_extern_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("(D) Add or remove space between 'extern' and '(' as in 'extern <here> (C)'.", "sp_extern_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_extern_paren = ' + self.option_sp_extern_paren.currentText())
        if full or  'ignore'!=self.option_sp_cmt_cpp_start.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after the opening of a C++ comment, as in '// <here> A'.", "sp_cmt_cpp_start")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_cmt_cpp_start = ' + self.option_sp_cmt_cpp_start.currentText())
        if full or  'false'!=self.option_sp_cmt_cpp_pvs.currentText():
            if comment:
                s.append(self.wrap(self.tr("remove space after the '//' and the pvs command '-V1234',\nonly works with sp_cmt_cpp_start set to add or force.", "sp_cmt_cpp_pvs")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('sp_cmt_cpp_pvs = ' + self.option_sp_cmt_cpp_pvs.currentText())
        if full or  'false'!=self.option_sp_cmt_cpp_lint.currentText():
            if comment:
                s.append(self.wrap(self.tr("remove space after the '//' and the command 'lint',\nonly works with sp_cmt_cpp_start set to add or force.", "sp_cmt_cpp_lint")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('sp_cmt_cpp_lint = ' + self.option_sp_cmt_cpp_lint.currentText())
        if full or  'ignore'!=self.option_sp_cmt_cpp_region.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space in a C++ region marker comment, as in '// <here> BEGIN'.\nA region marker is defined as a comment which is not preceded by other text\n(i.e. the comment is the first non-whitespace on the line), and which starts\nwith either 'BEGIN' or 'END'.", "sp_cmt_cpp_region"))+"\n#"+self.wrap(self.tr("Overrides sp_cmt_cpp_start.", "sp_cmt_cpp_region")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_cmt_cpp_region = ' + self.option_sp_cmt_cpp_region.currentText())
        if full or  'false'!=self.option_sp_cmt_cpp_doxygen.currentText():
            if comment:
                s.append(self.wrap(self.tr("If true, space added with sp_cmt_cpp_start will be added after Doxygen\nsequences like '///', '///<', '//!' and '//!<'.", "sp_cmt_cpp_doxygen")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('sp_cmt_cpp_doxygen = ' + self.option_sp_cmt_cpp_doxygen.currentText())
        if full or  'false'!=self.option_sp_cmt_cpp_qttr.currentText():
            if comment:
                s.append(self.wrap(self.tr("If true, space added with sp_cmt_cpp_start will be added after Qt translator\nor meta-data comments like '//:', '//=', and '//~'.", "sp_cmt_cpp_qttr")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('sp_cmt_cpp_qttr = ' + self.option_sp_cmt_cpp_qttr.currentText())
        if full or  'ignore'!=self.option_sp_endif_cmt.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between #else or #endif and a trailing comment.", "sp_endif_cmt")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_endif_cmt = ' + self.option_sp_endif_cmt.currentText())
        if full or  'ignore'!=self.option_sp_after_new.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after 'new', 'delete' and 'delete[]'.", "sp_after_new")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_new = ' + self.option_sp_after_new.currentText())
        if full or  'ignore'!=self.option_sp_between_new_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between 'new' and '(' in 'new()'.", "sp_between_new_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_between_new_paren = ' + self.option_sp_between_new_paren.currentText())
        if full or  'ignore'!=self.option_sp_after_newop_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between ')' and type in 'new(foo) BAR'.", "sp_after_newop_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_newop_paren = ' + self.option_sp_after_newop_paren.currentText())
        if full or  'ignore'!=self.option_sp_inside_newop_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space inside parentheses of the new operator\nas in 'new(foo) BAR'.", "sp_inside_newop_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_newop_paren = ' + self.option_sp_inside_newop_paren.currentText())
        if full or  'ignore'!=self.option_sp_inside_newop_paren_open.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after the open parenthesis of the new operator,\nas in 'new(foo) BAR'.", "sp_inside_newop_paren_open"))+"\n#"+self.wrap(self.tr("Overrides sp_inside_newop_paren.", "sp_inside_newop_paren_open")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_newop_paren_open = ' + self.option_sp_inside_newop_paren_open.currentText())
        if full or  'ignore'!=self.option_sp_inside_newop_paren_close.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before the close parenthesis of the new operator,\nas in 'new(foo) BAR'.", "sp_inside_newop_paren_close"))+"\n#"+self.wrap(self.tr("Overrides sp_inside_newop_paren.", "sp_inside_newop_paren_close")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_inside_newop_paren_close = ' + self.option_sp_inside_newop_paren_close.currentText())
        if full or  'ignore'!=self.option_sp_before_tr_cmt.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before a trailing comment.", "sp_before_tr_cmt")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_tr_cmt = ' + self.option_sp_before_tr_cmt.currentText())
        if full or  0!=self.option_sp_num_before_tr_cmt.value():
            if comment:
                s.append(self.wrap(self.tr("Number of spaces before a trailing comment.", "sp_num_before_tr_cmt")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('sp_num_before_tr_cmt = ' + str(self.option_sp_num_before_tr_cmt.value()))
        if full or  'force'!=self.option_sp_before_emb_cmt.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before an embedded comment.", "sp_before_emb_cmt")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: force ")
            s.append('sp_before_emb_cmt = ' + self.option_sp_before_emb_cmt.currentText())
        if full or  1!=self.option_sp_num_before_emb_cmt.value():
            if comment:
                s.append(self.wrap(self.tr("Number of spaces before an embedded comment.", "sp_num_before_emb_cmt")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 1 ")
            s.append('sp_num_before_emb_cmt = ' + str(self.option_sp_num_before_emb_cmt.value()))
        if full or  'force'!=self.option_sp_after_emb_cmt.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after an embedded comment.", "sp_after_emb_cmt")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: force ")
            s.append('sp_after_emb_cmt = ' + self.option_sp_after_emb_cmt.currentText())
        if full or  1!=self.option_sp_num_after_emb_cmt.value():
            if comment:
                s.append(self.wrap(self.tr("Number of spaces after an embedded comment.", "sp_num_after_emb_cmt")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 1 ")
            s.append('sp_num_after_emb_cmt = ' + str(self.option_sp_num_after_emb_cmt.value()))
        if full or  'false'!=self.option_sp_emb_cmt_priority.currentText():
            if comment:
                s.append(self.wrap(self.tr("Embedded comment spacing options have higher priority (== override)\nthan other spacing options (comma, parenthesis, braces, ...)", "sp_emb_cmt_priority")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('sp_emb_cmt_priority = ' + self.option_sp_emb_cmt_priority.currentText())
        if full or  'ignore'!=self.option_sp_annotation_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("(Java) Add or remove space between an annotation and the open parenthesis.", "sp_annotation_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_annotation_paren = ' + self.option_sp_annotation_paren.currentText())
        if full or  'false'!=self.option_sp_skip_vbrace_tokens.currentText():
            if comment:
                s.append(self.wrap(self.tr("If true, vbrace tokens are dropped to the previous token and skipped.", "sp_skip_vbrace_tokens")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('sp_skip_vbrace_tokens = ' + self.option_sp_skip_vbrace_tokens.currentText())
        if full or  'ignore'!=self.option_sp_after_noexcept.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after 'noexcept'.", "sp_after_noexcept")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_noexcept = ' + self.option_sp_after_noexcept.currentText())
        if full or  'ignore'!=self.option_sp_vala_after_translation.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after '_'.", "sp_vala_after_translation")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_vala_after_translation = ' + self.option_sp_vala_after_translation.currentText())
        if full or  'ignore'!=self.option_sp_before_bit_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space before a bit colon ':'.", "sp_before_bit_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_before_bit_colon = ' + self.option_sp_before_bit_colon.currentText())
        if full or  'ignore'!=self.option_sp_after_bit_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after a bit colon ':'.", "sp_after_bit_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_after_bit_colon = ' + self.option_sp_after_bit_colon.currentText())
        if full or  'false'!=self.option_force_tab_after_define.currentText():
            if comment:
                s.append(self.wrap(self.tr("If true, a <TAB> is inserted after #define.", "force_tab_after_define")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('force_tab_after_define = ' + self.option_force_tab_after_define.currentText())
        if full or  'ignore'!=self.option_sp_string_string.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space between two strings.", "sp_string_string")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_string_string = ' + self.option_sp_string_string.currentText())
        if full or  'ignore'!=self.option_sp_struct_type.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space 'struct' and a type.", "sp_struct_type")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('sp_struct_type = ' + self.option_sp_struct_type.currentText())
        #================== Indenting options ===============================================================
        if full or  comment: s.append('\n\n'+'#'*80+self.wrap(self.tr("Indenting options"))+'\n'+'#'*80)
        if full or  8!=self.option_indent_columns.value():
            if comment:
                s.append(self.wrap(self.tr("The number of columns to indent per level. Usually 2, 3, 4, or 8.", "indent_columns")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 8 ")
            s.append('indent_columns = ' + str(self.option_indent_columns.value()))
        if full or  'false'!=self.option_indent_ignore_first_continue.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to ignore indent for the first continuation line. Subsequent\ncontinuation lines will still be indented to match the first.", "indent_ignore_first_continue")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_ignore_first_continue = ' + self.option_indent_ignore_first_continue.currentText())
        if full or  0!=self.option_indent_continue.value():
            if comment:
                s.append(self.wrap(self.tr("The continuation indent. If non-zero, this overrides the indent of '(', '['\nand '=' continuation indents. Negative values are OK; negative value is\nabsolute and not increased for each '(' or '[' level.", "indent_continue"))+"\n#"+self.wrap(self.tr("For FreeBSD, this is set to 4.\nRequires indent_ignore_first_continue=false.", "indent_continue")))
                s.append("#\n# Type: signed  -16  16")
                s.append("# Default: 0 ")
            s.append('indent_continue = ' + str(self.option_indent_continue.value()))
        if full or  0!=self.option_indent_continue_class_head.value():
            if comment:
                s.append(self.wrap(self.tr("The continuation indent, only for class header line(s). If non-zero, this\noverrides the indent of 'class' continuation indents.\nRequires indent_ignore_first_continue=false.", "indent_continue_class_head")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('indent_continue_class_head = ' + str(self.option_indent_continue_class_head.value()))
        if full or  'false'!=self.option_indent_single_newlines.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent empty lines (i.e. lines which contain only spaces before\nthe newline character).", "indent_single_newlines")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_single_newlines = ' + self.option_indent_single_newlines.currentText())
        if full or  0!=self.option_indent_param.value():
            if comment:
                s.append(self.wrap(self.tr("The continuation indent for func_*_param if they are true. If non-zero, this\noverrides the indent.", "indent_param")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('indent_param = ' + str(self.option_indent_param.value()))
        if full or  1!=self.option_indent_with_tabs.value():
            if comment:
                s.append(self.wrap(self.tr("How to use tabs when indenting code.", "indent_with_tabs"))+"\n#"+self.wrap(self.tr("0: Spaces only\n1: Indent with tabs to brace level, align with spaces (default)\n2: Indent and align with tabs, using spaces when not on a tabstop", "indent_with_tabs")))
                s.append("#\n# Type: unsigned  0  2")
                s.append("# Default: 1 ")
            s.append('indent_with_tabs = ' + str(self.option_indent_with_tabs.value()))
        if full or  'false'!=self.option_indent_cmt_with_tabs.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent comments that are not at a brace level with tabs on a\ntabstop. Requires indent_with_tabs=2. If false, will use spaces.", "indent_cmt_with_tabs")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_cmt_with_tabs = ' + self.option_indent_cmt_with_tabs.currentText())
        if full or  'false'!=self.option_indent_align_string.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent strings broken by '\\' so that they line up.", "indent_align_string")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_align_string = ' + self.option_indent_align_string.currentText())
        if full or  0!=self.option_indent_xml_string.value():
            if comment:
                s.append(self.wrap(self.tr("The number of spaces to indent multi-line XML strings.\nRequires indent_align_string=true.", "indent_xml_string")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('indent_xml_string = ' + str(self.option_indent_xml_string.value()))
        if full or  0!=self.option_indent_brace.value():
            if comment:
                s.append(self.wrap(self.tr("Spaces to indent '{' from level.", "indent_brace")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('indent_brace = ' + str(self.option_indent_brace.value()))
        if full or  'false'!=self.option_indent_braces.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether braces are indented to the body level.", "indent_braces")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_braces = ' + self.option_indent_braces.currentText())
        if full or  'false'!=self.option_indent_braces_no_func.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to disable indenting function braces if indent_braces=true.", "indent_braces_no_func")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_braces_no_func = ' + self.option_indent_braces_no_func.currentText())
        if full or  'false'!=self.option_indent_braces_no_class.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to disable indenting class braces if indent_braces=true.", "indent_braces_no_class")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_braces_no_class = ' + self.option_indent_braces_no_class.currentText())
        if full or  'false'!=self.option_indent_braces_no_struct.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to disable indenting struct braces if indent_braces=true.", "indent_braces_no_struct")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_braces_no_struct = ' + self.option_indent_braces_no_struct.currentText())
        if full or  'false'!=self.option_indent_brace_parent.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent based on the size of the brace parent,\ni.e. 'if' => 3 spaces, 'for' => 4 spaces, etc.", "indent_brace_parent")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_brace_parent = ' + self.option_indent_brace_parent.currentText())
        if full or  'false'!=self.option_indent_paren_open_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent based on the open parenthesis instead of the open brace\nin '({\\n'.", "indent_paren_open_brace")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_paren_open_brace = ' + self.option_indent_paren_open_brace.currentText())
        if full or  'false'!=self.option_indent_cs_delegate_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("(C#) Whether to indent the brace of a C# delegate by another level.", "indent_cs_delegate_brace")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_cs_delegate_brace = ' + self.option_indent_cs_delegate_brace.currentText())
        if full or  'false'!=self.option_indent_cs_delegate_body.currentText():
            if comment:
                s.append(self.wrap(self.tr("(C#) Whether to indent a C# delegate (to handle delegates with no brace) by\nanother level.", "indent_cs_delegate_body")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_cs_delegate_body = ' + self.option_indent_cs_delegate_body.currentText())
        if full or  'false'!=self.option_indent_namespace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent the body of a 'namespace'.", "indent_namespace")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_namespace = ' + self.option_indent_namespace.currentText())
        if full or  'false'!=self.option_indent_namespace_single_indent.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent only the first namespace, and not any nested namespaces.\nRequires indent_namespace=true.", "indent_namespace_single_indent")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_namespace_single_indent = ' + self.option_indent_namespace_single_indent.currentText())
        if full or  0!=self.option_indent_namespace_level.value():
            if comment:
                s.append(self.wrap(self.tr("The number of spaces to indent a namespace block.\nIf set to zero, use the value indent_columns", "indent_namespace_level")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('indent_namespace_level = ' + str(self.option_indent_namespace_level.value()))
        if full or  0!=self.option_indent_namespace_limit.value():
            if comment:
                s.append(self.wrap(self.tr("If the body of the namespace is longer than this number, it won't be\nindented. Requires indent_namespace=true. 0 means no limit.", "indent_namespace_limit")))
                s.append("#\n# Type: unsigned  0  255")
                s.append("# Default: 0 ")
            s.append('indent_namespace_limit = ' + str(self.option_indent_namespace_limit.value()))
        if full or  'false'!=self.option_indent_namespace_inner_only.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent only in inner namespaces (nested in other namespaces).\nRequires indent_namespace=true.", "indent_namespace_inner_only")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_namespace_inner_only = ' + self.option_indent_namespace_inner_only.currentText())
        if full or  'false'!=self.option_indent_extern.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether the 'extern \"C\"' body is indented.", "indent_extern")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_extern = ' + self.option_indent_extern.currentText())
        if full or  'false'!=self.option_indent_class.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether the 'class' body is indented.", "indent_class")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_class = ' + self.option_indent_class.currentText())
        if full or  'false'!=self.option_indent_ignore_before_class_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to ignore indent for the leading base class colon.", "indent_ignore_before_class_colon")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_ignore_before_class_colon = ' + self.option_indent_ignore_before_class_colon.currentText())
        if full or  0!=self.option_indent_before_class_colon.value():
            if comment:
                s.append(self.wrap(self.tr("Additional indent before the leading base class colon.\nNegative values decrease indent down to the first column.\nRequires indent_ignore_before_class_colon=false and a newline break before\nthe colon (see pos_class_colon and nl_class_colon)", "indent_before_class_colon")))
                s.append("#\n# Type: signed  -16  16")
                s.append("# Default: 0 ")
            s.append('indent_before_class_colon = ' + str(self.option_indent_before_class_colon.value()))
        if full or  'false'!=self.option_indent_class_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent the stuff after a leading base class colon.", "indent_class_colon")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_class_colon = ' + self.option_indent_class_colon.currentText())
        if full or  'false'!=self.option_indent_class_on_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent based on a class colon instead of the stuff after the\ncolon. Requires indent_class_colon=true.", "indent_class_on_colon")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_class_on_colon = ' + self.option_indent_class_on_colon.currentText())
        if full or  'false'!=self.option_indent_ignore_before_constr_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to ignore indent for a leading class initializer colon.", "indent_ignore_before_constr_colon")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_ignore_before_constr_colon = ' + self.option_indent_ignore_before_constr_colon.currentText())
        if full or  'false'!=self.option_indent_constr_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent the stuff after a leading class initializer colon.", "indent_constr_colon")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_constr_colon = ' + self.option_indent_constr_colon.currentText())
        if full or  2!=self.option_indent_ctor_init_leading.value():
            if comment:
                s.append(self.wrap(self.tr("Virtual indent from the ':' for leading member initializers.", "indent_ctor_init_leading")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 2 ")
            s.append('indent_ctor_init_leading = ' + str(self.option_indent_ctor_init_leading.value()))
        if full or  2!=self.option_indent_ctor_init_following.value():
            if comment:
                s.append(self.wrap(self.tr("Virtual indent from the ':' for following member initializers.", "indent_ctor_init_following")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 2 ")
            s.append('indent_ctor_init_following = ' + str(self.option_indent_ctor_init_following.value()))
        if full or  0!=self.option_indent_ctor_init.value():
            if comment:
                s.append(self.wrap(self.tr("Additional indent for constructor initializer list.\nNegative values decrease indent down to the first column.", "indent_ctor_init")))
                s.append("#\n# Type: signed  -16  16")
                s.append("# Default: 0 ")
            s.append('indent_ctor_init = ' + str(self.option_indent_ctor_init.value()))
        if full or  'false'!=self.option_indent_else_if.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent 'if' following 'else' as a new block under the 'else'.\nIf false, 'else\\nif' is treated as 'else if' for indenting purposes.", "indent_else_if")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_else_if = ' + self.option_indent_else_if.currentText())
        if full or  0!=self.option_indent_var_def_blk.value():
            if comment:
                s.append(self.wrap(self.tr("Amount to indent variable declarations after a open brace.", "indent_var_def_blk"))+"\n#"+self.wrap(self.tr(" <0: Relative\n>=0: Absolute", "indent_var_def_blk")))
                s.append("#\n# Type: signed  -16  16")
                s.append("# Default: 0 ")
            s.append('indent_var_def_blk = ' + str(self.option_indent_var_def_blk.value()))
        if full or  'false'!=self.option_indent_var_def_cont.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent continued variable declarations instead of aligning.", "indent_var_def_cont")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_var_def_cont = ' + self.option_indent_var_def_cont.currentText())
        if full or  0!=self.option_indent_shift.value():
            if comment:
                s.append(self.wrap(self.tr("How to indent continued shift expressions ('<<' and '>>').\nSet align_left_shift=false when using this.\n 0: Align shift operators instead of indenting them (default)\n 1: Indent by one level\n-1: Preserve original indentation", "indent_shift")))
                s.append("#\n# Type: signed  -1  1")
                s.append("# Default: 0 ")
            s.append('indent_shift = ' + str(self.option_indent_shift.value()))
        if full or  'false'!=self.option_indent_func_def_force_col1.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to force indentation of function definitions to start in column 1.", "indent_func_def_force_col1")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_func_def_force_col1 = ' + self.option_indent_func_def_force_col1.currentText())
        if full or  'false'!=self.option_indent_func_call_param.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent continued function call parameters one indent level,\nrather than aligning parameters under the open parenthesis.", "indent_func_call_param")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_func_call_param = ' + self.option_indent_func_call_param.currentText())
        if full or  'false'!=self.option_indent_func_def_param.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent continued function definition parameters one indent level,\nrather than aligning parameters under the open parenthesis.", "indent_func_def_param")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_func_def_param = ' + self.option_indent_func_def_param.currentText())
        if full or  0!=self.option_indent_func_def_param_paren_pos_threshold.value():
            if comment:
                s.append(self.wrap(self.tr("for function definitions, only if indent_func_def_param is false\nAllows to align params when appropriate and indent them when not\nbehave as if it was true if paren position is more than this value\nif paren position is more than the option value", "indent_func_def_param_paren_pos_threshold")))
                s.append("#\n# Type: unsigned  0  160")
                s.append("# Default: 0 ")
            s.append('indent_func_def_param_paren_pos_threshold = ' + str(self.option_indent_func_def_param_paren_pos_threshold.value()))
        if full or  'false'!=self.option_indent_func_proto_param.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent continued function call prototype one indent level,\nrather than aligning parameters under the open parenthesis.", "indent_func_proto_param")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_func_proto_param = ' + self.option_indent_func_proto_param.currentText())
        if full or  'false'!=self.option_indent_func_class_param.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent continued function call declaration one indent level,\nrather than aligning parameters under the open parenthesis.", "indent_func_class_param")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_func_class_param = ' + self.option_indent_func_class_param.currentText())
        if full or  'false'!=self.option_indent_func_ctor_var_param.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent continued class variable constructors one indent level,\nrather than aligning parameters under the open parenthesis.", "indent_func_ctor_var_param")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_func_ctor_var_param = ' + self.option_indent_func_ctor_var_param.currentText())
        if full or  'false'!=self.option_indent_template_param.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent continued template parameter list one indent level,\nrather than aligning parameters under the open parenthesis.", "indent_template_param")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_template_param = ' + self.option_indent_template_param.currentText())
        if full or  'false'!=self.option_indent_func_param_double.currentText():
            if comment:
                s.append(self.wrap(self.tr("Double the indent for indent_func_xxx_param options.\nUse both values of the options indent_columns and indent_param.", "indent_func_param_double")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_func_param_double = ' + self.option_indent_func_param_double.currentText())
        if full or  0!=self.option_indent_func_const.value():
            if comment:
                s.append(self.wrap(self.tr("Indentation column for standalone 'const' qualifier on a function\nprototype.", "indent_func_const")))
                s.append("#\n# Type: unsigned  0  69")
                s.append("# Default: 0 ")
            s.append('indent_func_const = ' + str(self.option_indent_func_const.value()))
        if full or  0!=self.option_indent_func_throw.value():
            if comment:
                s.append(self.wrap(self.tr("Indentation column for standalone 'throw' qualifier on a function\nprototype.", "indent_func_throw")))
                s.append("#\n# Type: unsigned  0  41")
                s.append("# Default: 0 ")
            s.append('indent_func_throw = ' + str(self.option_indent_func_throw.value()))
        if full or  'true'!=self.option_indent_macro_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("How to indent within a macro followed by a brace on the same line\nThis allows reducing the indent in macros that have (for example)\n`do { ... } while (0)` blocks bracketing them.", "indent_macro_brace"))+"\n#"+self.wrap(self.tr("true:  add an indent for the brace on the same line as the macro\nfalse: do not add an indent for the brace on the same line as the macro", "indent_macro_brace")))
                s.append("#\n# Type: true/false")
                s.append("# Default: true ")
            s.append('indent_macro_brace = ' + self.option_indent_macro_brace.currentText())
        if full or  0!=self.option_indent_member.value():
            if comment:
                s.append(self.wrap(self.tr("The number of spaces to indent a continued '->' or '.'.\nUsually set to 0, 1, or indent_columns.", "indent_member")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('indent_member = ' + str(self.option_indent_member.value()))
        if full or  'false'!=self.option_indent_member_single.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether lines broken at '.' or '->' should be indented by a single indent.\nThe indent_member option will not be effective if this is set to true.", "indent_member_single")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_member_single = ' + self.option_indent_member_single.currentText())
        if full or  0!=self.option_indent_single_line_comments_before.value():
            if comment:
                s.append(self.wrap(self.tr("Spaces to indent single line ('//') comments on lines before code.", "indent_single_line_comments_before")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('indent_single_line_comments_before = ' + str(self.option_indent_single_line_comments_before.value()))
        if full or  0!=self.option_indent_single_line_comments_after.value():
            if comment:
                s.append(self.wrap(self.tr("Spaces to indent single line ('//') comments on lines after code.", "indent_single_line_comments_after")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('indent_single_line_comments_after = ' + str(self.option_indent_single_line_comments_after.value()))
        if full or  0!=self.option_indent_sparen_extra.value():
            if comment:
                s.append(self.wrap(self.tr("When opening a paren for a control statement (if, for, while, etc), increase\nthe indent level by this value. Negative values decrease the indent level.", "indent_sparen_extra")))
                s.append("#\n# Type: signed  -16  16")
                s.append("# Default: 0 ")
            s.append('indent_sparen_extra = ' + str(self.option_indent_sparen_extra.value()))
        if full or  'false'!=self.option_indent_relative_single_line_comments.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent trailing single line ('//') comments relative to the code\ninstead of trying to keep the same absolute column.", "indent_relative_single_line_comments")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_relative_single_line_comments = ' + self.option_indent_relative_single_line_comments.currentText())
        if full or  0!=self.option_indent_switch_case.value():
            if comment:
                s.append(self.wrap(self.tr("Spaces to indent 'case' from 'switch'. Usually 0 or indent_columns.\nIt might be wise to choose the same value for the option indent_case_brace.", "indent_switch_case")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('indent_switch_case = ' + str(self.option_indent_switch_case.value()))
        if full or  0!=self.option_indent_switch_body.value():
            if comment:
                s.append(self.wrap(self.tr("Spaces to indent the body of a 'switch' before any 'case'.\nUsually the same as indent_columns or indent_switch_case.", "indent_switch_body")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('indent_switch_body = ' + str(self.option_indent_switch_body.value()))
        if full or  'false'!=self.option_indent_ignore_case_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to ignore indent for '{' following 'case'.", "indent_ignore_case_brace")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_ignore_case_brace = ' + self.option_indent_ignore_case_brace.currentText())
        if full or  0!=self.option_indent_case_brace.value():
            if comment:
                s.append(self.wrap(self.tr("Spaces to indent '{' from 'case'. By default, the brace will appear under\nthe 'c' in case. Usually set to 0 or indent_columns. Negative values are OK.\nIt might be wise to choose the same value for the option indent_switch_case.", "indent_case_brace")))
                s.append("#\n# Type: signed  -16  16")
                s.append("# Default: 0 ")
            s.append('indent_case_brace = ' + str(self.option_indent_case_brace.value()))
        if full or  'false'!=self.option_indent_switch_break_with_case.currentText():
            if comment:
                s.append(self.wrap(self.tr("indent 'break' with 'case' from 'switch'.", "indent_switch_break_with_case")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_switch_break_with_case = ' + self.option_indent_switch_break_with_case.currentText())
        if full or  'true'!=self.option_indent_switch_pp.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent preprocessor statements inside of switch statements.", "indent_switch_pp")))
                s.append("#\n# Type: true/false")
                s.append("# Default: true ")
            s.append('indent_switch_pp = ' + self.option_indent_switch_pp.currentText())
        if full or  0!=self.option_indent_case_shift.value():
            if comment:
                s.append(self.wrap(self.tr("Spaces to shift the 'case' line, without affecting any other lines.\nUsually 0.", "indent_case_shift")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('indent_case_shift = ' + str(self.option_indent_case_shift.value()))
        if full or  'true'!=self.option_indent_case_comment.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to align comments before 'case' with the 'case'.", "indent_case_comment")))
                s.append("#\n# Type: true/false")
                s.append("# Default: true ")
            s.append('indent_case_comment = ' + self.option_indent_case_comment.currentText())
        if full or  'true'!=self.option_indent_comment.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent comments not found in first column.", "indent_comment")))
                s.append("#\n# Type: true/false")
                s.append("# Default: true ")
            s.append('indent_comment = ' + self.option_indent_comment.currentText())
        if full or  'false'!=self.option_indent_col1_comment.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent comments found in first column.", "indent_col1_comment")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_col1_comment = ' + self.option_indent_col1_comment.currentText())
        if full or  'false'!=self.option_indent_col1_multi_string_literal.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent multi string literal in first column.", "indent_col1_multi_string_literal")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_col1_multi_string_literal = ' + self.option_indent_col1_multi_string_literal.currentText())
        if full or  3!=self.option_indent_comment_align_thresh.value():
            if comment:
                s.append(self.wrap(self.tr("Align comments on adjacent lines that are this many columns apart or less.", "indent_comment_align_thresh")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 3 ")
            s.append('indent_comment_align_thresh = ' + str(self.option_indent_comment_align_thresh.value()))
        if full or  'false'!=self.option_indent_ignore_label.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to ignore indent for goto labels.", "indent_ignore_label")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_ignore_label = ' + self.option_indent_ignore_label.currentText())
        if full or  1!=self.option_indent_label.value():
            if comment:
                s.append(self.wrap(self.tr("How to indent goto labels. Requires indent_ignore_label=false.", "indent_label"))+"\n#"+self.wrap(self.tr(" >0: Absolute column where 1 is the leftmost column\n<=0: Subtract from brace indent", "indent_label")))
                s.append("#\n# Type: signed  -16  16")
                s.append("# Default: 1 ")
            s.append('indent_label = ' + str(self.option_indent_label.value()))
        if full or  1!=self.option_indent_access_spec.value():
            if comment:
                s.append(self.wrap(self.tr("How to indent access specifiers that are followed by a\ncolon.", "indent_access_spec"))+"\n#"+self.wrap(self.tr(" >0: Absolute column where 1 is the leftmost column\n<=0: Subtract from brace indent", "indent_access_spec")))
                s.append("#\n# Type: signed  -16  16")
                s.append("# Default: 1 ")
            s.append('indent_access_spec = ' + str(self.option_indent_access_spec.value()))
        if full or  'false'!=self.option_indent_access_spec_body.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent the code after an access specifier by one level.\nIf true, this option forces 'indent_access_spec=0'.", "indent_access_spec_body")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_access_spec_body = ' + self.option_indent_access_spec_body.currentText())
        if full or  'false'!=self.option_indent_paren_nl.currentText():
            if comment:
                s.append(self.wrap(self.tr("If an open parenthesis is followed by a newline, whether to indent the next\nline so that it lines up after the open parenthesis (not recommended).", "indent_paren_nl")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_paren_nl = ' + self.option_indent_paren_nl.currentText())
        if full or  0!=self.option_indent_paren_close.value():
            if comment:
                s.append(self.wrap(self.tr("How to indent a close parenthesis after a newline.", "indent_paren_close"))+"\n#"+self.wrap(self.tr(" 0: Indent to body level (default)\n 1: Align under the open parenthesis\n 2: Indent to the brace level\n-1: Preserve original indentation", "indent_paren_close")))
                s.append("#\n# Type: signed  -1  2")
                s.append("# Default: 0 ")
            s.append('indent_paren_close = ' + str(self.option_indent_paren_close.value()))
        if full or  'false'!=self.option_indent_paren_after_func_def.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent the open parenthesis of a function definition,\nif the parenthesis is on its own line.", "indent_paren_after_func_def")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_paren_after_func_def = ' + self.option_indent_paren_after_func_def.currentText())
        if full or  'false'!=self.option_indent_paren_after_func_decl.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent the open parenthesis of a function declaration,\nif the parenthesis is on its own line.", "indent_paren_after_func_decl")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_paren_after_func_decl = ' + self.option_indent_paren_after_func_decl.currentText())
        if full or  'false'!=self.option_indent_paren_after_func_call.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent the open parenthesis of a function call,\nif the parenthesis is on its own line.", "indent_paren_after_func_call")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_paren_after_func_call = ' + self.option_indent_paren_after_func_call.currentText())
        if full or  0!=self.option_indent_comma_brace.value():
            if comment:
                s.append(self.wrap(self.tr("How to indent a comma when inside braces.\n 0: Indent by one level (default)\n 1: Align under the open brace\n-1: Preserve original indentation", "indent_comma_brace")))
                s.append("#\n# Type: signed  -1  1")
                s.append("# Default: 0 ")
            s.append('indent_comma_brace = ' + str(self.option_indent_comma_brace.value()))
        if full or  0!=self.option_indent_comma_paren.value():
            if comment:
                s.append(self.wrap(self.tr("How to indent a comma when inside parentheses.\n 0: Indent by one level (default)\n 1: Align under the open parenthesis\n-1: Preserve original indentation", "indent_comma_paren")))
                s.append("#\n# Type: signed  -1  1")
                s.append("# Default: 0 ")
            s.append('indent_comma_paren = ' + str(self.option_indent_comma_paren.value()))
        if full or  0!=self.option_indent_bool_paren.value():
            if comment:
                s.append(self.wrap(self.tr("How to indent a Boolean operator when inside parentheses.\n 0: Indent by one level (default)\n 1: Align under the open parenthesis\n-1: Preserve original indentation", "indent_bool_paren")))
                s.append("#\n# Type: signed  -1  1")
                s.append("# Default: 0 ")
            s.append('indent_bool_paren = ' + str(self.option_indent_bool_paren.value()))
        if full or  'false'!=self.option_indent_ignore_bool.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to ignore the indentation of a Boolean operator when outside\nparentheses.", "indent_ignore_bool")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_ignore_bool = ' + self.option_indent_ignore_bool.currentText())
        if full or  'false'!=self.option_indent_ignore_arith.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to ignore the indentation of an arithmetic operator.", "indent_ignore_arith")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_ignore_arith = ' + self.option_indent_ignore_arith.currentText())
        if full or  'false'!=self.option_indent_semicolon_for_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent a semicolon when inside a for parenthesis.\nIf true, aligns under the open for parenthesis.", "indent_semicolon_for_paren")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_semicolon_for_paren = ' + self.option_indent_semicolon_for_paren.currentText())
        if full or  'false'!=self.option_indent_ignore_semicolon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to ignore the indentation of a semicolon outside of a 'for'\nstatement.", "indent_ignore_semicolon")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_ignore_semicolon = ' + self.option_indent_ignore_semicolon.currentText())
        if full or  'false'!=self.option_indent_first_bool_expr.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to align the first expression to following ones\nif indent_bool_paren=1.", "indent_first_bool_expr")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_first_bool_expr = ' + self.option_indent_first_bool_expr.currentText())
        if full or  'false'!=self.option_indent_first_for_expr.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to align the first expression to following ones\nif indent_semicolon_for_paren=true.", "indent_first_for_expr")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_first_for_expr = ' + self.option_indent_first_for_expr.currentText())
        if full or  'false'!=self.option_indent_square_nl.currentText():
            if comment:
                s.append(self.wrap(self.tr("If an open square is followed by a newline, whether to indent the next line\nso that it lines up after the open square (not recommended).", "indent_square_nl")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_square_nl = ' + self.option_indent_square_nl.currentText())
        if full or  'false'!=self.option_indent_preserve_sql.currentText():
            if comment:
                s.append(self.wrap(self.tr("(ESQL/C) Whether to preserve the relative indent of 'EXEC SQL' bodies.", "indent_preserve_sql")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_preserve_sql = ' + self.option_indent_preserve_sql.currentText())
        if full or  'false'!=self.option_indent_ignore_assign.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to ignore the indentation of an assignment operator.", "indent_ignore_assign")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_ignore_assign = ' + self.option_indent_ignore_assign.currentText())
        if full or  'true'!=self.option_indent_align_assign.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to align continued statements at the '='. If false or if the '=' is\nfollowed by a newline, the next line is indent one tab.", "indent_align_assign")))
                s.append("#\n# Type: true/false")
                s.append("# Default: true ")
            s.append('indent_align_assign = ' + self.option_indent_align_assign.currentText())
        if full or  'false'!=self.option_indent_off_after_assign.currentText():
            if comment:
                s.append(self.wrap(self.tr("If true, the indentation of the chunks after a '=' sequence will be set at\nLHS token indentation column before '='.", "indent_off_after_assign")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_off_after_assign = ' + self.option_indent_off_after_assign.currentText())
        if full or  'true'!=self.option_indent_align_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to align continued statements at the '('. If false or the '(' is\nfollowed by a newline, the next line indent is one tab.", "indent_align_paren")))
                s.append("#\n# Type: true/false")
                s.append("# Default: true ")
            s.append('indent_align_paren = ' + self.option_indent_align_paren.currentText())
        if full or  'false'!=self.option_indent_oc_inside_msg_sel.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Whether to indent Objective-C code inside message selectors.", "indent_oc_inside_msg_sel")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_oc_inside_msg_sel = ' + self.option_indent_oc_inside_msg_sel.currentText())
        if full or  'false'!=self.option_indent_oc_block.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Whether to indent Objective-C blocks at brace level instead of usual\nrules.", "indent_oc_block")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_oc_block = ' + self.option_indent_oc_block.currentText())
        if full or  0!=self.option_indent_oc_block_msg.value():
            if comment:
                s.append(self.wrap(self.tr("(OC) Indent for Objective-C blocks in a message relative to the parameter\nname.", "indent_oc_block_msg"))+"\n#"+self.wrap(self.tr("=0: Use indent_oc_block rules\n>0: Use specified number of spaces to indent", "indent_oc_block_msg")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('indent_oc_block_msg = ' + str(self.option_indent_oc_block_msg.value()))
        if full or  0!=self.option_indent_oc_msg_colon.value():
            if comment:
                s.append(self.wrap(self.tr("(OC) Minimum indent for subsequent parameters", "indent_oc_msg_colon")))
                s.append("#\n# Type: unsigned  0  5000")
                s.append("# Default: 0 ")
            s.append('indent_oc_msg_colon = ' + str(self.option_indent_oc_msg_colon.value()))
        if full or  'true'!=self.option_indent_oc_msg_prioritize_first_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Whether to prioritize aligning with initial colon (and stripping spaces\nfrom lines, if necessary).", "indent_oc_msg_prioritize_first_colon")))
                s.append("#\n# Type: true/false")
                s.append("# Default: true ")
            s.append('indent_oc_msg_prioritize_first_colon = ' + self.option_indent_oc_msg_prioritize_first_colon.currentText())
        if full or  'false'!=self.option_indent_oc_block_msg_xcode_style.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Whether to indent blocks the way that Xcode does by default\n(from the keyword if the parameter is on its own line; otherwise, from the\nprevious indentation level). Requires indent_oc_block_msg=true.", "indent_oc_block_msg_xcode_style")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_oc_block_msg_xcode_style = ' + self.option_indent_oc_block_msg_xcode_style.currentText())
        if full or  'false'!=self.option_indent_oc_block_msg_from_keyword.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Whether to indent blocks from where the brace is, relative to a\nmessage keyword. Requires indent_oc_block_msg=true.", "indent_oc_block_msg_from_keyword")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_oc_block_msg_from_keyword = ' + self.option_indent_oc_block_msg_from_keyword.currentText())
        if full or  'false'!=self.option_indent_oc_block_msg_from_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Whether to indent blocks from where the brace is, relative to a message\ncolon. Requires indent_oc_block_msg=true.", "indent_oc_block_msg_from_colon")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_oc_block_msg_from_colon = ' + self.option_indent_oc_block_msg_from_colon.currentText())
        if full or  'false'!=self.option_indent_oc_block_msg_from_caret.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Whether to indent blocks from where the block caret is.\nRequires indent_oc_block_msg=true.", "indent_oc_block_msg_from_caret")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_oc_block_msg_from_caret = ' + self.option_indent_oc_block_msg_from_caret.currentText())
        if full or  'false'!=self.option_indent_oc_block_msg_from_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Whether to indent blocks from where the brace caret is.\nRequires indent_oc_block_msg=true.", "indent_oc_block_msg_from_brace")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_oc_block_msg_from_brace = ' + self.option_indent_oc_block_msg_from_brace.currentText())
        if full or  0!=self.option_indent_min_vbrace_open.value():
            if comment:
                s.append(self.wrap(self.tr("When indenting after virtual brace open and newline add further spaces to\nreach this minimum indent.", "indent_min_vbrace_open")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('indent_min_vbrace_open = ' + str(self.option_indent_min_vbrace_open.value()))
        if full or  'false'!=self.option_indent_vbrace_open_on_tabstop.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add further spaces after regular indent to reach next tabstop\nwhen indenting after virtual brace open and newline.", "indent_vbrace_open_on_tabstop")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_vbrace_open_on_tabstop = ' + self.option_indent_vbrace_open_on_tabstop.currentText())
        if full or  'true'!=self.option_indent_token_after_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("How to indent after a brace followed by another token (not a newline).\ntrue:  indent all contained lines to match the token\nfalse: indent all contained lines to match the brace", "indent_token_after_brace")))
                s.append("#\n# Type: true/false")
                s.append("# Default: true ")
            s.append('indent_token_after_brace = ' + self.option_indent_token_after_brace.currentText())
        if full or  'false'!=self.option_indent_cpp_lambda_body.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent the body of a C++11 lambda.", "indent_cpp_lambda_body")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_cpp_lambda_body = ' + self.option_indent_cpp_lambda_body.currentText())
        if full or  'true'!=self.option_indent_compound_literal_return.currentText():
            if comment:
                s.append(self.wrap(self.tr("How to indent compound literals that are being returned.\ntrue: add both the indent from return & the compound literal open brace\n      (i.e. 2 indent levels)\nfalse: only indent 1 level, don't add the indent for the open brace, only\n       add the indent for the return.", "indent_compound_literal_return")))
                s.append("#\n# Type: true/false")
                s.append("# Default: true ")
            s.append('indent_compound_literal_return = ' + self.option_indent_compound_literal_return.currentText())
        if full or  'true'!=self.option_indent_using_block.currentText():
            if comment:
                s.append(self.wrap(self.tr("(C#) Whether to indent a 'using' block if no braces are used.", "indent_using_block")))
                s.append("#\n# Type: true/false")
                s.append("# Default: true ")
            s.append('indent_using_block = ' + self.option_indent_using_block.currentText())
        if full or  0!=self.option_indent_ternary_operator.value():
            if comment:
                s.append(self.wrap(self.tr("How to indent the continuation of ternary operator.", "indent_ternary_operator"))+"\n#"+self.wrap(self.tr("0: Off (default)\n1: When the `if_false` is a continuation, indent it under the `if_true` branch\n2: When the `:` is a continuation, indent it under `?`", "indent_ternary_operator")))
                s.append("#\n# Type: unsigned  0  2")
                s.append("# Default: 0 ")
            s.append('indent_ternary_operator = ' + str(self.option_indent_ternary_operator.value()))
        if full or  'false'!=self.option_indent_inside_ternary_operator.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent the statements inside ternary operator.", "indent_inside_ternary_operator")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_inside_ternary_operator = ' + self.option_indent_inside_ternary_operator.currentText())
        if full or  'false'!=self.option_indent_off_after_return.currentText():
            if comment:
                s.append(self.wrap(self.tr("If true, the indentation of the chunks after a `return` sequence will be set at return indentation column.", "indent_off_after_return")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_off_after_return = ' + self.option_indent_off_after_return.currentText())
        if full or  'false'!=self.option_indent_off_after_return_new.currentText():
            if comment:
                s.append(self.wrap(self.tr("If true, the indentation of the chunks after a `return new` sequence will be set at return indentation column.", "indent_off_after_return_new")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_off_after_return_new = ' + self.option_indent_off_after_return_new.currentText())
        if full or  'false'!=self.option_indent_single_after_return.currentText():
            if comment:
                s.append(self.wrap(self.tr("If true, the tokens after return are indented with regular single indentation. By default (false) the indentation is after the return token.", "indent_single_after_return")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_single_after_return = ' + self.option_indent_single_after_return.currentText())
        if full or  'false'!=self.option_indent_ignore_asm_block.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to ignore indent and alignment for 'asm' blocks (i.e. assume they\nhave their own indentation).", "indent_ignore_asm_block")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_ignore_asm_block = ' + self.option_indent_ignore_asm_block.currentText())
        if full or  'false'!=self.option_donot_indent_func_def_close_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Don't indent the close parenthesis of a function definition,\nif the parenthesis is on its own line.", "donot_indent_func_def_close_paren")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('donot_indent_func_def_close_paren = ' + self.option_donot_indent_func_def_close_paren.currentText())
        #================== Newline adding and removing options =============================================
        if full or  comment: s.append('\n\n'+'#'*80+self.wrap(self.tr("Newline adding and removing options"))+'\n'+'#'*80)
        if full or  'false'!=self.option_nl_collapse_empty_body.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to collapse empty blocks between '{' and '}' except for functions.\nUse nl_collapse_empty_body_functions to specify how empty function braces\nshould be formatted.", "nl_collapse_empty_body")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_collapse_empty_body = ' + self.option_nl_collapse_empty_body.currentText())
        if full or  'false'!=self.option_nl_collapse_empty_body_functions.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to collapse empty blocks between '{' and '}' for functions only.\nIf true, overrides nl_inside_empty_func.", "nl_collapse_empty_body_functions")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_collapse_empty_body_functions = ' + self.option_nl_collapse_empty_body_functions.currentText())
        if full or  'false'!=self.option_nl_assign_leave_one_liners.currentText():
            if comment:
                s.append(self.wrap(self.tr("Don't split one-line braced assignments, as in 'foo_t f = { 1, 2 };'.", "nl_assign_leave_one_liners")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_assign_leave_one_liners = ' + self.option_nl_assign_leave_one_liners.currentText())
        if full or  'false'!=self.option_nl_class_leave_one_liners.currentText():
            if comment:
                s.append(self.wrap(self.tr("Don't split one-line braced statements inside a 'class xx { }' body.", "nl_class_leave_one_liners")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_class_leave_one_liners = ' + self.option_nl_class_leave_one_liners.currentText())
        if full or  'false'!=self.option_nl_enum_leave_one_liners.currentText():
            if comment:
                s.append(self.wrap(self.tr("Don't split one-line enums, as in 'enum foo { BAR = 15 };'", "nl_enum_leave_one_liners")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_enum_leave_one_liners = ' + self.option_nl_enum_leave_one_liners.currentText())
        if full or  'false'!=self.option_nl_getset_leave_one_liners.currentText():
            if comment:
                s.append(self.wrap(self.tr("Don't split one-line get or set functions.", "nl_getset_leave_one_liners")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_getset_leave_one_liners = ' + self.option_nl_getset_leave_one_liners.currentText())
        if full or  'false'!=self.option_nl_cs_property_leave_one_liners.currentText():
            if comment:
                s.append(self.wrap(self.tr("(C#) Don't split one-line property get or set functions.", "nl_cs_property_leave_one_liners")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_cs_property_leave_one_liners = ' + self.option_nl_cs_property_leave_one_liners.currentText())
        if full or  'false'!=self.option_nl_func_leave_one_liners.currentText():
            if comment:
                s.append(self.wrap(self.tr("Don't split one-line function definitions, as in 'int foo() { return 0; }'.\nmight modify nl_func_type_name", "nl_func_leave_one_liners")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_func_leave_one_liners = ' + self.option_nl_func_leave_one_liners.currentText())
        if full or  'false'!=self.option_nl_cpp_lambda_leave_one_liners.currentText():
            if comment:
                s.append(self.wrap(self.tr("Don't split one-line C++11 lambdas, as in '[]() { return 0; }'.", "nl_cpp_lambda_leave_one_liners")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_cpp_lambda_leave_one_liners = ' + self.option_nl_cpp_lambda_leave_one_liners.currentText())
        if full or  'false'!=self.option_nl_if_leave_one_liners.currentText():
            if comment:
                s.append(self.wrap(self.tr("Don't split one-line if/else statements, as in 'if(...) b++;'.", "nl_if_leave_one_liners")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_if_leave_one_liners = ' + self.option_nl_if_leave_one_liners.currentText())
        if full or  'false'!=self.option_nl_while_leave_one_liners.currentText():
            if comment:
                s.append(self.wrap(self.tr("Don't split one-line while statements, as in 'while(...) b++;'.", "nl_while_leave_one_liners")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_while_leave_one_liners = ' + self.option_nl_while_leave_one_liners.currentText())
        if full or  'false'!=self.option_nl_do_leave_one_liners.currentText():
            if comment:
                s.append(self.wrap(self.tr("Don't split one-line do statements, as in 'do { b++; } while(...);'.", "nl_do_leave_one_liners")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_do_leave_one_liners = ' + self.option_nl_do_leave_one_liners.currentText())
        if full or  'false'!=self.option_nl_for_leave_one_liners.currentText():
            if comment:
                s.append(self.wrap(self.tr("Don't split one-line for statements, as in 'for(...) b++;'.", "nl_for_leave_one_liners")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_for_leave_one_liners = ' + self.option_nl_for_leave_one_liners.currentText())
        if full or  'false'!=self.option_nl_oc_msg_leave_one_liner.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Don't split one-line Objective-C messages.", "nl_oc_msg_leave_one_liner")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_oc_msg_leave_one_liner = ' + self.option_nl_oc_msg_leave_one_liner.currentText())
        if full or  'ignore'!=self.option_nl_oc_mdef_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove newline between method declaration and '{'.", "nl_oc_mdef_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_oc_mdef_brace = ' + self.option_nl_oc_mdef_brace.currentText())
        if full or  'ignore'!=self.option_nl_oc_block_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove newline between Objective-C block signature and '{'.", "nl_oc_block_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_oc_block_brace = ' + self.option_nl_oc_block_brace.currentText())
        if full or  'ignore'!=self.option_nl_oc_before_interface.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove blank line before '@interface' statement.", "nl_oc_before_interface")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_oc_before_interface = ' + self.option_nl_oc_before_interface.currentText())
        if full or  'ignore'!=self.option_nl_oc_before_implementation.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove blank line before '@implementation' statement.", "nl_oc_before_implementation")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_oc_before_implementation = ' + self.option_nl_oc_before_implementation.currentText())
        if full or  'ignore'!=self.option_nl_oc_before_end.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove blank line before '@end' statement.", "nl_oc_before_end")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_oc_before_end = ' + self.option_nl_oc_before_end.currentText())
        if full or  'ignore'!=self.option_nl_oc_interface_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove newline between '@interface' and '{'.", "nl_oc_interface_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_oc_interface_brace = ' + self.option_nl_oc_interface_brace.currentText())
        if full or  'ignore'!=self.option_nl_oc_implementation_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove newline between '@implementation' and '{'.", "nl_oc_implementation_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_oc_implementation_brace = ' + self.option_nl_oc_implementation_brace.currentText())
        if full or  'ignore'!=self.option_nl_start_of_file.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newlines at the start of the file.", "nl_start_of_file")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_start_of_file = ' + self.option_nl_start_of_file.currentText())
        if full or  0!=self.option_nl_start_of_file_min.value():
            if comment:
                s.append(self.wrap(self.tr("The minimum number of newlines at the start of the file (only used if\nnl_start_of_file is 'add' or 'force').", "nl_start_of_file_min")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_start_of_file_min = ' + str(self.option_nl_start_of_file_min.value()))
        if full or  'ignore'!=self.option_nl_end_of_file.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline at the end of the file.", "nl_end_of_file")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_end_of_file = ' + self.option_nl_end_of_file.currentText())
        if full or  0!=self.option_nl_end_of_file_min.value():
            if comment:
                s.append(self.wrap(self.tr("The minimum number of newlines at the end of the file (only used if\nnl_end_of_file is 'add' or 'force').", "nl_end_of_file_min")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_end_of_file_min = ' + str(self.option_nl_end_of_file_min.value()))
        if full or  'ignore'!=self.option_nl_assign_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between '=' and '{'.", "nl_assign_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_assign_brace = ' + self.option_nl_assign_brace.currentText())
        if full or  'ignore'!=self.option_nl_assign_square.currentText():
            if comment:
                s.append(self.wrap(self.tr("(D) Add or remove newline between '=' and '['.", "nl_assign_square")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_assign_square = ' + self.option_nl_assign_square.currentText())
        if full or  'ignore'!=self.option_nl_tsquare_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between '[]' and '{'.", "nl_tsquare_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_tsquare_brace = ' + self.option_nl_tsquare_brace.currentText())
        if full or  'ignore'!=self.option_nl_after_square_assign.currentText():
            if comment:
                s.append(self.wrap(self.tr("(D) Add or remove newline after '= ['. Will also affect the newline before\nthe ']'.", "nl_after_square_assign")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_after_square_assign = ' + self.option_nl_after_square_assign.currentText())
        if full or  'ignore'!=self.option_nl_fcall_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between a function call's ')' and '{', as in\n'list_for_each(item, &list) { }'.", "nl_fcall_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_fcall_brace = ' + self.option_nl_fcall_brace.currentText())
        if full or  'ignore'!=self.option_nl_enum_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'enum' and '{'.", "nl_enum_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_enum_brace = ' + self.option_nl_enum_brace.currentText())
        if full or  'ignore'!=self.option_nl_enum_class.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'enum' and 'class'.", "nl_enum_class")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_enum_class = ' + self.option_nl_enum_class.currentText())
        if full or  'ignore'!=self.option_nl_enum_class_identifier.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'enum class' and the identifier.", "nl_enum_class_identifier")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_enum_class_identifier = ' + self.option_nl_enum_class_identifier.currentText())
        if full or  'ignore'!=self.option_nl_enum_identifier_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'enum class' type and ':'.", "nl_enum_identifier_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_enum_identifier_colon = ' + self.option_nl_enum_identifier_colon.currentText())
        if full or  'ignore'!=self.option_nl_enum_colon_type.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'enum class identifier :' and type.", "nl_enum_colon_type")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_enum_colon_type = ' + self.option_nl_enum_colon_type.currentText())
        if full or  'ignore'!=self.option_nl_struct_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'struct and '{'.", "nl_struct_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_struct_brace = ' + self.option_nl_struct_brace.currentText())
        if full or  'ignore'!=self.option_nl_union_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'union' and '{'.", "nl_union_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_union_brace = ' + self.option_nl_union_brace.currentText())
        if full or  'ignore'!=self.option_nl_if_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'if' and '{'.", "nl_if_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_if_brace = ' + self.option_nl_if_brace.currentText())
        if full or  'ignore'!=self.option_nl_brace_else.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between '}' and 'else'.", "nl_brace_else")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_brace_else = ' + self.option_nl_brace_else.currentText())
        if full or  'ignore'!=self.option_nl_elseif_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'else if' and '{'. If set to ignore,\nnl_if_brace is used instead.", "nl_elseif_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_elseif_brace = ' + self.option_nl_elseif_brace.currentText())
        if full or  'ignore'!=self.option_nl_else_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'else' and '{'.", "nl_else_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_else_brace = ' + self.option_nl_else_brace.currentText())
        if full or  'ignore'!=self.option_nl_else_if.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'else' and 'if'.", "nl_else_if")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_else_if = ' + self.option_nl_else_if.currentText())
        if full or  'ignore'!=self.option_nl_before_opening_brace_func_class_def.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline before '{' opening brace", "nl_before_opening_brace_func_class_def")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_before_opening_brace_func_class_def = ' + self.option_nl_before_opening_brace_func_class_def.currentText())
        if full or  'ignore'!=self.option_nl_before_if_closing_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline before 'if'/'else if' closing parenthesis.", "nl_before_if_closing_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_before_if_closing_paren = ' + self.option_nl_before_if_closing_paren.currentText())
        if full or  'ignore'!=self.option_nl_brace_finally.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between '}' and 'finally'.", "nl_brace_finally")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_brace_finally = ' + self.option_nl_brace_finally.currentText())
        if full or  'ignore'!=self.option_nl_finally_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'finally' and '{'.", "nl_finally_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_finally_brace = ' + self.option_nl_finally_brace.currentText())
        if full or  'ignore'!=self.option_nl_try_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'try' and '{'.", "nl_try_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_try_brace = ' + self.option_nl_try_brace.currentText())
        if full or  'ignore'!=self.option_nl_getset_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between get/set and '{'.", "nl_getset_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_getset_brace = ' + self.option_nl_getset_brace.currentText())
        if full or  'ignore'!=self.option_nl_for_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'for' and '{'.", "nl_for_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_for_brace = ' + self.option_nl_for_brace.currentText())
        if full or  'ignore'!=self.option_nl_catch_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline before the '{' of a 'catch' statement, as in\n'catch (decl) <here> {'.", "nl_catch_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_catch_brace = ' + self.option_nl_catch_brace.currentText())
        if full or  'ignore'!=self.option_nl_oc_catch_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove newline before the '{' of a '@catch' statement, as in\n'@catch (decl) <here> {'. If set to ignore, nl_catch_brace is used.", "nl_oc_catch_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_oc_catch_brace = ' + self.option_nl_oc_catch_brace.currentText())
        if full or  'ignore'!=self.option_nl_brace_catch.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between '}' and 'catch'.", "nl_brace_catch")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_brace_catch = ' + self.option_nl_brace_catch.currentText())
        if full or  'ignore'!=self.option_nl_oc_brace_catch.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Add or remove newline between '}' and '@catch'. If set to ignore,\nnl_brace_catch is used.", "nl_oc_brace_catch")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_oc_brace_catch = ' + self.option_nl_oc_brace_catch.currentText())
        if full or  'ignore'!=self.option_nl_brace_square.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between '}' and ']'.", "nl_brace_square")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_brace_square = ' + self.option_nl_brace_square.currentText())
        if full or  'ignore'!=self.option_nl_brace_fparen.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between '}' and ')' in a function invocation.", "nl_brace_fparen")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_brace_fparen = ' + self.option_nl_brace_fparen.currentText())
        if full or  'ignore'!=self.option_nl_while_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'while' and '{'.", "nl_while_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_while_brace = ' + self.option_nl_while_brace.currentText())
        if full or  'ignore'!=self.option_nl_scope_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("(D) Add or remove newline between 'scope (x)' and '{'.", "nl_scope_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_scope_brace = ' + self.option_nl_scope_brace.currentText())
        if full or  'ignore'!=self.option_nl_unittest_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("(D) Add or remove newline between 'unittest' and '{'.", "nl_unittest_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_unittest_brace = ' + self.option_nl_unittest_brace.currentText())
        if full or  'ignore'!=self.option_nl_version_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("(D) Add or remove newline between 'version (x)' and '{'.", "nl_version_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_version_brace = ' + self.option_nl_version_brace.currentText())
        if full or  'ignore'!=self.option_nl_using_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("(C#) Add or remove newline between 'using' and '{'.", "nl_using_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_using_brace = ' + self.option_nl_using_brace.currentText())
        if full or  'ignore'!=self.option_nl_brace_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between two open or close braces. Due to general\nnewline/brace handling, REMOVE may not work.", "nl_brace_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_brace_brace = ' + self.option_nl_brace_brace.currentText())
        if full or  'ignore'!=self.option_nl_do_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'do' and '{'.", "nl_do_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_do_brace = ' + self.option_nl_do_brace.currentText())
        if full or  'ignore'!=self.option_nl_brace_while.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between '}' and 'while' of 'do' statement.", "nl_brace_while")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_brace_while = ' + self.option_nl_brace_while.currentText())
        if full or  'ignore'!=self.option_nl_switch_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'switch' and '{'.", "nl_switch_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_switch_brace = ' + self.option_nl_switch_brace.currentText())
        if full or  'ignore'!=self.option_nl_synchronized_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'synchronized' and '{'.", "nl_synchronized_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_synchronized_brace = ' + self.option_nl_synchronized_brace.currentText())
        if full or  'false'!=self.option_nl_multi_line_cond.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add a newline between ')' and '{' if the ')' is on a different line than the\nif/for/etc.", "nl_multi_line_cond"))+"\n#"+self.wrap(self.tr("Overrides nl_for_brace, nl_if_brace, nl_switch_brace, nl_while_switch and\nnl_catch_brace.", "nl_multi_line_cond")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_multi_line_cond = ' + self.option_nl_multi_line_cond.currentText())
        if full or  'ignore'!=self.option_nl_multi_line_sparen_open.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add a newline after '(' if an if/for/while/switch condition spans multiple\nlines", "nl_multi_line_sparen_open")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_multi_line_sparen_open = ' + self.option_nl_multi_line_sparen_open.currentText())
        if full or  'ignore'!=self.option_nl_multi_line_sparen_close.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add a newline before ')' if an if/for/while/switch condition spans multiple\nlines. Overrides nl_before_if_closing_paren if both are specified.", "nl_multi_line_sparen_close")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_multi_line_sparen_close = ' + self.option_nl_multi_line_sparen_close.currentText())
        if full or  'false'!=self.option_nl_multi_line_define.currentText():
            if comment:
                s.append(self.wrap(self.tr("Force a newline in a define after the macro name for multi-line defines.", "nl_multi_line_define")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_multi_line_define = ' + self.option_nl_multi_line_define.currentText())
        if full or  'false'!=self.option_nl_before_case.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline before 'case', and a blank line before a 'case'\nstatement that follows a ';' or '}'.", "nl_before_case")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_before_case = ' + self.option_nl_before_case.currentText())
        if full or  'false'!=self.option_nl_after_case.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline after a 'case' statement.", "nl_after_case")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_after_case = ' + self.option_nl_after_case.currentText())
        if full or  'ignore'!=self.option_nl_case_colon_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between a case ':' and '{'.", "nl_case_colon_brace"))+"\n#"+self.wrap(self.tr("Overrides nl_after_case.", "nl_case_colon_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_case_colon_brace = ' + self.option_nl_case_colon_brace.currentText())
        if full or  'ignore'!=self.option_nl_before_throw.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between ')' and 'throw'.", "nl_before_throw")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_before_throw = ' + self.option_nl_before_throw.currentText())
        if full or  'ignore'!=self.option_nl_namespace_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'namespace' and '{'.", "nl_namespace_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_namespace_brace = ' + self.option_nl_namespace_brace.currentText())
        if full or  'ignore'!=self.option_nl_template_class.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline after 'template<...>' of a template class.", "nl_template_class")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_template_class = ' + self.option_nl_template_class.currentText())
        if full or  'ignore'!=self.option_nl_template_class_decl.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline after 'template<...>' of a template class declaration.", "nl_template_class_decl"))+"\n#"+self.wrap(self.tr("Overrides nl_template_class.", "nl_template_class_decl")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_template_class_decl = ' + self.option_nl_template_class_decl.currentText())
        if full or  'ignore'!=self.option_nl_template_class_decl_special.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline after 'template<>' of a specialized class declaration.", "nl_template_class_decl_special"))+"\n#"+self.wrap(self.tr("Overrides nl_template_class_decl.", "nl_template_class_decl_special")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_template_class_decl_special = ' + self.option_nl_template_class_decl_special.currentText())
        if full or  'ignore'!=self.option_nl_template_class_def.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline after 'template<...>' of a template class definition.", "nl_template_class_def"))+"\n#"+self.wrap(self.tr("Overrides nl_template_class.", "nl_template_class_def")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_template_class_def = ' + self.option_nl_template_class_def.currentText())
        if full or  'ignore'!=self.option_nl_template_class_def_special.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline after 'template<>' of a specialized class definition.", "nl_template_class_def_special"))+"\n#"+self.wrap(self.tr("Overrides nl_template_class_def.", "nl_template_class_def_special")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_template_class_def_special = ' + self.option_nl_template_class_def_special.currentText())
        if full or  'ignore'!=self.option_nl_template_func.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline after 'template<...>' of a template function.", "nl_template_func")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_template_func = ' + self.option_nl_template_func.currentText())
        if full or  'ignore'!=self.option_nl_template_func_decl.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline after 'template<...>' of a template function\ndeclaration.", "nl_template_func_decl"))+"\n#"+self.wrap(self.tr("Overrides nl_template_func.", "nl_template_func_decl")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_template_func_decl = ' + self.option_nl_template_func_decl.currentText())
        if full or  'ignore'!=self.option_nl_template_func_decl_special.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline after 'template<>' of a specialized function\ndeclaration.", "nl_template_func_decl_special"))+"\n#"+self.wrap(self.tr("Overrides nl_template_func_decl.", "nl_template_func_decl_special")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_template_func_decl_special = ' + self.option_nl_template_func_decl_special.currentText())
        if full or  'ignore'!=self.option_nl_template_func_def.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline after 'template<...>' of a template function\ndefinition.", "nl_template_func_def"))+"\n#"+self.wrap(self.tr("Overrides nl_template_func.", "nl_template_func_def")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_template_func_def = ' + self.option_nl_template_func_def.currentText())
        if full or  'ignore'!=self.option_nl_template_func_def_special.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline after 'template<>' of a specialized function\ndefinition.", "nl_template_func_def_special"))+"\n#"+self.wrap(self.tr("Overrides nl_template_func_def.", "nl_template_func_def_special")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_template_func_def_special = ' + self.option_nl_template_func_def_special.currentText())
        if full or  'ignore'!=self.option_nl_template_var.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline after 'template<...>' of a template variable.", "nl_template_var")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_template_var = ' + self.option_nl_template_var.currentText())
        if full or  'ignore'!=self.option_nl_template_using.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'template<...>' and 'using' of a templated\ntype alias.", "nl_template_using")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_template_using = ' + self.option_nl_template_using.currentText())
        if full or  'ignore'!=self.option_nl_class_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'class' and '{'.", "nl_class_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_class_brace = ' + self.option_nl_class_brace.currentText())
        if full or  'ignore'!=self.option_nl_class_init_args.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline before or after (depending on pos_class_comma,\nmay not be IGNORE) each',' in the base class list.", "nl_class_init_args")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_class_init_args = ' + self.option_nl_class_init_args.currentText())
        if full or  'ignore'!=self.option_nl_constr_init_args.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline after each ',' in the constructor member\ninitialization. Related to nl_constr_colon, pos_constr_colon and\npos_constr_comma.", "nl_constr_init_args")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_constr_init_args = ' + self.option_nl_constr_init_args.currentText())
        if full or  'ignore'!=self.option_nl_enum_own_lines.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline before first element, after comma, and after last\nelement, in 'enum'.", "nl_enum_own_lines")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_enum_own_lines = ' + self.option_nl_enum_own_lines.currentText())
        if full or  'ignore'!=self.option_nl_func_type_name.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between return type and function name in a function\ndefinition.\nmight be modified by nl_func_leave_one_liners", "nl_func_type_name")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_type_name = ' + self.option_nl_func_type_name.currentText())
        if full or  'ignore'!=self.option_nl_func_type_name_class.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between return type and function name inside a class\ndefinition. If set to ignore, nl_func_type_name or nl_func_proto_type_name\nis used instead.", "nl_func_type_name_class")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_type_name_class = ' + self.option_nl_func_type_name_class.currentText())
        if full or  'ignore'!=self.option_nl_func_class_scope.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between class specification and '::'\nin 'void A::f() { }'. Only appears in separate member implementation (does\nnot appear with in-line implementation).", "nl_func_class_scope")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_class_scope = ' + self.option_nl_func_class_scope.currentText())
        if full or  'ignore'!=self.option_nl_func_scope_name.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between function scope and name, as in\n'void A :: <here> f() { }'.", "nl_func_scope_name")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_scope_name = ' + self.option_nl_func_scope_name.currentText())
        if full or  'ignore'!=self.option_nl_func_proto_type_name.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between return type and function name in a prototype.", "nl_func_proto_type_name")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_proto_type_name = ' + self.option_nl_func_proto_type_name.currentText())
        if full or  'ignore'!=self.option_nl_func_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between a function name and the opening '(' in the\ndeclaration.", "nl_func_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_paren = ' + self.option_nl_func_paren.currentText())
        if full or  'ignore'!=self.option_nl_func_paren_empty.currentText():
            if comment:
                s.append(self.wrap(self.tr("Overrides nl_func_paren for functions with no parameters.", "nl_func_paren_empty")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_paren_empty = ' + self.option_nl_func_paren_empty.currentText())
        if full or  'ignore'!=self.option_nl_func_def_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between a function name and the opening '(' in the\ndefinition.", "nl_func_def_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_def_paren = ' + self.option_nl_func_def_paren.currentText())
        if full or  'ignore'!=self.option_nl_func_def_paren_empty.currentText():
            if comment:
                s.append(self.wrap(self.tr("Overrides nl_func_def_paren for functions with no parameters.", "nl_func_def_paren_empty")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_def_paren_empty = ' + self.option_nl_func_def_paren_empty.currentText())
        if full or  'ignore'!=self.option_nl_func_call_paren.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between a function name and the opening '(' in the\ncall.", "nl_func_call_paren")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_call_paren = ' + self.option_nl_func_call_paren.currentText())
        if full or  'ignore'!=self.option_nl_func_call_paren_empty.currentText():
            if comment:
                s.append(self.wrap(self.tr("Overrides nl_func_call_paren for functions with no parameters.", "nl_func_call_paren_empty")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_call_paren_empty = ' + self.option_nl_func_call_paren_empty.currentText())
        if full or  'ignore'!=self.option_nl_func_decl_start.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline after '(' in a function declaration.", "nl_func_decl_start")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_decl_start = ' + self.option_nl_func_decl_start.currentText())
        if full or  'ignore'!=self.option_nl_func_def_start.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline after '(' in a function definition.", "nl_func_def_start")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_def_start = ' + self.option_nl_func_def_start.currentText())
        if full or  'ignore'!=self.option_nl_func_decl_start_single.currentText():
            if comment:
                s.append(self.wrap(self.tr("Overrides nl_func_decl_start when there is only one parameter.", "nl_func_decl_start_single")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_decl_start_single = ' + self.option_nl_func_decl_start_single.currentText())
        if full or  'ignore'!=self.option_nl_func_def_start_single.currentText():
            if comment:
                s.append(self.wrap(self.tr("Overrides nl_func_def_start when there is only one parameter.", "nl_func_def_start_single")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_def_start_single = ' + self.option_nl_func_def_start_single.currentText())
        if full or  'false'!=self.option_nl_func_decl_start_multi_line.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline after '(' in a function declaration if '(' and ')'\nare in different lines. If false, nl_func_decl_start is used instead.", "nl_func_decl_start_multi_line")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_func_decl_start_multi_line = ' + self.option_nl_func_decl_start_multi_line.currentText())
        if full or  'false'!=self.option_nl_func_def_start_multi_line.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline after '(' in a function definition if '(' and ')'\nare in different lines. If false, nl_func_def_start is used instead.", "nl_func_def_start_multi_line")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_func_def_start_multi_line = ' + self.option_nl_func_def_start_multi_line.currentText())
        if full or  'ignore'!=self.option_nl_func_decl_args.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline after each ',' in a function declaration.", "nl_func_decl_args")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_decl_args = ' + self.option_nl_func_decl_args.currentText())
        if full or  'ignore'!=self.option_nl_func_def_args.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline after each ',' in a function definition.", "nl_func_def_args")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_def_args = ' + self.option_nl_func_def_args.currentText())
        if full or  'ignore'!=self.option_nl_func_call_args.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline after each ',' in a function call.", "nl_func_call_args")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_call_args = ' + self.option_nl_func_call_args.currentText())
        if full or  'false'!=self.option_nl_func_decl_args_multi_line.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline after each ',' in a function declaration if '('\nand ')' are in different lines. If false, nl_func_decl_args is used instead.", "nl_func_decl_args_multi_line")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_func_decl_args_multi_line = ' + self.option_nl_func_decl_args_multi_line.currentText())
        if full or  'false'!=self.option_nl_func_def_args_multi_line.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline after each ',' in a function definition if '('\nand ')' are in different lines. If false, nl_func_def_args is used instead.", "nl_func_def_args_multi_line")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_func_def_args_multi_line = ' + self.option_nl_func_def_args_multi_line.currentText())
        if full or  'ignore'!=self.option_nl_func_decl_end.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline before the ')' in a function declaration.", "nl_func_decl_end")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_decl_end = ' + self.option_nl_func_decl_end.currentText())
        if full or  'ignore'!=self.option_nl_func_def_end.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline before the ')' in a function definition.", "nl_func_def_end")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_def_end = ' + self.option_nl_func_def_end.currentText())
        if full or  'ignore'!=self.option_nl_func_decl_end_single.currentText():
            if comment:
                s.append(self.wrap(self.tr("Overrides nl_func_decl_end when there is only one parameter.", "nl_func_decl_end_single")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_decl_end_single = ' + self.option_nl_func_decl_end_single.currentText())
        if full or  'ignore'!=self.option_nl_func_def_end_single.currentText():
            if comment:
                s.append(self.wrap(self.tr("Overrides nl_func_def_end when there is only one parameter.", "nl_func_def_end_single")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_def_end_single = ' + self.option_nl_func_def_end_single.currentText())
        if full or  'false'!=self.option_nl_func_decl_end_multi_line.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline before ')' in a function declaration if '(' and ')'\nare in different lines. If false, nl_func_decl_end is used instead.", "nl_func_decl_end_multi_line")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_func_decl_end_multi_line = ' + self.option_nl_func_decl_end_multi_line.currentText())
        if full or  'false'!=self.option_nl_func_def_end_multi_line.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline before ')' in a function definition if '(' and ')'\nare in different lines. If false, nl_func_def_end is used instead.", "nl_func_def_end_multi_line")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_func_def_end_multi_line = ' + self.option_nl_func_def_end_multi_line.currentText())
        if full or  'ignore'!=self.option_nl_func_decl_empty.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between '()' in a function declaration.", "nl_func_decl_empty")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_decl_empty = ' + self.option_nl_func_decl_empty.currentText())
        if full or  'ignore'!=self.option_nl_func_def_empty.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between '()' in a function definition.", "nl_func_def_empty")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_def_empty = ' + self.option_nl_func_def_empty.currentText())
        if full or  'ignore'!=self.option_nl_func_call_empty.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between '()' in a function call.", "nl_func_call_empty")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_call_empty = ' + self.option_nl_func_call_empty.currentText())
        if full or  'ignore'!=self.option_nl_func_call_start.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline after '(' in a function call,\nhas preference over nl_func_call_start_multi_line.", "nl_func_call_start")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_call_start = ' + self.option_nl_func_call_start.currentText())
        if full or  'ignore'!=self.option_nl_func_call_end.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline before ')' in a function call.", "nl_func_call_end")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_func_call_end = ' + self.option_nl_func_call_end.currentText())
        if full or  'false'!=self.option_nl_func_call_start_multi_line.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline after '(' in a function call if '(' and ')' are in\ndifferent lines.", "nl_func_call_start_multi_line")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_func_call_start_multi_line = ' + self.option_nl_func_call_start_multi_line.currentText())
        if full or  'false'!=self.option_nl_func_call_args_multi_line.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline after each ',' in a function call if '(' and ')'\nare in different lines.", "nl_func_call_args_multi_line")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_func_call_args_multi_line = ' + self.option_nl_func_call_args_multi_line.currentText())
        if full or  'false'!=self.option_nl_func_call_end_multi_line.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline before ')' in a function call if '(' and ')' are in\ndifferent lines.", "nl_func_call_end_multi_line")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_func_call_end_multi_line = ' + self.option_nl_func_call_end_multi_line.currentText())
        if full or  'false'!=self.option_nl_func_call_args_multi_line_ignore_closures.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to respect nl_func_call_XXX option in case of closure args.", "nl_func_call_args_multi_line_ignore_closures")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_func_call_args_multi_line_ignore_closures = ' + self.option_nl_func_call_args_multi_line_ignore_closures.currentText())
        if full or  'false'!=self.option_nl_template_start.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline after '<' of a template parameter list.", "nl_template_start")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_template_start = ' + self.option_nl_template_start.currentText())
        if full or  'false'!=self.option_nl_template_args.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline after each ',' in a template parameter list.", "nl_template_args")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_template_args = ' + self.option_nl_template_args.currentText())
        if full or  'false'!=self.option_nl_template_end.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline before '>' of a template parameter list.", "nl_template_end")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_template_end = ' + self.option_nl_template_end.currentText())
        if full or  'false'!=self.option_nl_oc_msg_args.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Whether to put each Objective-C message parameter on a separate line.\nSee nl_oc_msg_leave_one_liner.", "nl_oc_msg_args")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_oc_msg_args = ' + self.option_nl_oc_msg_args.currentText())
        if full or  0!=self.option_nl_oc_msg_args_min_params.value():
            if comment:
                s.append(self.wrap(self.tr("(OC) Minimum number of Objective-C message parameters before applying nl_oc_msg_args.", "nl_oc_msg_args_min_params")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_oc_msg_args_min_params = ' + str(self.option_nl_oc_msg_args_min_params.value()))
        if full or  0!=self.option_nl_oc_msg_args_max_code_width.value():
            if comment:
                s.append(self.wrap(self.tr("(OC) Max code width of Objective-C message before applying nl_oc_msg_args.", "nl_oc_msg_args_max_code_width")))
                s.append("#\n# Type: unsigned  0  10000")
                s.append("# Default: 0 ")
            s.append('nl_oc_msg_args_max_code_width = ' + str(self.option_nl_oc_msg_args_max_code_width.value()))
        if full or  'false'!=self.option_nl_oc_msg_args_finish_multi_line.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Whether to apply nl_oc_msg_args if some of the parameters are already\non new lines. Overrides nl_oc_msg_args_min_params and nl_oc_msg_args_max_code_width.", "nl_oc_msg_args_finish_multi_line")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_oc_msg_args_finish_multi_line = ' + self.option_nl_oc_msg_args_finish_multi_line.currentText())
        if full or  'ignore'!=self.option_nl_fdef_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between function signature and '{'.", "nl_fdef_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_fdef_brace = ' + self.option_nl_fdef_brace.currentText())
        if full or  'ignore'!=self.option_nl_fdef_brace_cond.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between function signature and '{',\nif signature ends with ')'. Overrides nl_fdef_brace.", "nl_fdef_brace_cond")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_fdef_brace_cond = ' + self.option_nl_fdef_brace_cond.currentText())
        if full or  'ignore'!=self.option_nl_cpp_ldef_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between C++11 lambda signature and '{'.", "nl_cpp_ldef_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_cpp_ldef_brace = ' + self.option_nl_cpp_ldef_brace.currentText())
        if full or  'ignore'!=self.option_nl_return_expr.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'return' and the return expression.", "nl_return_expr")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_return_expr = ' + self.option_nl_return_expr.currentText())
        if full or  'ignore'!=self.option_nl_throw_expr.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between 'throw' and the throw expression.", "nl_throw_expr")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_throw_expr = ' + self.option_nl_throw_expr.currentText())
        if full or  'false'!=self.option_nl_after_semicolon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline after semicolons, except in 'for' statements.", "nl_after_semicolon")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_after_semicolon = ' + self.option_nl_after_semicolon.currentText())
        if full or  'ignore'!=self.option_nl_paren_dbrace_open.currentText():
            if comment:
                s.append(self.wrap(self.tr("(Java) Add or remove newline between the ')' and '{{' of the double brace\ninitializer.", "nl_paren_dbrace_open")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_paren_dbrace_open = ' + self.option_nl_paren_dbrace_open.currentText())
        if full or  'ignore'!=self.option_nl_type_brace_init_lst.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline after the type in an unnamed temporary\ndirect-list-initialization, better:\nbefore a direct-list-initialization.", "nl_type_brace_init_lst")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_type_brace_init_lst = ' + self.option_nl_type_brace_init_lst.currentText())
        if full or  'ignore'!=self.option_nl_type_brace_init_lst_open.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline after the open brace in an unnamed temporary\ndirect-list-initialization.", "nl_type_brace_init_lst_open")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_type_brace_init_lst_open = ' + self.option_nl_type_brace_init_lst_open.currentText())
        if full or  'ignore'!=self.option_nl_type_brace_init_lst_close.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline before the close brace in an unnamed temporary\ndirect-list-initialization.", "nl_type_brace_init_lst_close")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_type_brace_init_lst_close = ' + self.option_nl_type_brace_init_lst_close.currentText())
        if full or  'false'!=self.option_nl_before_brace_open.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline before '{'.", "nl_before_brace_open")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_before_brace_open = ' + self.option_nl_before_brace_open.currentText())
        if full or  'false'!=self.option_nl_after_brace_open.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline after '{'.", "nl_after_brace_open")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_after_brace_open = ' + self.option_nl_after_brace_open.currentText())
        if full or  'false'!=self.option_nl_after_brace_open_cmt.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline between the open brace and a trailing single-line\ncomment. Requires nl_after_brace_open=true.", "nl_after_brace_open_cmt")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_after_brace_open_cmt = ' + self.option_nl_after_brace_open_cmt.currentText())
        if full or  'false'!=self.option_nl_after_vbrace_open.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline after a virtual brace open with a non-empty body.\nThese occur in un-braced if/while/do/for statement bodies.", "nl_after_vbrace_open")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_after_vbrace_open = ' + self.option_nl_after_vbrace_open.currentText())
        if full or  'false'!=self.option_nl_after_vbrace_open_empty.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline after a virtual brace open with an empty body.\nThese occur in un-braced if/while/do/for statement bodies.", "nl_after_vbrace_open_empty")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_after_vbrace_open_empty = ' + self.option_nl_after_vbrace_open_empty.currentText())
        if full or  'false'!=self.option_nl_after_brace_close.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline after '}'. Does not apply if followed by a\nnecessary ';'.", "nl_after_brace_close")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_after_brace_close = ' + self.option_nl_after_brace_close.currentText())
        if full or  'false'!=self.option_nl_after_vbrace_close.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline after a virtual brace close,\nas in 'if (foo) a++; <here> return;'.", "nl_after_vbrace_close")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_after_vbrace_close = ' + self.option_nl_after_vbrace_close.currentText())
        if full or  'ignore'!=self.option_nl_brace_struct_var.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline between the close brace and identifier,\nas in 'struct { int a; } <here> b;'. Affects enumerations, unions and\nstructures. If set to ignore, uses nl_after_brace_close.", "nl_brace_struct_var")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_brace_struct_var = ' + self.option_nl_brace_struct_var.currentText())
        if full or  'false'!=self.option_nl_define_macro.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to alter newlines in '#define' macros.", "nl_define_macro")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_define_macro = ' + self.option_nl_define_macro.currentText())
        if full or  'false'!=self.option_nl_squeeze_paren_close.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to alter newlines between consecutive parenthesis closes. The number\nof closing parentheses in a line will depend on respective open parenthesis\nlines.", "nl_squeeze_paren_close")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_squeeze_paren_close = ' + self.option_nl_squeeze_paren_close.currentText())
        if full or  'false'!=self.option_nl_squeeze_ifdef.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to remove blanks after '#ifxx' and '#elxx', or before '#elxx' and\n'#endif'. Does not affect top-level #ifdefs.", "nl_squeeze_ifdef")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_squeeze_ifdef = ' + self.option_nl_squeeze_ifdef.currentText())
        if full or  'false'!=self.option_nl_squeeze_ifdef_top_level.currentText():
            if comment:
                s.append(self.wrap(self.tr("Makes the nl_squeeze_ifdef option affect the top-level #ifdefs as well.", "nl_squeeze_ifdef_top_level")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_squeeze_ifdef_top_level = ' + self.option_nl_squeeze_ifdef_top_level.currentText())
        if full or  'ignore'!=self.option_nl_before_if.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove blank line before 'if'.", "nl_before_if")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_before_if = ' + self.option_nl_before_if.currentText())
        if full or  'ignore'!=self.option_nl_after_if.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove blank line after 'if' statement. Add/Force work only if the\nnext token is not a closing brace.", "nl_after_if")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_after_if = ' + self.option_nl_after_if.currentText())
        if full or  'ignore'!=self.option_nl_before_for.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove blank line before 'for'.", "nl_before_for")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_before_for = ' + self.option_nl_before_for.currentText())
        if full or  'ignore'!=self.option_nl_after_for.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove blank line after 'for' statement.", "nl_after_for")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_after_for = ' + self.option_nl_after_for.currentText())
        if full or  'ignore'!=self.option_nl_before_while.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove blank line before 'while'.", "nl_before_while")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_before_while = ' + self.option_nl_before_while.currentText())
        if full or  'ignore'!=self.option_nl_after_while.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove blank line after 'while' statement.", "nl_after_while")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_after_while = ' + self.option_nl_after_while.currentText())
        if full or  'ignore'!=self.option_nl_before_switch.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove blank line before 'switch'.", "nl_before_switch")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_before_switch = ' + self.option_nl_before_switch.currentText())
        if full or  'ignore'!=self.option_nl_after_switch.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove blank line after 'switch' statement.", "nl_after_switch")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_after_switch = ' + self.option_nl_after_switch.currentText())
        if full or  'ignore'!=self.option_nl_before_synchronized.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove blank line before 'synchronized'.", "nl_before_synchronized")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_before_synchronized = ' + self.option_nl_before_synchronized.currentText())
        if full or  'ignore'!=self.option_nl_after_synchronized.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove blank line after 'synchronized' statement.", "nl_after_synchronized")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_after_synchronized = ' + self.option_nl_after_synchronized.currentText())
        if full or  'ignore'!=self.option_nl_before_do.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove blank line before 'do'.", "nl_before_do")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_before_do = ' + self.option_nl_before_do.currentText())
        if full or  'ignore'!=self.option_nl_after_do.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove blank line after 'do/while' statement.", "nl_after_do")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_after_do = ' + self.option_nl_after_do.currentText())
        if full or  'false'!=self.option_nl_before_ignore_after_case.currentText():
            if comment:
                s.append(self.wrap(self.tr("Ignore nl_before_{if,for,switch,do,synchronized} if the control\nstatement is immediately after a case statement.\nif nl_before_{if,for,switch,do} is set to remove, this option\ndoes nothing.", "nl_before_ignore_after_case")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_before_ignore_after_case = ' + self.option_nl_before_ignore_after_case.currentText())
        if full or  'false'!=self.option_nl_before_return.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to put a blank line before 'return' statements, unless after an open\nbrace.", "nl_before_return")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_before_return = ' + self.option_nl_before_return.currentText())
        if full or  'false'!=self.option_nl_after_return.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to put a blank line after 'return' statements, unless followed by a\nclose brace.", "nl_after_return")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_after_return = ' + self.option_nl_after_return.currentText())
        if full or  'ignore'!=self.option_nl_before_member.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to put a blank line before a member '.' or '->' operators.", "nl_before_member")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_before_member = ' + self.option_nl_before_member.currentText())
        if full or  'ignore'!=self.option_nl_after_member.currentText():
            if comment:
                s.append(self.wrap(self.tr("(Java) Whether to put a blank line after a member '.' or '->' operators.", "nl_after_member")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_after_member = ' + self.option_nl_after_member.currentText())
        if full or  'false'!=self.option_nl_ds_struct_enum_cmt.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to double-space commented-entries in 'struct'/'union'/'enum'.", "nl_ds_struct_enum_cmt")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_ds_struct_enum_cmt = ' + self.option_nl_ds_struct_enum_cmt.currentText())
        if full or  'false'!=self.option_nl_ds_struct_enum_close_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to force a newline before '}' of a 'struct'/'union'/'enum'.\n(Lower priority than eat_blanks_before_close_brace.)", "nl_ds_struct_enum_close_brace")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_ds_struct_enum_close_brace = ' + self.option_nl_ds_struct_enum_close_brace.currentText())
        if full or  'ignore'!=self.option_nl_class_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline before or after (depending on pos_class_colon) a class\ncolon, as in 'class Foo <here> : <or here> public Bar'.", "nl_class_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_class_colon = ' + self.option_nl_class_colon.currentText())
        if full or  'ignore'!=self.option_nl_constr_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove newline around a class constructor colon. The exact position\ndepends on nl_constr_init_args, pos_constr_colon and pos_constr_comma.", "nl_constr_colon")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_constr_colon = ' + self.option_nl_constr_colon.currentText())
        if full or  'false'!=self.option_nl_namespace_two_to_one_liner.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to collapse a two-line namespace, like 'namespace foo\\n{ decl; }'\ninto a single line. If true, prevents other brace newline rules from turning\nsuch code into four lines. If true, it also preserves one-liner namespaces.", "nl_namespace_two_to_one_liner")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_namespace_two_to_one_liner = ' + self.option_nl_namespace_two_to_one_liner.currentText())
        if full or  'false'!=self.option_nl_create_if_one_liner.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to remove a newline in simple unbraced if statements, turning them\ninto one-liners, as in 'if(b)\\n i++;' => 'if(b) i++;'.", "nl_create_if_one_liner")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_create_if_one_liner = ' + self.option_nl_create_if_one_liner.currentText())
        if full or  'false'!=self.option_nl_create_for_one_liner.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to remove a newline in simple unbraced for statements, turning them\ninto one-liners, as in 'for (...)\\n stmt;' => 'for (...) stmt;'.", "nl_create_for_one_liner")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_create_for_one_liner = ' + self.option_nl_create_for_one_liner.currentText())
        if full or  'false'!=self.option_nl_create_while_one_liner.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to remove a newline in simple unbraced while statements, turning\nthem into one-liners, as in 'while (expr)\\n stmt;' => 'while (expr) stmt;'.", "nl_create_while_one_liner")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_create_while_one_liner = ' + self.option_nl_create_while_one_liner.currentText())
        if full or  'false'!=self.option_nl_create_func_def_one_liner.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to collapse a function definition whose body (not counting braces)\nis only one line so that the entire definition (prototype, braces, body) is\na single line.", "nl_create_func_def_one_liner")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_create_func_def_one_liner = ' + self.option_nl_create_func_def_one_liner.currentText())
        if full or  'false'!=self.option_nl_create_list_one_liner.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to split one-line simple list definitions into three lines by\nadding newlines, as in 'int a[12] = { <here> 0 <here> };'.", "nl_create_list_one_liner")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_create_list_one_liner = ' + self.option_nl_create_list_one_liner.currentText())
        if full or  'false'!=self.option_nl_split_if_one_liner.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to split one-line simple unbraced if statements into two lines by\nadding a newline, as in 'if(b) <here> i++;'.", "nl_split_if_one_liner")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_split_if_one_liner = ' + self.option_nl_split_if_one_liner.currentText())
        if full or  'false'!=self.option_nl_split_for_one_liner.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to split one-line simple unbraced for statements into two lines by\nadding a newline, as in 'for (...) <here> stmt;'.", "nl_split_for_one_liner")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_split_for_one_liner = ' + self.option_nl_split_for_one_liner.currentText())
        if full or  'false'!=self.option_nl_split_while_one_liner.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to split one-line simple unbraced while statements into two lines by\nadding a newline, as in 'while (expr) <here> stmt;'.", "nl_split_while_one_liner")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_split_while_one_liner = ' + self.option_nl_split_while_one_liner.currentText())
        if full or  'false'!=self.option_donot_add_nl_before_cpp_comment.currentText():
            if comment:
                s.append(self.wrap(self.tr("Don't add a newline before a cpp-comment in a parameter list of a function\ncall.", "donot_add_nl_before_cpp_comment")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('donot_add_nl_before_cpp_comment = ' + self.option_donot_add_nl_before_cpp_comment.currentText())
        #================== Blank line options ==============================================================
        if full or  comment: s.append('\n\n'+'#'*80+self.wrap(self.tr("Blank line options"))+'\n'+'#'*80)
        if full or  0!=self.option_nl_max.value():
            if comment:
                s.append(self.wrap(self.tr("The maximum number of consecutive newlines (3 = 2 blank lines).", "nl_max")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_max = ' + str(self.option_nl_max.value()))
        if full or  0!=self.option_nl_max_blank_in_func.value():
            if comment:
                s.append(self.wrap(self.tr("The maximum number of consecutive newlines in a function.", "nl_max_blank_in_func")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_max_blank_in_func = ' + str(self.option_nl_max_blank_in_func.value()))
        if full or  0!=self.option_nl_inside_empty_func.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines inside an empty function body.\nThis option overrides eat_blanks_after_open_brace and\neat_blanks_before_close_brace, but is ignored when\nnl_collapse_empty_body_functions=true", "nl_inside_empty_func")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_inside_empty_func = ' + str(self.option_nl_inside_empty_func.value()))
        if full or  0!=self.option_nl_before_func_body_proto.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines before a function prototype.", "nl_before_func_body_proto")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_before_func_body_proto = ' + str(self.option_nl_before_func_body_proto.value()))
        if full or  0!=self.option_nl_before_func_body_def.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines before a multi-line function definition. Where\napplicable, this option is overridden with eat_blanks_after_open_brace=true", "nl_before_func_body_def")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_before_func_body_def = ' + str(self.option_nl_before_func_body_def.value()))
        if full or  0!=self.option_nl_before_func_class_proto.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines before a class constructor/destructor prototype.", "nl_before_func_class_proto")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_before_func_class_proto = ' + str(self.option_nl_before_func_class_proto.value()))
        if full or  0!=self.option_nl_before_func_class_def.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines before a class constructor/destructor definition.", "nl_before_func_class_def")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_before_func_class_def = ' + str(self.option_nl_before_func_class_def.value()))
        if full or  0!=self.option_nl_after_func_proto.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines after a function prototype.", "nl_after_func_proto")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_after_func_proto = ' + str(self.option_nl_after_func_proto.value()))
        if full or  0!=self.option_nl_after_func_proto_group.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines after a function prototype, if not followed by\nanother function prototype.", "nl_after_func_proto_group")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_after_func_proto_group = ' + str(self.option_nl_after_func_proto_group.value()))
        if full or  0!=self.option_nl_after_func_class_proto.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines after a class constructor/destructor prototype.", "nl_after_func_class_proto")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_after_func_class_proto = ' + str(self.option_nl_after_func_class_proto.value()))
        if full or  0!=self.option_nl_after_func_class_proto_group.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines after a class constructor/destructor prototype,\nif not followed by another constructor/destructor prototype.", "nl_after_func_class_proto_group")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_after_func_class_proto_group = ' + str(self.option_nl_after_func_class_proto_group.value()))
        if full or  'false'!=self.option_nl_class_leave_one_liner_groups.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether one-line method definitions inside a class body should be treated\nas if they were prototypes for the purposes of adding newlines.", "nl_class_leave_one_liner_groups"))+"\n#"+self.wrap(self.tr("Requires nl_class_leave_one_liners=true. Overrides nl_before_func_body_def\nand nl_before_func_class_def for one-liners.", "nl_class_leave_one_liner_groups")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_class_leave_one_liner_groups = ' + self.option_nl_class_leave_one_liner_groups.currentText())
        if full or  0!=self.option_nl_after_func_body.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines after '}' of a multi-line function body.", "nl_after_func_body"))+"\n#"+self.wrap(self.tr("Overrides nl_min_after_func_body and nl_max_after_func_body.", "nl_after_func_body")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_after_func_body = ' + str(self.option_nl_after_func_body.value()))
        if full or  0!=self.option_nl_min_after_func_body.value():
            if comment:
                s.append(self.wrap(self.tr("The minimum number of newlines after '}' of a multi-line function body.", "nl_min_after_func_body"))+"\n#"+self.wrap(self.tr("Only works when nl_after_func_body is 0.", "nl_min_after_func_body")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_min_after_func_body = ' + str(self.option_nl_min_after_func_body.value()))
        if full or  0!=self.option_nl_max_after_func_body.value():
            if comment:
                s.append(self.wrap(self.tr("The maximum number of newlines after '}' of a multi-line function body.", "nl_max_after_func_body"))+"\n#"+self.wrap(self.tr("Only works when nl_after_func_body is 0.\nTakes precedence over nl_min_after_func_body.", "nl_max_after_func_body")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_max_after_func_body = ' + str(self.option_nl_max_after_func_body.value()))
        if full or  0!=self.option_nl_after_func_body_class.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines after '}' of a multi-line function body in a class\ndeclaration. Also affects class constructors/destructors.", "nl_after_func_body_class"))+"\n#"+self.wrap(self.tr("Overrides nl_after_func_body.", "nl_after_func_body_class")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_after_func_body_class = ' + str(self.option_nl_after_func_body_class.value()))
        if full or  0!=self.option_nl_after_func_body_one_liner.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines after '}' of a single line function body. Also\naffects class constructors/destructors.", "nl_after_func_body_one_liner"))+"\n#"+self.wrap(self.tr("Overrides nl_after_func_body and nl_after_func_body_class.", "nl_after_func_body_one_liner")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_after_func_body_one_liner = ' + str(self.option_nl_after_func_body_one_liner.value()))
        if full or  0!=self.option_nl_typedef_blk_start.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines before a block of typedefs. If nl_after_access_spec\nis non-zero, that option takes precedence.", "nl_typedef_blk_start"))+"\n#"+self.wrap(self.tr("0: No change (default).", "nl_typedef_blk_start")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_typedef_blk_start = ' + str(self.option_nl_typedef_blk_start.value()))
        if full or  0!=self.option_nl_typedef_blk_end.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines after a block of typedefs.", "nl_typedef_blk_end"))+"\n#"+self.wrap(self.tr("0: No change (default).", "nl_typedef_blk_end")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_typedef_blk_end = ' + str(self.option_nl_typedef_blk_end.value()))
        if full or  0!=self.option_nl_typedef_blk_in.value():
            if comment:
                s.append(self.wrap(self.tr("The maximum number of consecutive newlines within a block of typedefs.", "nl_typedef_blk_in"))+"\n#"+self.wrap(self.tr("0: No change (default).", "nl_typedef_blk_in")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_typedef_blk_in = ' + str(self.option_nl_typedef_blk_in.value()))
        if full or  0!=self.option_nl_var_def_blk_end_func_top.value():
            if comment:
                s.append(self.wrap(self.tr("The minimum number of blank lines after a block of variable definitions\nat the top of a function body. If any preprocessor directives appear\nbetween the opening brace of the function and the variable block, then\nit is considered as not at the top of the function.Newlines are added\nbefore trailing preprocessor directives, if any exist.", "nl_var_def_blk_end_func_top"))+"\n#"+self.wrap(self.tr("0: No change (default).", "nl_var_def_blk_end_func_top")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_var_def_blk_end_func_top = ' + str(self.option_nl_var_def_blk_end_func_top.value()))
        if full or  0!=self.option_nl_var_def_blk_start.value():
            if comment:
                s.append(self.wrap(self.tr("The minimum number of empty newlines before a block of variable definitions\nnot at the top of a function body. If nl_after_access_spec is non-zero,\nthat option takes precedence. Newlines are not added at the top of the\nfile or just after an opening brace. Newlines are added above any\npreprocessor directives before the block.", "nl_var_def_blk_start"))+"\n#"+self.wrap(self.tr("0: No change (default).", "nl_var_def_blk_start")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_var_def_blk_start = ' + str(self.option_nl_var_def_blk_start.value()))
        if full or  0!=self.option_nl_var_def_blk_end.value():
            if comment:
                s.append(self.wrap(self.tr("The minimum number of empty newlines after a block of variable definitions\nnot at the top of a function body. Newlines are not added if the block\nis at the bottom of the file or just before a preprocessor directive.", "nl_var_def_blk_end"))+"\n#"+self.wrap(self.tr("0: No change (default).", "nl_var_def_blk_end")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_var_def_blk_end = ' + str(self.option_nl_var_def_blk_end.value()))
        if full or  0!=self.option_nl_var_def_blk_in.value():
            if comment:
                s.append(self.wrap(self.tr("The maximum number of consecutive newlines within a block of variable\ndefinitions.", "nl_var_def_blk_in"))+"\n#"+self.wrap(self.tr("0: No change (default).", "nl_var_def_blk_in")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_var_def_blk_in = ' + str(self.option_nl_var_def_blk_in.value()))
        if full or  0!=self.option_nl_before_block_comment.value():
            if comment:
                s.append(self.wrap(self.tr("The minimum number of newlines before a multi-line comment.\nDoesn't apply if after a brace open or another multi-line comment.", "nl_before_block_comment")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_before_block_comment = ' + str(self.option_nl_before_block_comment.value()))
        if full or  0!=self.option_nl_before_c_comment.value():
            if comment:
                s.append(self.wrap(self.tr("The minimum number of newlines before a single-line C comment.\nDoesn't apply if after a brace open or other single-line C comments.", "nl_before_c_comment")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_before_c_comment = ' + str(self.option_nl_before_c_comment.value()))
        if full or  0!=self.option_nl_before_cpp_comment.value():
            if comment:
                s.append(self.wrap(self.tr("The minimum number of newlines before a CPP comment.\nDoesn't apply if after a brace open or other CPP comments.", "nl_before_cpp_comment")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_before_cpp_comment = ' + str(self.option_nl_before_cpp_comment.value()))
        if full or  'false'!=self.option_nl_after_multiline_comment.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to force a newline after a multi-line comment.", "nl_after_multiline_comment")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_after_multiline_comment = ' + self.option_nl_after_multiline_comment.currentText())
        if full or  'false'!=self.option_nl_after_label_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to force a newline after a label's colon.", "nl_after_label_colon")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('nl_after_label_colon = ' + self.option_nl_after_label_colon.currentText())
        if full or  0!=self.option_nl_before_struct.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines before a struct definition.", "nl_before_struct")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_before_struct = ' + str(self.option_nl_before_struct.value()))
        if full or  0!=self.option_nl_after_struct.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines after '}' or ';' of a struct/enum/union definition.", "nl_after_struct")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_after_struct = ' + str(self.option_nl_after_struct.value()))
        if full or  0!=self.option_nl_before_class.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines before a class definition.", "nl_before_class")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_before_class = ' + str(self.option_nl_before_class.value()))
        if full or  0!=self.option_nl_after_class.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines after '}' or ';' of a class definition.", "nl_after_class")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_after_class = ' + str(self.option_nl_after_class.value()))
        if full or  0!=self.option_nl_before_namespace.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines before a namespace.", "nl_before_namespace")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_before_namespace = ' + str(self.option_nl_before_namespace.value()))
        if full or  0!=self.option_nl_inside_namespace.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines after '{' of a namespace. This also adds newlines\nbefore the matching '}'.", "nl_inside_namespace"))+"\n#"+self.wrap(self.tr("0: Apply eat_blanks_after_open_brace or eat_blanks_before_close_brace if\n    applicable, otherwise no change.", "nl_inside_namespace"))+"\n#"+self.wrap(self.tr("Overrides eat_blanks_after_open_brace and eat_blanks_before_close_brace.", "nl_inside_namespace")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_inside_namespace = ' + str(self.option_nl_inside_namespace.value()))
        if full or  0!=self.option_nl_after_namespace.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines after '}' of a namespace.", "nl_after_namespace")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_after_namespace = ' + str(self.option_nl_after_namespace.value()))
        if full or  0!=self.option_nl_before_access_spec.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines before an access specifier label. This also includes\nthe Qt-specific 'signals:' and 'slots:'. Will not change the newline count\nif after a brace open.", "nl_before_access_spec"))+"\n#"+self.wrap(self.tr("0: No change (default).", "nl_before_access_spec")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_before_access_spec = ' + str(self.option_nl_before_access_spec.value()))
        if full or  0!=self.option_nl_after_access_spec.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines after an access specifier label. This also includes\nthe Qt-specific 'signals:' and 'slots:'. Will not change the newline count\nif after a brace open.", "nl_after_access_spec"))+"\n#"+self.wrap(self.tr("0: No change (default).", "nl_after_access_spec"))+"\n#"+self.wrap(self.tr("Overrides nl_typedef_blk_start and nl_var_def_blk_start.", "nl_after_access_spec")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_after_access_spec = ' + str(self.option_nl_after_access_spec.value()))
        if full or  0!=self.option_nl_comment_func_def.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines between a function definition and the function\ncomment, as in '// comment\\n <here> void foo() {...}'.", "nl_comment_func_def"))+"\n#"+self.wrap(self.tr("0: No change (default).", "nl_comment_func_def")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_comment_func_def = ' + str(self.option_nl_comment_func_def.value()))
        if full or  0!=self.option_nl_after_try_catch_finally.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines after a try-catch-finally block that isn't followed\nby a brace close.", "nl_after_try_catch_finally"))+"\n#"+self.wrap(self.tr("0: No change (default).", "nl_after_try_catch_finally")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_after_try_catch_finally = ' + str(self.option_nl_after_try_catch_finally.value()))
        if full or  0!=self.option_nl_around_cs_property.value():
            if comment:
                s.append(self.wrap(self.tr("(C#) The number of newlines before and after a property, indexer or event\ndeclaration.", "nl_around_cs_property"))+"\n#"+self.wrap(self.tr("0: No change (default).", "nl_around_cs_property")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_around_cs_property = ' + str(self.option_nl_around_cs_property.value()))
        if full or  0!=self.option_nl_between_get_set.value():
            if comment:
                s.append(self.wrap(self.tr("(C#) The number of newlines between the get/set/add/remove handlers.", "nl_between_get_set"))+"\n#"+self.wrap(self.tr("0: No change (default).", "nl_between_get_set")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_between_get_set = ' + str(self.option_nl_between_get_set.value()))
        if full or  'ignore'!=self.option_nl_property_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("(C#) Add or remove newline between property and the '{'.", "nl_property_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_property_brace = ' + self.option_nl_property_brace.currentText())
        if full or  'false'!=self.option_eat_blanks_after_open_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to remove blank lines after '{'.", "eat_blanks_after_open_brace")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('eat_blanks_after_open_brace = ' + self.option_eat_blanks_after_open_brace.currentText())
        if full or  'false'!=self.option_eat_blanks_before_close_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to remove blank lines before '}'.", "eat_blanks_before_close_brace")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('eat_blanks_before_close_brace = ' + self.option_eat_blanks_before_close_brace.currentText())
        if full or  0!=self.option_nl_remove_extra_newlines.value():
            if comment:
                s.append(self.wrap(self.tr("How aggressively to remove extra newlines not in preprocessor.", "nl_remove_extra_newlines"))+"\n#"+self.wrap(self.tr("0: No change (default)\n1: Remove most newlines not handled by other config\n2: Remove all newlines and reformat completely by config", "nl_remove_extra_newlines")))
                s.append("#\n# Type: unsigned  0  2")
                s.append("# Default: 0 ")
            s.append('nl_remove_extra_newlines = ' + str(self.option_nl_remove_extra_newlines.value()))
        if full or  'ignore'!=self.option_nl_after_annotation.currentText():
            if comment:
                s.append(self.wrap(self.tr("(Java) Add or remove newline after an annotation statement. Only affects\nannotations that are after a newline.", "nl_after_annotation")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_after_annotation = ' + self.option_nl_after_annotation.currentText())
        if full or  'ignore'!=self.option_nl_between_annotation.currentText():
            if comment:
                s.append(self.wrap(self.tr("(Java) Add or remove newline between two annotations.", "nl_between_annotation")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('nl_between_annotation = ' + self.option_nl_between_annotation.currentText())
        if full or  0!=self.option_nl_before_whole_file_ifdef.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines before a whole-file #ifdef.", "nl_before_whole_file_ifdef"))+"\n#"+self.wrap(self.tr("0: No change (default).", "nl_before_whole_file_ifdef")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_before_whole_file_ifdef = ' + str(self.option_nl_before_whole_file_ifdef.value()))
        if full or  0!=self.option_nl_after_whole_file_ifdef.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines after a whole-file #ifdef.", "nl_after_whole_file_ifdef"))+"\n#"+self.wrap(self.tr("0: No change (default).", "nl_after_whole_file_ifdef")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_after_whole_file_ifdef = ' + str(self.option_nl_after_whole_file_ifdef.value()))
        if full or  0!=self.option_nl_before_whole_file_endif.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines before a whole-file #endif.", "nl_before_whole_file_endif"))+"\n#"+self.wrap(self.tr("0: No change (default).", "nl_before_whole_file_endif")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_before_whole_file_endif = ' + str(self.option_nl_before_whole_file_endif.value()))
        if full or  0!=self.option_nl_after_whole_file_endif.value():
            if comment:
                s.append(self.wrap(self.tr("The number of newlines after a whole-file #endif.", "nl_after_whole_file_endif"))+"\n#"+self.wrap(self.tr("0: No change (default).", "nl_after_whole_file_endif")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('nl_after_whole_file_endif = ' + str(self.option_nl_after_whole_file_endif.value()))
        #================== Positioning options =============================================================
        if full or  comment: s.append('\n\n'+'#'*80+self.wrap(self.tr("Positioning options"))+'\n'+'#'*80)
        if full or  'ignore'!=self.option_pos_arith.currentText():
            if comment:
                s.append(self.wrap(self.tr("The position of arithmetic operators in wrapped expressions.", "pos_arith")))
                s.append("#\n# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force")
                s.append("# Default: ignore ")
            s.append('pos_arith = ' + self.option_pos_arith.currentText())
        if full or  'ignore'!=self.option_pos_assign.currentText():
            if comment:
                s.append(self.wrap(self.tr("The position of assignment in wrapped expressions. Do not affect '='\nfollowed by '{'.", "pos_assign")))
                s.append("#\n# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force")
                s.append("# Default: ignore ")
            s.append('pos_assign = ' + self.option_pos_assign.currentText())
        if full or  'ignore'!=self.option_pos_bool.currentText():
            if comment:
                s.append(self.wrap(self.tr("The position of Boolean operators in wrapped expressions.", "pos_bool")))
                s.append("#\n# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force")
                s.append("# Default: ignore ")
            s.append('pos_bool = ' + self.option_pos_bool.currentText())
        if full or  'ignore'!=self.option_pos_compare.currentText():
            if comment:
                s.append(self.wrap(self.tr("The position of comparison operators in wrapped expressions.", "pos_compare")))
                s.append("#\n# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force")
                s.append("# Default: ignore ")
            s.append('pos_compare = ' + self.option_pos_compare.currentText())
        if full or  'ignore'!=self.option_pos_conditional.currentText():
            if comment:
                s.append(self.wrap(self.tr("The position of conditional operators, as in the '?' and ':' of\n'expr ? stmt : stmt', in wrapped expressions.", "pos_conditional")))
                s.append("#\n# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force")
                s.append("# Default: ignore ")
            s.append('pos_conditional = ' + self.option_pos_conditional.currentText())
        if full or  'ignore'!=self.option_pos_comma.currentText():
            if comment:
                s.append(self.wrap(self.tr("The position of the comma in wrapped expressions.", "pos_comma")))
                s.append("#\n# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force")
                s.append("# Default: ignore ")
            s.append('pos_comma = ' + self.option_pos_comma.currentText())
        if full or  'ignore'!=self.option_pos_enum_comma.currentText():
            if comment:
                s.append(self.wrap(self.tr("The position of the comma in enum entries.", "pos_enum_comma")))
                s.append("#\n# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force")
                s.append("# Default: ignore ")
            s.append('pos_enum_comma = ' + self.option_pos_enum_comma.currentText())
        if full or  'ignore'!=self.option_pos_class_comma.currentText():
            if comment:
                s.append(self.wrap(self.tr("The position of the comma in the base class list if there is more than one\nline. Affects nl_class_init_args.", "pos_class_comma")))
                s.append("#\n# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force")
                s.append("# Default: ignore ")
            s.append('pos_class_comma = ' + self.option_pos_class_comma.currentText())
        if full or  'ignore'!=self.option_pos_constr_comma.currentText():
            if comment:
                s.append(self.wrap(self.tr("The position of the comma in the constructor initialization list.\nRelated to nl_constr_colon, nl_constr_init_args and pos_constr_colon.", "pos_constr_comma")))
                s.append("#\n# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force")
                s.append("# Default: ignore ")
            s.append('pos_constr_comma = ' + self.option_pos_constr_comma.currentText())
        if full or  'ignore'!=self.option_pos_class_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("The position of trailing/leading class colon, between class and base class\nlist. Affects nl_class_colon.", "pos_class_colon")))
                s.append("#\n# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force")
                s.append("# Default: ignore ")
            s.append('pos_class_colon = ' + self.option_pos_class_colon.currentText())
        if full or  'ignore'!=self.option_pos_constr_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("The position of colons between constructor and member initialization.\nRelated to nl_constr_colon, nl_constr_init_args and pos_constr_comma.", "pos_constr_colon")))
                s.append("#\n# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force")
                s.append("# Default: ignore ")
            s.append('pos_constr_colon = ' + self.option_pos_constr_colon.currentText())
        if full or  'ignore'!=self.option_pos_shift.currentText():
            if comment:
                s.append(self.wrap(self.tr("The position of shift operators in wrapped expressions.", "pos_shift")))
                s.append("#\n# Type: ignore/break/force/lead/trail/join/lead_break/lead_force/trail_break/trail_force")
                s.append("# Default: ignore ")
            s.append('pos_shift = ' + self.option_pos_shift.currentText())
        #================== Line splitting options ==========================================================
        if full or  comment: s.append('\n\n'+'#'*80+self.wrap(self.tr("Line splitting options"))+'\n'+'#'*80)
        if full or  0!=self.option_code_width.value():
            if comment:
                s.append(self.wrap(self.tr("Try to limit code width to N columns.", "code_width")))
                s.append("#\n# Type: unsigned  0  10000")
                s.append("# Default: 0 ")
            s.append('code_width = ' + str(self.option_code_width.value()))
        if full or  'false'!=self.option_ls_for_split_full.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to fully split long 'for' statements at semi-colons.", "ls_for_split_full")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('ls_for_split_full = ' + self.option_ls_for_split_full.currentText())
        if full or  'false'!=self.option_ls_func_split_full.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to fully split long function prototypes/calls at commas.\nThe option ls_code_width has priority over the option ls_func_split_full.", "ls_func_split_full")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('ls_func_split_full = ' + self.option_ls_func_split_full.currentText())
        if full or  'false'!=self.option_ls_code_width.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to split lines as close to code_width as possible and ignore some\ngroupings.\nThe option ls_code_width has priority over the option ls_func_split_full.", "ls_code_width")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('ls_code_width = ' + self.option_ls_code_width.currentText())
        #================== Code alignment options (not left column spaces/tabs) ============================
        if full or  comment: s.append('\n\n'+'#'*80+self.wrap(self.tr("Code alignment options (not left column spaces/tabs)"))+'\n'+'#'*80)
        if full or  'false'!=self.option_align_keep_tabs.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to keep non-indenting tabs.", "align_keep_tabs")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_keep_tabs = ' + self.option_align_keep_tabs.currentText())
        if full or  'false'!=self.option_align_with_tabs.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to use tabs for aligning.", "align_with_tabs")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_with_tabs = ' + self.option_align_with_tabs.currentText())
        if full or  'false'!=self.option_align_on_tabstop.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to bump out to the next tab when aligning.", "align_on_tabstop")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_on_tabstop = ' + self.option_align_on_tabstop.currentText())
        if full or  'false'!=self.option_align_number_right.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to right-align numbers.", "align_number_right")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_number_right = ' + self.option_align_number_right.currentText())
        if full or  'false'!=self.option_align_keep_extra_space.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to keep whitespace not required for alignment.", "align_keep_extra_space")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_keep_extra_space = ' + self.option_align_keep_extra_space.currentText())
        if full or  'false'!=self.option_align_func_params.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to align variable definitions in prototypes and functions.", "align_func_params")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_func_params = ' + self.option_align_func_params.currentText())
        if full or  0!=self.option_align_func_params_span.value():
            if comment:
                s.append(self.wrap(self.tr("The span for aligning parameter definitions in function on parameter name.", "align_func_params_span"))+"\n#"+self.wrap(self.tr("0: Don't align (default).", "align_func_params_span")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('align_func_params_span = ' + str(self.option_align_func_params_span.value()))
        if full or  0!=self.option_align_func_params_thresh.value():
            if comment:
                s.append(self.wrap(self.tr("The threshold for aligning function parameter definitions.\nUse a negative number for absolute thresholds.", "align_func_params_thresh"))+"\n#"+self.wrap(self.tr("0: No limit (default).", "align_func_params_thresh")))
                s.append("#\n# Type: signed  -1000  5000")
                s.append("# Default: 0 ")
            s.append('align_func_params_thresh = ' + str(self.option_align_func_params_thresh.value()))
        if full or  0!=self.option_align_func_params_gap.value():
            if comment:
                s.append(self.wrap(self.tr("The gap for aligning function parameter definitions.", "align_func_params_gap")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('align_func_params_gap = ' + str(self.option_align_func_params_gap.value()))
        if full or  0!=self.option_align_constr_value_span.value():
            if comment:
                s.append(self.wrap(self.tr("The span for aligning constructor value.", "align_constr_value_span"))+"\n#"+self.wrap(self.tr("0: Don't align (default).", "align_constr_value_span")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('align_constr_value_span = ' + str(self.option_align_constr_value_span.value()))
        if full or  0!=self.option_align_constr_value_thresh.value():
            if comment:
                s.append(self.wrap(self.tr("The threshold for aligning constructor value.\nUse a negative number for absolute thresholds.", "align_constr_value_thresh"))+"\n#"+self.wrap(self.tr("0: No limit (default).", "align_constr_value_thresh")))
                s.append("#\n# Type: signed  -1000  5000")
                s.append("# Default: 0 ")
            s.append('align_constr_value_thresh = ' + str(self.option_align_constr_value_thresh.value()))
        if full or  0!=self.option_align_constr_value_gap.value():
            if comment:
                s.append(self.wrap(self.tr("The gap for aligning constructor value.", "align_constr_value_gap")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('align_constr_value_gap = ' + str(self.option_align_constr_value_gap.value()))
        if full or  'false'!=self.option_align_same_func_call_params.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to align parameters in single-line functions that have the same\nname. The function names must already be aligned with each other.", "align_same_func_call_params")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_same_func_call_params = ' + self.option_align_same_func_call_params.currentText())
        if full or  0!=self.option_align_same_func_call_params_span.value():
            if comment:
                s.append(self.wrap(self.tr("The span for aligning function-call parameters for single line functions.", "align_same_func_call_params_span"))+"\n#"+self.wrap(self.tr("0: Don't align (default).", "align_same_func_call_params_span")))
                s.append("#\n# Type: unsigned  0  5000")
                s.append("# Default: 0 ")
            s.append('align_same_func_call_params_span = ' + str(self.option_align_same_func_call_params_span.value()))
        if full or  0!=self.option_align_same_func_call_params_thresh.value():
            if comment:
                s.append(self.wrap(self.tr("The threshold for aligning function-call parameters for single line\nfunctions.\nUse a negative number for absolute thresholds.", "align_same_func_call_params_thresh"))+"\n#"+self.wrap(self.tr("0: No limit (default).", "align_same_func_call_params_thresh")))
                s.append("#\n# Type: signed  -1000  5000")
                s.append("# Default: 0 ")
            s.append('align_same_func_call_params_thresh = ' + str(self.option_align_same_func_call_params_thresh.value()))
        if full or  0!=self.option_align_var_def_span.value():
            if comment:
                s.append(self.wrap(self.tr("The span for aligning variable definitions.", "align_var_def_span"))+"\n#"+self.wrap(self.tr("0: Don't align (default).", "align_var_def_span")))
                s.append("#\n# Type: unsigned  0  5000")
                s.append("# Default: 0 ")
            s.append('align_var_def_span = ' + str(self.option_align_var_def_span.value()))
        if full or  0!=self.option_align_var_def_star_style.value():
            if comment:
                s.append(self.wrap(self.tr("How to consider (or treat) the '*' in the alignment of variable definitions.", "align_var_def_star_style"))+"\n#"+self.wrap(self.tr("0: Part of the type     'void *   foo;' (default)\n1: Part of the variable 'void     *foo;'\n2: Dangling             'void    *foo;'\nDangling: the '*' will not be taken into account when aligning.", "align_var_def_star_style")))
                s.append("#\n# Type: unsigned  0  2")
                s.append("# Default: 0 ")
            s.append('align_var_def_star_style = ' + str(self.option_align_var_def_star_style.value()))
        if full or  0!=self.option_align_var_def_amp_style.value():
            if comment:
                s.append(self.wrap(self.tr("How to consider (or treat) the '&' in the alignment of variable definitions.", "align_var_def_amp_style"))+"\n#"+self.wrap(self.tr("0: Part of the type     'long &   foo;' (default)\n1: Part of the variable 'long     &foo;'\n2: Dangling             'long    &foo;'\nDangling: the '&' will not be taken into account when aligning.", "align_var_def_amp_style")))
                s.append("#\n# Type: unsigned  0  2")
                s.append("# Default: 0 ")
            s.append('align_var_def_amp_style = ' + str(self.option_align_var_def_amp_style.value()))
        if full or  0!=self.option_align_var_def_thresh.value():
            if comment:
                s.append(self.wrap(self.tr("The threshold for aligning variable definitions.\nUse a negative number for absolute thresholds.", "align_var_def_thresh"))+"\n#"+self.wrap(self.tr("0: No limit (default).", "align_var_def_thresh")))
                s.append("#\n# Type: signed  -1000  5000")
                s.append("# Default: 0 ")
            s.append('align_var_def_thresh = ' + str(self.option_align_var_def_thresh.value()))
        if full or  0!=self.option_align_var_def_gap.value():
            if comment:
                s.append(self.wrap(self.tr("The gap for aligning variable definitions.", "align_var_def_gap")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('align_var_def_gap = ' + str(self.option_align_var_def_gap.value()))
        if full or  'false'!=self.option_align_var_def_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to align the colon in struct bit fields.", "align_var_def_colon")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_var_def_colon = ' + self.option_align_var_def_colon.currentText())
        if full or  0!=self.option_align_var_def_colon_gap.value():
            if comment:
                s.append(self.wrap(self.tr("The gap for aligning the colon in struct bit fields.", "align_var_def_colon_gap")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('align_var_def_colon_gap = ' + str(self.option_align_var_def_colon_gap.value()))
        if full or  'false'!=self.option_align_var_def_attribute.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to align any attribute after the variable name.", "align_var_def_attribute")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_var_def_attribute = ' + self.option_align_var_def_attribute.currentText())
        if full or  'false'!=self.option_align_var_def_inline.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to align inline struct/enum/union variable definitions.", "align_var_def_inline")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_var_def_inline = ' + self.option_align_var_def_inline.currentText())
        if full or  0!=self.option_align_assign_span.value():
            if comment:
                s.append(self.wrap(self.tr("The span for aligning on '=' in assignments.", "align_assign_span"))+"\n#"+self.wrap(self.tr("0: Don't align (default).", "align_assign_span")))
                s.append("#\n# Type: unsigned  0  5000")
                s.append("# Default: 0 ")
            s.append('align_assign_span = ' + str(self.option_align_assign_span.value()))
        if full or  0!=self.option_align_assign_func_proto_span.value():
            if comment:
                s.append(self.wrap(self.tr("The span for aligning on '=' in function prototype modifier.", "align_assign_func_proto_span"))+"\n#"+self.wrap(self.tr("0: Don't align (default).", "align_assign_func_proto_span")))
                s.append("#\n# Type: unsigned  0  5000")
                s.append("# Default: 0 ")
            s.append('align_assign_func_proto_span = ' + str(self.option_align_assign_func_proto_span.value()))
        if full or  0!=self.option_align_assign_thresh.value():
            if comment:
                s.append(self.wrap(self.tr("The threshold for aligning on '=' in assignments.\nUse a negative number for absolute thresholds.", "align_assign_thresh"))+"\n#"+self.wrap(self.tr("0: No limit (default).", "align_assign_thresh")))
                s.append("#\n# Type: signed  -1000  5000")
                s.append("# Default: 0 ")
            s.append('align_assign_thresh = ' + str(self.option_align_assign_thresh.value()))
        if full or  'false'!=self.option_align_assign_on_multi_var_defs.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to align on the left most assignment when multiple\ndefinitions are found on the same line.\nDepends on 'align_assign_span' and 'align_assign_thresh' settings.", "align_assign_on_multi_var_defs")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_assign_on_multi_var_defs = ' + self.option_align_assign_on_multi_var_defs.currentText())
        if full or  0!=self.option_align_braced_init_list_span.value():
            if comment:
                s.append(self.wrap(self.tr("The span for aligning on '{' in braced init list.", "align_braced_init_list_span"))+"\n#"+self.wrap(self.tr("0: Don't align (default).", "align_braced_init_list_span")))
                s.append("#\n# Type: unsigned  0  5000")
                s.append("# Default: 0 ")
            s.append('align_braced_init_list_span = ' + str(self.option_align_braced_init_list_span.value()))
        if full or  0!=self.option_align_braced_init_list_thresh.value():
            if comment:
                s.append(self.wrap(self.tr("The threshold for aligning on '{' in braced init list.\nUse a negative number for absolute thresholds.", "align_braced_init_list_thresh"))+"\n#"+self.wrap(self.tr("0: No limit (default).", "align_braced_init_list_thresh")))
                s.append("#\n# Type: signed  -1000  5000")
                s.append("# Default: 0 ")
            s.append('align_braced_init_list_thresh = ' + str(self.option_align_braced_init_list_thresh.value()))
        if full or  0!=self.option_align_assign_decl_func.value():
            if comment:
                s.append(self.wrap(self.tr("How to apply align_assign_span to function declaration \"assignments\", i.e.\n'virtual void foo() = 0' or '~foo() = {default|delete}'.", "align_assign_decl_func"))+"\n#"+self.wrap(self.tr("0: Align with other assignments (default)\n1: Align with each other, ignoring regular assignments\n2: Don't align", "align_assign_decl_func")))
                s.append("#\n# Type: unsigned  0  2")
                s.append("# Default: 0 ")
            s.append('align_assign_decl_func = ' + str(self.option_align_assign_decl_func.value()))
        if full or  0!=self.option_align_enum_equ_span.value():
            if comment:
                s.append(self.wrap(self.tr("The span for aligning on '=' in enums.", "align_enum_equ_span"))+"\n#"+self.wrap(self.tr("0: Don't align (default).", "align_enum_equ_span")))
                s.append("#\n# Type: unsigned  0  5000")
                s.append("# Default: 0 ")
            s.append('align_enum_equ_span = ' + str(self.option_align_enum_equ_span.value()))
        if full or  0!=self.option_align_enum_equ_thresh.value():
            if comment:
                s.append(self.wrap(self.tr("The threshold for aligning on '=' in enums.\nUse a negative number for absolute thresholds.", "align_enum_equ_thresh"))+"\n#"+self.wrap(self.tr("0: no limit (default).", "align_enum_equ_thresh")))
                s.append("#\n# Type: signed  -1000  5000")
                s.append("# Default: 0 ")
            s.append('align_enum_equ_thresh = ' + str(self.option_align_enum_equ_thresh.value()))
        if full or  0!=self.option_align_var_class_span.value():
            if comment:
                s.append(self.wrap(self.tr("The span for aligning class member definitions.", "align_var_class_span"))+"\n#"+self.wrap(self.tr("0: Don't align (default).", "align_var_class_span")))
                s.append("#\n# Type: unsigned  0  5000")
                s.append("# Default: 0 ")
            s.append('align_var_class_span = ' + str(self.option_align_var_class_span.value()))
        if full or  0!=self.option_align_var_class_thresh.value():
            if comment:
                s.append(self.wrap(self.tr("The threshold for aligning class member definitions.\nUse a negative number for absolute thresholds.", "align_var_class_thresh"))+"\n#"+self.wrap(self.tr("0: No limit (default).", "align_var_class_thresh")))
                s.append("#\n# Type: signed  -1000  5000")
                s.append("# Default: 0 ")
            s.append('align_var_class_thresh = ' + str(self.option_align_var_class_thresh.value()))
        if full or  0!=self.option_align_var_class_gap.value():
            if comment:
                s.append(self.wrap(self.tr("The gap for aligning class member definitions.", "align_var_class_gap")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('align_var_class_gap = ' + str(self.option_align_var_class_gap.value()))
        if full or  0!=self.option_align_var_struct_span.value():
            if comment:
                s.append(self.wrap(self.tr("The span for aligning struct/union member definitions.", "align_var_struct_span"))+"\n#"+self.wrap(self.tr("0: Don't align (default).", "align_var_struct_span")))
                s.append("#\n# Type: unsigned  0  5000")
                s.append("# Default: 0 ")
            s.append('align_var_struct_span = ' + str(self.option_align_var_struct_span.value()))
        if full or  0!=self.option_align_var_struct_thresh.value():
            if comment:
                s.append(self.wrap(self.tr("The threshold for aligning struct/union member definitions.\nUse a negative number for absolute thresholds.", "align_var_struct_thresh"))+"\n#"+self.wrap(self.tr("0: No limit (default).", "align_var_struct_thresh")))
                s.append("#\n# Type: signed  -1000  5000")
                s.append("# Default: 0 ")
            s.append('align_var_struct_thresh = ' + str(self.option_align_var_struct_thresh.value()))
        if full or  0!=self.option_align_var_struct_gap.value():
            if comment:
                s.append(self.wrap(self.tr("The gap for aligning struct/union member definitions.", "align_var_struct_gap")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('align_var_struct_gap = ' + str(self.option_align_var_struct_gap.value()))
        if full or  0!=self.option_align_struct_init_span.value():
            if comment:
                s.append(self.wrap(self.tr("The span for aligning struct initializer values.", "align_struct_init_span"))+"\n#"+self.wrap(self.tr("0: Don't align (default).", "align_struct_init_span")))
                s.append("#\n# Type: unsigned  0  5000")
                s.append("# Default: 0 ")
            s.append('align_struct_init_span = ' + str(self.option_align_struct_init_span.value()))
        if full or  0!=self.option_align_typedef_span.value():
            if comment:
                s.append(self.wrap(self.tr("The span for aligning single-line typedefs.", "align_typedef_span"))+"\n#"+self.wrap(self.tr("0: Don't align (default).", "align_typedef_span")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('align_typedef_span = ' + str(self.option_align_typedef_span.value()))
        if full or  0!=self.option_align_typedef_gap.value():
            if comment:
                s.append(self.wrap(self.tr("The minimum space between the type and the synonym of a typedef.", "align_typedef_gap")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('align_typedef_gap = ' + str(self.option_align_typedef_gap.value()))
        if full or  0!=self.option_align_typedef_func.value():
            if comment:
                s.append(self.wrap(self.tr("How to align typedef'd functions with other typedefs.", "align_typedef_func"))+"\n#"+self.wrap(self.tr("0: Don't mix them at all (default)\n1: Align the open parenthesis with the types\n2: Align the function type name with the other type names", "align_typedef_func")))
                s.append("#\n# Type: unsigned  0  2")
                s.append("# Default: 0 ")
            s.append('align_typedef_func = ' + str(self.option_align_typedef_func.value()))
        if full or  0!=self.option_align_typedef_star_style.value():
            if comment:
                s.append(self.wrap(self.tr("How to consider (or treat) the '*' in the alignment of typedefs.", "align_typedef_star_style"))+"\n#"+self.wrap(self.tr("0: Part of the typedef type, 'typedef int * pint;' (default)\n1: Part of type name:        'typedef int   *pint;'\n2: Dangling:                 'typedef int  *pint;'\nDangling: the '*' will not be taken into account when aligning.", "align_typedef_star_style")))
                s.append("#\n# Type: unsigned  0  2")
                s.append("# Default: 0 ")
            s.append('align_typedef_star_style = ' + str(self.option_align_typedef_star_style.value()))
        if full or  0!=self.option_align_typedef_amp_style.value():
            if comment:
                s.append(self.wrap(self.tr("How to consider (or treat) the '&' in the alignment of typedefs.", "align_typedef_amp_style"))+"\n#"+self.wrap(self.tr("0: Part of the typedef type, 'typedef int & intref;' (default)\n1: Part of type name:        'typedef int   &intref;'\n2: Dangling:                 'typedef int  &intref;'\nDangling: the '&' will not be taken into account when aligning.", "align_typedef_amp_style")))
                s.append("#\n# Type: unsigned  0  2")
                s.append("# Default: 0 ")
            s.append('align_typedef_amp_style = ' + str(self.option_align_typedef_amp_style.value()))
        if full or  0!=self.option_align_right_cmt_span.value():
            if comment:
                s.append(self.wrap(self.tr("The span for aligning comments that end lines.", "align_right_cmt_span"))+"\n#"+self.wrap(self.tr("0: Don't align (default).", "align_right_cmt_span")))
                s.append("#\n# Type: unsigned  0  5000")
                s.append("# Default: 0 ")
            s.append('align_right_cmt_span = ' + str(self.option_align_right_cmt_span.value()))
        if full or  0!=self.option_align_right_cmt_gap.value():
            if comment:
                s.append(self.wrap(self.tr("Minimum number of columns between preceding text and a trailing comment in\norder for the comment to qualify for being aligned. Must be non-zero to have\nan effect.", "align_right_cmt_gap")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('align_right_cmt_gap = ' + str(self.option_align_right_cmt_gap.value()))
        if full or  'false'!=self.option_align_right_cmt_mix.currentText():
            if comment:
                s.append(self.wrap(self.tr("If aligning comments, whether to mix with comments after '}' and #endif with\nless than three spaces before the comment.", "align_right_cmt_mix")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_right_cmt_mix = ' + self.option_align_right_cmt_mix.currentText())
        if full or  'false'!=self.option_align_right_cmt_same_level.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to only align trailing comments that are at the same brace level.", "align_right_cmt_same_level")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_right_cmt_same_level = ' + self.option_align_right_cmt_same_level.currentText())
        if full or  0!=self.option_align_right_cmt_at_col.value():
            if comment:
                s.append(self.wrap(self.tr("Minimum column at which to align trailing comments. Comments which are\naligned beyond this column, but which can be aligned in a lesser column,\nmay be \"pulled in\".", "align_right_cmt_at_col"))+"\n#"+self.wrap(self.tr("0: Ignore (default).", "align_right_cmt_at_col")))
                s.append("#\n# Type: unsigned  0  200")
                s.append("# Default: 0 ")
            s.append('align_right_cmt_at_col = ' + str(self.option_align_right_cmt_at_col.value()))
        if full or  0!=self.option_align_func_proto_span.value():
            if comment:
                s.append(self.wrap(self.tr("The span for aligning function prototypes.", "align_func_proto_span"))+"\n#"+self.wrap(self.tr("0: Don't align (default).", "align_func_proto_span")))
                s.append("#\n# Type: unsigned  0  5000")
                s.append("# Default: 0 ")
            s.append('align_func_proto_span = ' + str(self.option_align_func_proto_span.value()))
        if full or  'false'!=self.option_align_func_proto_span_ignore_cont_lines.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to ignore continuation lines when evaluating the number of\nnew lines for the function prototype alignment's span.", "align_func_proto_span_ignore_cont_lines"))+"\n#"+self.wrap(self.tr("false: continuation lines are part of the newlines count\ntrue:  continuation lines are not counted", "align_func_proto_span_ignore_cont_lines")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_func_proto_span_ignore_cont_lines = ' + self.option_align_func_proto_span_ignore_cont_lines.currentText())
        if full or  0!=self.option_align_func_proto_star_style.value():
            if comment:
                s.append(self.wrap(self.tr("How to consider (or treat) the '*' in the alignment of function prototypes.", "align_func_proto_star_style"))+"\n#"+self.wrap(self.tr("0: Part of the type     'void *   foo();' (default)\n1: Part of the function 'void     *foo();'\n2: Dangling             'void    *foo();'\nDangling: the '*' will not be taken into account when aligning.", "align_func_proto_star_style")))
                s.append("#\n# Type: unsigned  0  2")
                s.append("# Default: 0 ")
            s.append('align_func_proto_star_style = ' + str(self.option_align_func_proto_star_style.value()))
        if full or  0!=self.option_align_func_proto_amp_style.value():
            if comment:
                s.append(self.wrap(self.tr("How to consider (or treat) the '&' in the alignment of function prototypes.", "align_func_proto_amp_style"))+"\n#"+self.wrap(self.tr("0: Part of the type     'long &   foo();' (default)\n1: Part of the function 'long     &foo();'\n2: Dangling             'long    &foo();'\nDangling: the '&' will not be taken into account when aligning.", "align_func_proto_amp_style")))
                s.append("#\n# Type: unsigned  0  2")
                s.append("# Default: 0 ")
            s.append('align_func_proto_amp_style = ' + str(self.option_align_func_proto_amp_style.value()))
        if full or  0!=self.option_align_func_proto_thresh.value():
            if comment:
                s.append(self.wrap(self.tr("The threshold for aligning function prototypes.\nUse a negative number for absolute thresholds.", "align_func_proto_thresh"))+"\n#"+self.wrap(self.tr("0: No limit (default).", "align_func_proto_thresh")))
                s.append("#\n# Type: signed  -1000  5000")
                s.append("# Default: 0 ")
            s.append('align_func_proto_thresh = ' + str(self.option_align_func_proto_thresh.value()))
        if full or  0!=self.option_align_func_proto_gap.value():
            if comment:
                s.append(self.wrap(self.tr("Minimum gap between the return type and the function name.", "align_func_proto_gap")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('align_func_proto_gap = ' + str(self.option_align_func_proto_gap.value()))
        if full or  'false'!=self.option_align_on_operator.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to align function prototypes on the 'operator' keyword instead of\nwhat follows.", "align_on_operator")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_on_operator = ' + self.option_align_on_operator.currentText())
        if full or  'false'!=self.option_align_mix_var_proto.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to mix aligning prototype and variable declarations. If true,\nalign_var_def_XXX options are used instead of align_func_proto_XXX options.", "align_mix_var_proto")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_mix_var_proto = ' + self.option_align_mix_var_proto.currentText())
        if full or  'false'!=self.option_align_single_line_func.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to align single-line functions with function prototypes.\nUses align_func_proto_span.", "align_single_line_func")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_single_line_func = ' + self.option_align_single_line_func.currentText())
        if full or  'false'!=self.option_align_single_line_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to align the open brace of single-line functions.\nRequires align_single_line_func=true. Uses align_func_proto_span.", "align_single_line_brace")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_single_line_brace = ' + self.option_align_single_line_brace.currentText())
        if full or  0!=self.option_align_single_line_brace_gap.value():
            if comment:
                s.append(self.wrap(self.tr("Gap for align_single_line_brace.", "align_single_line_brace_gap")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('align_single_line_brace_gap = ' + str(self.option_align_single_line_brace_gap.value()))
        if full or  0!=self.option_align_oc_msg_spec_span.value():
            if comment:
                s.append(self.wrap(self.tr("(OC) The span for aligning Objective-C message specifications.", "align_oc_msg_spec_span"))+"\n#"+self.wrap(self.tr("0: Don't align (default).", "align_oc_msg_spec_span")))
                s.append("#\n# Type: unsigned  0  5000")
                s.append("# Default: 0 ")
            s.append('align_oc_msg_spec_span = ' + str(self.option_align_oc_msg_spec_span.value()))
        if full or  0!=self.option_align_nl_cont.value():
            if comment:
                s.append(self.wrap(self.tr("Whether and how to align backslashes that split a macro onto multiple lines.\nThis will not work right if the macro contains a multi-line comment.", "align_nl_cont"))+"\n#"+self.wrap(self.tr("0: Do nothing (default)\n1: Align the backslashes in the column at the end of the longest line\n2: Align with the backslash that is farthest to the left, or, if that\n   backslash is farther left than the end of the longest line, at the end of\n   the longest line\n3: Align with the backslash that is farthest to the right", "align_nl_cont")))
                s.append("#\n# Type: unsigned  0  3")
                s.append("# Default: 0 ")
            s.append('align_nl_cont = ' + str(self.option_align_nl_cont.value()))
        if full or  1!=self.option_align_nl_cont_spaces.value():
            if comment:
                s.append(self.wrap(self.tr("The minimum number of spaces between the end of a line and its continuation\nbackslash. Requires align_nl_cont.", "align_nl_cont_spaces")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 1 ")
            s.append('align_nl_cont_spaces = ' + str(self.option_align_nl_cont_spaces.value()))
        if full or  'false'!=self.option_align_pp_define_together.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to align macro functions and variables together.", "align_pp_define_together")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_pp_define_together = ' + self.option_align_pp_define_together.currentText())
        if full or  0!=self.option_align_pp_define_span.value():
            if comment:
                s.append(self.wrap(self.tr("The span for aligning on '#define' bodies.", "align_pp_define_span"))+"\n#"+self.wrap(self.tr("=0: Don't align (default)\n>0: Number of lines (including comments) between blocks", "align_pp_define_span")))
                s.append("#\n# Type: unsigned  0  5000")
                s.append("# Default: 0 ")
            s.append('align_pp_define_span = ' + str(self.option_align_pp_define_span.value()))
        if full or  0!=self.option_align_pp_define_gap.value():
            if comment:
                s.append(self.wrap(self.tr("The minimum space between label and value of a preprocessor define.", "align_pp_define_gap")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('align_pp_define_gap = ' + str(self.option_align_pp_define_gap.value()))
        if full or  'true'!=self.option_align_left_shift.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to align lines that start with '<<' with previous '<<'.", "align_left_shift")))
                s.append("#\n# Type: true/false")
                s.append("# Default: true ")
            s.append('align_left_shift = ' + self.option_align_left_shift.currentText())
        if full or  'false'!=self.option_align_eigen_comma_init.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to align comma-separated statements following '<<' (as used to\ninitialize Eigen matrices).", "align_eigen_comma_init")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_eigen_comma_init = ' + self.option_align_eigen_comma_init.currentText())
        if full or  'false'!=self.option_align_asm_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to align text after 'asm volatile ()' colons.", "align_asm_colon")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_asm_colon = ' + self.option_align_asm_colon.currentText())
        if full or  0!=self.option_align_oc_msg_colon_span.value():
            if comment:
                s.append(self.wrap(self.tr("(OC) Span for aligning parameters in an Objective-C message call\non the ':'.", "align_oc_msg_colon_span"))+"\n#"+self.wrap(self.tr("0: Don't align.", "align_oc_msg_colon_span")))
                s.append("#\n# Type: unsigned  0  5000")
                s.append("# Default: 0 ")
            s.append('align_oc_msg_colon_span = ' + str(self.option_align_oc_msg_colon_span.value()))
        if full or  'false'!=self.option_align_oc_msg_colon_first.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Whether to always align with the first parameter, even if it is too\nshort.", "align_oc_msg_colon_first")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_oc_msg_colon_first = ' + self.option_align_oc_msg_colon_first.currentText())
        if full or  'false'!=self.option_align_oc_decl_colon.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Whether to align parameters in an Objective-C '+' or '-' declaration\non the ':'.", "align_oc_decl_colon")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_oc_decl_colon = ' + self.option_align_oc_decl_colon.currentText())
        if full or  'false'!=self.option_align_oc_msg_colon_xcode_like.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Whether to not align parameters in an Objectve-C message call if first\ncolon is not on next line of the message call (the same way Xcode does\nalignment)", "align_oc_msg_colon_xcode_like")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('align_oc_msg_colon_xcode_like = ' + self.option_align_oc_msg_colon_xcode_like.currentText())
        #================== Comment modification options ====================================================
        if full or  comment: s.append('\n\n'+'#'*80+self.wrap(self.tr("Comment modification options"))+'\n'+'#'*80)
        if full or  0!=self.option_cmt_width.value():
            if comment:
                s.append(self.wrap(self.tr("Try to wrap comments at N columns.", "cmt_width")))
                s.append("#\n# Type: unsigned  0  256")
                s.append("# Default: 0 ")
            s.append('cmt_width = ' + str(self.option_cmt_width.value()))
        if full or  0!=self.option_cmt_reflow_mode.value():
            if comment:
                s.append(self.wrap(self.tr("How to reflow comments.", "cmt_reflow_mode"))+"\n#"+self.wrap(self.tr("0: No reflowing (apart from the line wrapping due to cmt_width) (default)\n1: No touching at all\n2: Full reflow (enable cmt_indent_multi for indent with line wrapping due to cmt_width)", "cmt_reflow_mode")))
                s.append("#\n# Type: unsigned  0  2")
                s.append("# Default: 0 ")
            s.append('cmt_reflow_mode = ' + str(self.option_cmt_reflow_mode.value()))
        if full or  ''!=self.option_cmt_reflow_fold_regex_file.text():
            if comment:
                s.append(self.wrap(self.tr("Path to a file that contains regular expressions describing patterns for\nwhich the end of one line and the beginning of the next will be folded into\nthe same sentence or paragraph during full comment reflow. The regular\nexpressions are described using ECMAScript syntax. The syntax for this\nspecification is as follows, where \"...\" indicates the custom regular\nexpression and \"n\" indicates the nth end_of_prev_line_regex and\nbeg_of_next_line_regex regular expression pair:", "cmt_reflow_fold_regex_file"))+"\n#"+self.wrap(self.tr("end_of_prev_line_regex[1] = \"...$\"\nbeg_of_next_line_regex[1] = \"^...\"\nend_of_prev_line_regex[2] = \"...$\"\nbeg_of_next_line_regex[2] = \"^...\"\n            .\n            .\n            .\nend_of_prev_line_regex[n] = \"...$\"\nbeg_of_next_line_regex[n] = \"^...\"", "cmt_reflow_fold_regex_file"))+"\n#"+self.wrap(self.tr("Note that use of this option overrides the default reflow fold regular\nexpressions, which are internally defined as follows:", "cmt_reflow_fold_regex_file"))+"\n#"+self.wrap(self.tr("end_of_prev_line_regex[1] = \"[\\w,\\]\\)]$\"\nbeg_of_next_line_regex[1] = \"^[\\w,\\[\\(]\"\nend_of_prev_line_regex[2] = \"\\.$\"\nbeg_of_next_line_regex[2] = \"^[A-Z]\"", "cmt_reflow_fold_regex_file")))
                s.append("#\n# Type: string")
                s.append("# Default:  ")
            s.append('cmt_reflow_fold_regex_file = "' + self.option_cmt_reflow_fold_regex_file.text()+'"\n')
        if full or  'false'!=self.option_cmt_reflow_indent_to_paragraph_start.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent wrapped lines to the start of the encompassing paragraph\nduring full comment reflow (cmt_reflow_mode = 2). Overrides the value\nspecified by cmt_sp_after_star_cont.", "cmt_reflow_indent_to_paragraph_start"))+"\n#"+self.wrap(self.tr("Note that cmt_align_doxygen_javadoc_tags overrides this option for\nparagraphs associated with javadoc tags", "cmt_reflow_indent_to_paragraph_start")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('cmt_reflow_indent_to_paragraph_start = ' + self.option_cmt_reflow_indent_to_paragraph_start.currentText())
        if full or  'false'!=self.option_cmt_convert_tab_to_spaces.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to convert all tabs to spaces in comments. If false, tabs in\ncomments are left alone, unless used for indenting.", "cmt_convert_tab_to_spaces")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('cmt_convert_tab_to_spaces = ' + self.option_cmt_convert_tab_to_spaces.currentText())
        if full or  'true'!=self.option_cmt_indent_multi.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to apply changes to multi-line comments, including cmt_width,\nkeyword substitution and leading chars.", "cmt_indent_multi")))
                s.append("#\n# Type: true/false")
                s.append("# Default: true ")
            s.append('cmt_indent_multi = ' + self.option_cmt_indent_multi.currentText())
        if full or  'false'!=self.option_cmt_align_doxygen_javadoc_tags.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to align doxygen javadoc-style tags ('@param', '@return', etc.)\nand corresponding fields such that groups of consecutive block tags,\nparameter names, and descriptions align with one another. Overrides that\nwhich is specified by the cmt_sp_after_star_cont. If cmt_width > 0, it may\nbe necessary to enable cmt_indent_multi and set cmt_reflow_mode = 2\nin order to achieve the desired alignment for line-wrapping.", "cmt_align_doxygen_javadoc_tags")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('cmt_align_doxygen_javadoc_tags = ' + self.option_cmt_align_doxygen_javadoc_tags.currentText())
        if full or  1!=self.option_cmt_sp_before_doxygen_javadoc_tags.value():
            if comment:
                s.append(self.wrap(self.tr("The number of spaces to insert after the star and before doxygen\njavadoc-style tags (@param, @return, etc). Requires enabling\ncmt_align_doxygen_javadoc_tags. Overrides that which is specified by the\ncmt_sp_after_star_cont.", "cmt_sp_before_doxygen_javadoc_tags")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 1 ")
            s.append('cmt_sp_before_doxygen_javadoc_tags = ' + str(self.option_cmt_sp_before_doxygen_javadoc_tags.value()))
        if full or  'false'!=self.option_cmt_trailing_single_line_c_to_cpp.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to change trailing, single-line c-comments into cpp-comments.", "cmt_trailing_single_line_c_to_cpp")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('cmt_trailing_single_line_c_to_cpp = ' + self.option_cmt_trailing_single_line_c_to_cpp.currentText())
        if full or  'false'!=self.option_cmt_c_group.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to group c-comments that look like they are in a block.", "cmt_c_group")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('cmt_c_group = ' + self.option_cmt_c_group.currentText())
        if full or  'false'!=self.option_cmt_c_nl_start.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to put an empty '/*' on the first line of the combined c-comment.", "cmt_c_nl_start")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('cmt_c_nl_start = ' + self.option_cmt_c_nl_start.currentText())
        if full or  'false'!=self.option_cmt_c_nl_end.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline before the closing '*/' of the combined c-comment.", "cmt_c_nl_end")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('cmt_c_nl_end = ' + self.option_cmt_c_nl_end.currentText())
        if full or  'false'!=self.option_cmt_cpp_to_c.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to change cpp-comments into c-comments.", "cmt_cpp_to_c")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('cmt_cpp_to_c = ' + self.option_cmt_cpp_to_c.currentText())
        if full or  'false'!=self.option_cmt_cpp_group.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to group cpp-comments that look like they are in a block. Only\nmeaningful if cmt_cpp_to_c=true.", "cmt_cpp_group")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('cmt_cpp_group = ' + self.option_cmt_cpp_group.currentText())
        if full or  'false'!=self.option_cmt_cpp_nl_start.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to put an empty '/*' on the first line of the combined cpp-comment\nwhen converting to a c-comment.", "cmt_cpp_nl_start"))+"\n#"+self.wrap(self.tr("Requires cmt_cpp_to_c=true and cmt_cpp_group=true.", "cmt_cpp_nl_start")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('cmt_cpp_nl_start = ' + self.option_cmt_cpp_nl_start.currentText())
        if full or  'false'!=self.option_cmt_cpp_nl_end.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add a newline before the closing '*/' of the combined cpp-comment\nwhen converting to a c-comment.", "cmt_cpp_nl_end"))+"\n#"+self.wrap(self.tr("Requires cmt_cpp_to_c=true and cmt_cpp_group=true.", "cmt_cpp_nl_end")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('cmt_cpp_nl_end = ' + self.option_cmt_cpp_nl_end.currentText())
        if full or  'false'!=self.option_cmt_star_cont.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to put a star on subsequent comment lines.", "cmt_star_cont")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('cmt_star_cont = ' + self.option_cmt_star_cont.currentText())
        if full or  0!=self.option_cmt_sp_before_star_cont.value():
            if comment:
                s.append(self.wrap(self.tr("The number of spaces to insert at the start of subsequent comment lines.", "cmt_sp_before_star_cont")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('cmt_sp_before_star_cont = ' + str(self.option_cmt_sp_before_star_cont.value()))
        if full or  0!=self.option_cmt_sp_after_star_cont.value():
            if comment:
                s.append(self.wrap(self.tr("The number of spaces to insert after the star on subsequent comment lines.", "cmt_sp_after_star_cont")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('cmt_sp_after_star_cont = ' + str(self.option_cmt_sp_after_star_cont.value()))
        if full or  'true'!=self.option_cmt_multi_check_last.currentText():
            if comment:
                s.append(self.wrap(self.tr("For multi-line comments with a '*' lead, remove leading spaces if the first\nand last lines of the comment are the same length.", "cmt_multi_check_last")))
                s.append("#\n# Type: true/false")
                s.append("# Default: true ")
            s.append('cmt_multi_check_last = ' + self.option_cmt_multi_check_last.currentText())
        if full or  4!=self.option_cmt_multi_first_len_minimum.value():
            if comment:
                s.append(self.wrap(self.tr("For multi-line comments with a '*' lead, remove leading spaces if the first\nand last lines of the comment are the same length AND if the length is\nbigger as the first_len minimum.", "cmt_multi_first_len_minimum")))
                s.append("#\n# Type: unsigned  1  20")
                s.append("# Default: 4 ")
            s.append('cmt_multi_first_len_minimum = ' + str(self.option_cmt_multi_first_len_minimum.value()))
        if full or  ''!=self.option_cmt_insert_file_header.text():
            if comment:
                s.append(self.wrap(self.tr("Path to a file that contains text to insert at the beginning of a file if\nthe file doesn't start with a C/C++ comment. If the inserted text contains\n'$(filename)', that will be replaced with the current file's name.", "cmt_insert_file_header")))
                s.append("#\n# Type: string")
                s.append("# Default:  ")
            s.append('cmt_insert_file_header = "' + self.option_cmt_insert_file_header.text()+'"\n')
        if full or  ''!=self.option_cmt_insert_file_footer.text():
            if comment:
                s.append(self.wrap(self.tr("Path to a file that contains text to insert at the end of a file if the\nfile doesn't end with a C/C++ comment. If the inserted text contains\n'$(filename)', that will be replaced with the current file's name.", "cmt_insert_file_footer")))
                s.append("#\n# Type: string")
                s.append("# Default:  ")
            s.append('cmt_insert_file_footer = "' + self.option_cmt_insert_file_footer.text()+'"\n')
        if full or  ''!=self.option_cmt_insert_func_header.text():
            if comment:
                s.append(self.wrap(self.tr("Path to a file that contains text to insert before a function definition if\nthe function isn't preceded by a C/C++ comment. If the inserted text\ncontains '$(function)', '$(javaparam)' or '$(fclass)', these will be\nreplaced with, respectively, the name of the function, the javadoc '@param'\nand '@return' stuff, or the name of the class to which the member function\nbelongs.", "cmt_insert_func_header")))
                s.append("#\n# Type: string")
                s.append("# Default:  ")
            s.append('cmt_insert_func_header = "' + self.option_cmt_insert_func_header.text()+'"\n')
        if full or  ''!=self.option_cmt_insert_class_header.text():
            if comment:
                s.append(self.wrap(self.tr("Path to a file that contains text to insert before a class if the class\nisn't preceded by a C/C++ comment. If the inserted text contains '$(class)',\nthat will be replaced with the class name.", "cmt_insert_class_header")))
                s.append("#\n# Type: string")
                s.append("# Default:  ")
            s.append('cmt_insert_class_header = "' + self.option_cmt_insert_class_header.text()+'"\n')
        if full or  ''!=self.option_cmt_insert_oc_msg_header.text():
            if comment:
                s.append(self.wrap(self.tr("Path to a file that contains text to insert before an Objective-C message\nspecification, if the method isn't preceded by a C/C++ comment. If the\ninserted text contains '$(message)' or '$(javaparam)', these will be\nreplaced with, respectively, the name of the function, or the javadoc\n'@param' and '@return' stuff.", "cmt_insert_oc_msg_header")))
                s.append("#\n# Type: string")
                s.append("# Default:  ")
            s.append('cmt_insert_oc_msg_header = "' + self.option_cmt_insert_oc_msg_header.text()+'"\n')
        if full or  'false'!=self.option_cmt_insert_before_preproc.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether a comment should be inserted if a preprocessor is encountered when\nstepping backwards from a function name.", "cmt_insert_before_preproc"))+"\n#"+self.wrap(self.tr("Applies to cmt_insert_oc_msg_header, cmt_insert_func_header and\ncmt_insert_class_header.", "cmt_insert_before_preproc")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('cmt_insert_before_preproc = ' + self.option_cmt_insert_before_preproc.currentText())
        if full or  'true'!=self.option_cmt_insert_before_inlines.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether a comment should be inserted if a function is declared inline to a\nclass definition.", "cmt_insert_before_inlines"))+"\n#"+self.wrap(self.tr("Applies to cmt_insert_func_header.", "cmt_insert_before_inlines")))
                s.append("#\n# Type: true/false")
                s.append("# Default: true ")
            s.append('cmt_insert_before_inlines = ' + self.option_cmt_insert_before_inlines.currentText())
        if full or  'false'!=self.option_cmt_insert_before_ctor_dtor.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether a comment should be inserted if the function is a class constructor\nor destructor.", "cmt_insert_before_ctor_dtor"))+"\n#"+self.wrap(self.tr("Applies to cmt_insert_func_header.", "cmt_insert_before_ctor_dtor")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('cmt_insert_before_ctor_dtor = ' + self.option_cmt_insert_before_ctor_dtor.currentText())
        #================== Code modifying options (non-whitespace) =========================================
        if full or  comment: s.append('\n\n'+'#'*80+self.wrap(self.tr("Code modifying options (non-whitespace)"))+'\n'+'#'*80)
        if full or  'ignore'!=self.option_mod_full_brace_do.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove braces on a single-line 'do' statement.", "mod_full_brace_do")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('mod_full_brace_do = ' + self.option_mod_full_brace_do.currentText())
        if full or  'ignore'!=self.option_mod_full_brace_for.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove braces on a single-line 'for' statement.", "mod_full_brace_for")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('mod_full_brace_for = ' + self.option_mod_full_brace_for.currentText())
        if full or  'ignore'!=self.option_mod_full_brace_function.currentText():
            if comment:
                s.append(self.wrap(self.tr("(Pawn) Add or remove braces on a single-line function definition.", "mod_full_brace_function")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('mod_full_brace_function = ' + self.option_mod_full_brace_function.currentText())
        if full or  'ignore'!=self.option_mod_full_brace_if.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove braces on a single-line 'if' statement. Braces will not be\nremoved if the braced statement contains an 'else'.", "mod_full_brace_if")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('mod_full_brace_if = ' + self.option_mod_full_brace_if.currentText())
        if full or  0!=self.option_mod_full_brace_if_chain.value():
            if comment:
                s.append(self.wrap(self.tr("Whether to enforce that all blocks of an 'if'/'else if'/'else' chain either\nhave, or do not have, braces. Overrides mod_full_brace_if.", "mod_full_brace_if_chain"))+"\n#"+self.wrap(self.tr("0: Don't override mod_full_brace_if\n1: Add braces to all blocks if any block needs braces and remove braces if\n   they can be removed from all blocks\n2: Add braces to all blocks if any block already has braces, regardless of\n   whether it needs them\n3: Add braces to all blocks if any block needs braces and remove braces if\n   they can be removed from all blocks, except if all blocks have braces\n   despite none needing them", "mod_full_brace_if_chain")))
                s.append("#\n# Type: unsigned  0  3")
                s.append("# Default: 0 ")
            s.append('mod_full_brace_if_chain = ' + str(self.option_mod_full_brace_if_chain.value()))
        if full or  'false'!=self.option_mod_full_brace_if_chain_only.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to add braces to all blocks of an 'if'/'else if'/'else' chain.\nIf true, mod_full_brace_if_chain will only remove braces from an 'if' that\ndoes not have an 'else if' or 'else'.", "mod_full_brace_if_chain_only")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_full_brace_if_chain_only = ' + self.option_mod_full_brace_if_chain_only.currentText())
        if full or  'ignore'!=self.option_mod_full_brace_while.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove braces on single-line 'while' statement.", "mod_full_brace_while")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('mod_full_brace_while = ' + self.option_mod_full_brace_while.currentText())
        if full or  'ignore'!=self.option_mod_full_brace_using.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove braces on single-line 'using ()' statement.", "mod_full_brace_using")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('mod_full_brace_using = ' + self.option_mod_full_brace_using.currentText())
        if full or  0!=self.option_mod_full_brace_nl.value():
            if comment:
                s.append(self.wrap(self.tr("Don't remove braces around statements that span N newlines", "mod_full_brace_nl")))
                s.append("#\n# Type: unsigned  0  5000")
                s.append("# Default: 0 ")
            s.append('mod_full_brace_nl = ' + str(self.option_mod_full_brace_nl.value()))
        if full or  'false'!=self.option_mod_full_brace_nl_block_rem_mlcond.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to prevent removal of braces from 'if'/'for'/'while'/etc. blocks\nwhich span multiple lines.", "mod_full_brace_nl_block_rem_mlcond"))+"\n#"+self.wrap(self.tr("Affects:\n  mod_full_brace_for\n  mod_full_brace_if\n  mod_full_brace_if_chain\n  mod_full_brace_if_chain_only\n  mod_full_brace_while\n  mod_full_brace_using", "mod_full_brace_nl_block_rem_mlcond"))+"\n#"+self.wrap(self.tr("Does not affect:\n  mod_full_brace_do\n  mod_full_brace_function", "mod_full_brace_nl_block_rem_mlcond")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_full_brace_nl_block_rem_mlcond = ' + self.option_mod_full_brace_nl_block_rem_mlcond.currentText())
        if full or  'ignore'!=self.option_mod_paren_on_return.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove unnecessary parentheses on 'return' statement.", "mod_paren_on_return")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('mod_paren_on_return = ' + self.option_mod_paren_on_return.currentText())
        if full or  'ignore'!=self.option_mod_paren_on_throw.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove unnecessary parentheses on 'throw' statement.", "mod_paren_on_throw")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('mod_paren_on_throw = ' + self.option_mod_paren_on_throw.currentText())
        if full or  'false'!=self.option_mod_pawn_semicolon.currentText():
            if comment:
                s.append(self.wrap(self.tr("(Pawn) Whether to change optional semicolons to real semicolons.", "mod_pawn_semicolon")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_pawn_semicolon = ' + self.option_mod_pawn_semicolon.currentText())
        if full or  'false'!=self.option_mod_full_paren_if_bool.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to fully parenthesize Boolean expressions in 'while' and 'if'\nstatement, as in 'if (a && b > c)' => 'if (a && (b > c))'.", "mod_full_paren_if_bool")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_full_paren_if_bool = ' + self.option_mod_full_paren_if_bool.currentText())
        if full or  'false'!=self.option_mod_full_paren_assign_bool.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to fully parenthesize Boolean expressions after '='\nstatement, as in 'x = a && b > c;' => 'x = (a && (b > c));'.", "mod_full_paren_assign_bool")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_full_paren_assign_bool = ' + self.option_mod_full_paren_assign_bool.currentText())
        if full or  'false'!=self.option_mod_full_paren_return_bool.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to fully parenthesize Boolean expressions after '='\nstatement, as in 'return  a && b > c;' => 'return (a && (b > c));'.", "mod_full_paren_return_bool")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_full_paren_return_bool = ' + self.option_mod_full_paren_return_bool.currentText())
        if full or  'false'!=self.option_mod_remove_extra_semicolon.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to remove superfluous semicolons.", "mod_remove_extra_semicolon")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_remove_extra_semicolon = ' + self.option_mod_remove_extra_semicolon.currentText())
        if full or  'false'!=self.option_mod_remove_duplicate_include.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to remove duplicate include.", "mod_remove_duplicate_include")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_remove_duplicate_include = ' + self.option_mod_remove_duplicate_include.currentText())
        if full or  'false'!=self.option_mod_add_force_c_closebrace_comment.currentText():
            if comment:
                s.append(self.wrap(self.tr("the following options (mod_XX_closebrace_comment) use different comment,\ndepending of the setting of the next option.\nfalse: Use the c comment (default)\ntrue : Use the cpp comment", "mod_add_force_c_closebrace_comment")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_add_force_c_closebrace_comment = ' + self.option_mod_add_force_c_closebrace_comment.currentText())
        if full or  0!=self.option_mod_add_long_function_closebrace_comment.value():
            if comment:
                s.append(self.wrap(self.tr("If a function body exceeds the specified number of newlines and doesn't have\na comment after the close brace, a comment will be added.", "mod_add_long_function_closebrace_comment")))
                s.append("#\n# Type: unsigned  0  255")
                s.append("# Default: 0 ")
            s.append('mod_add_long_function_closebrace_comment = ' + str(self.option_mod_add_long_function_closebrace_comment.value()))
        if full or  0!=self.option_mod_add_long_namespace_closebrace_comment.value():
            if comment:
                s.append(self.wrap(self.tr("If a namespace body exceeds the specified number of newlines and doesn't\nhave a comment after the close brace, a comment will be added.", "mod_add_long_namespace_closebrace_comment")))
                s.append("#\n# Type: unsigned  0  255")
                s.append("# Default: 0 ")
            s.append('mod_add_long_namespace_closebrace_comment = ' + str(self.option_mod_add_long_namespace_closebrace_comment.value()))
        if full or  0!=self.option_mod_add_long_class_closebrace_comment.value():
            if comment:
                s.append(self.wrap(self.tr("If a class body exceeds the specified number of newlines and doesn't have a\ncomment after the close brace, a comment will be added.", "mod_add_long_class_closebrace_comment")))
                s.append("#\n# Type: unsigned  0  255")
                s.append("# Default: 0 ")
            s.append('mod_add_long_class_closebrace_comment = ' + str(self.option_mod_add_long_class_closebrace_comment.value()))
        if full or  0!=self.option_mod_add_long_switch_closebrace_comment.value():
            if comment:
                s.append(self.wrap(self.tr("If a switch body exceeds the specified number of newlines and doesn't have a\ncomment after the close brace, a comment will be added.", "mod_add_long_switch_closebrace_comment")))
                s.append("#\n# Type: unsigned  0  255")
                s.append("# Default: 0 ")
            s.append('mod_add_long_switch_closebrace_comment = ' + str(self.option_mod_add_long_switch_closebrace_comment.value()))
        if full or  0!=self.option_mod_add_long_ifdef_endif_comment.value():
            if comment:
                s.append(self.wrap(self.tr("If an #ifdef body exceeds the specified number of newlines and doesn't have\na comment after the #endif, a comment will be added.", "mod_add_long_ifdef_endif_comment")))
                s.append("#\n# Type: unsigned  0  255")
                s.append("# Default: 0 ")
            s.append('mod_add_long_ifdef_endif_comment = ' + str(self.option_mod_add_long_ifdef_endif_comment.value()))
        if full or  0!=self.option_mod_add_long_ifdef_else_comment.value():
            if comment:
                s.append(self.wrap(self.tr("If an #ifdef or #else body exceeds the specified number of newlines and\ndoesn't have a comment after the #else, a comment will be added.", "mod_add_long_ifdef_else_comment")))
                s.append("#\n# Type: unsigned  0  255")
                s.append("# Default: 0 ")
            s.append('mod_add_long_ifdef_else_comment = ' + str(self.option_mod_add_long_ifdef_else_comment.value()))
        if full or  'false'!=self.option_mod_sort_case_sensitive.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to take care of the case by the mod_sort_xx options.", "mod_sort_case_sensitive")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_sort_case_sensitive = ' + self.option_mod_sort_case_sensitive.currentText())
        if full or  'false'!=self.option_mod_sort_import.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to sort consecutive single-line 'import' statements.", "mod_sort_import")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_sort_import = ' + self.option_mod_sort_import.currentText())
        if full or  'false'!=self.option_mod_sort_using.currentText():
            if comment:
                s.append(self.wrap(self.tr("(C#) Whether to sort consecutive single-line 'using' statements.", "mod_sort_using")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_sort_using = ' + self.option_mod_sort_using.currentText())
        if full or  'false'!=self.option_mod_sort_include.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to sort consecutive single-line '#include' statements (C/C++) and\n'#import' statements (Objective-C). Be aware that this has the potential to\nbreak your code if your includes/imports have ordering dependencies.", "mod_sort_include")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_sort_include = ' + self.option_mod_sort_include.currentText())
        if full or  'false'!=self.option_mod_sort_incl_import_prioritize_filename.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to prioritize '#include' and '#import' statements that contain\nfilename without extension when sorting is enabled.", "mod_sort_incl_import_prioritize_filename")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_sort_incl_import_prioritize_filename = ' + self.option_mod_sort_incl_import_prioritize_filename.currentText())
        if full or  'false'!=self.option_mod_sort_incl_import_prioritize_extensionless.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to prioritize '#include' and '#import' statements that does not\ncontain extensions when sorting is enabled.", "mod_sort_incl_import_prioritize_extensionless")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_sort_incl_import_prioritize_extensionless = ' + self.option_mod_sort_incl_import_prioritize_extensionless.currentText())
        if full or  'false'!=self.option_mod_sort_incl_import_prioritize_angle_over_quotes.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to prioritize '#include' and '#import' statements that contain\nangle over quotes when sorting is enabled.", "mod_sort_incl_import_prioritize_angle_over_quotes")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_sort_incl_import_prioritize_angle_over_quotes = ' + self.option_mod_sort_incl_import_prioritize_angle_over_quotes.currentText())
        if full or  'false'!=self.option_mod_sort_incl_import_ignore_extension.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to ignore file extension in '#include' and '#import' statements\nfor sorting comparison.", "mod_sort_incl_import_ignore_extension")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_sort_incl_import_ignore_extension = ' + self.option_mod_sort_incl_import_ignore_extension.currentText())
        if full or  'false'!=self.option_mod_sort_incl_import_grouping_enabled.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to group '#include' and '#import' statements when sorting is enabled.", "mod_sort_incl_import_grouping_enabled")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_sort_incl_import_grouping_enabled = ' + self.option_mod_sort_incl_import_grouping_enabled.currentText())
        if full or  'false'!=self.option_mod_move_case_break.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to move a 'break' that appears after a fully braced 'case' before\nthe close brace, as in 'case X: { ... } break;' => 'case X: { ... break; }'.", "mod_move_case_break")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_move_case_break = ' + self.option_mod_move_case_break.currentText())
        if full or  'false'!=self.option_mod_move_case_return.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to move a 'return' that appears after a fully braced 'case' before\nthe close brace, as in 'case X: { ... } return;' => 'case X: { ... return; }'.", "mod_move_case_return")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_move_case_return = ' + self.option_mod_move_case_return.currentText())
        if full or  'ignore'!=self.option_mod_case_brace.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove braces around a fully braced case statement. Will only remove\nbraces if there are no variable declarations in the block.", "mod_case_brace")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('mod_case_brace = ' + self.option_mod_case_brace.currentText())
        if full or  'false'!=self.option_mod_remove_empty_return.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to remove a void 'return;' that appears as the last statement in a\nfunction.", "mod_remove_empty_return")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_remove_empty_return = ' + self.option_mod_remove_empty_return.currentText())
        if full or  'ignore'!=self.option_mod_enum_last_comma.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove the comma after the last value of an enumeration.", "mod_enum_last_comma")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('mod_enum_last_comma = ' + self.option_mod_enum_last_comma.currentText())
        if full or  0!=self.option_mod_infinite_loop.value():
            if comment:
                s.append(self.wrap(self.tr("Syntax to use for infinite loops.", "mod_infinite_loop"))+"\n#"+self.wrap(self.tr("0: Leave syntax alone (default)\n1: Rewrite as `for(;;)`\n2: Rewrite as `while(true)`\n3: Rewrite as `do`...`while(true);`\n4: Rewrite as `while(1)`\n5: Rewrite as `do`...`while(1);`", "mod_infinite_loop"))+"\n#"+self.wrap(self.tr("Infinite loops that do not already match one of these syntaxes are ignored.\nOther options that affect loop formatting will be applied after transforming\nthe syntax.", "mod_infinite_loop")))
                s.append("#\n# Type: unsigned  0  5")
                s.append("# Default: 0 ")
            s.append('mod_infinite_loop = ' + str(self.option_mod_infinite_loop.value()))
        if full or  'ignore'!=self.option_mod_int_short.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove the 'int' keyword in 'int short'.", "mod_int_short")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('mod_int_short = ' + self.option_mod_int_short.currentText())
        if full or  'ignore'!=self.option_mod_short_int.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove the 'int' keyword in 'short int'.", "mod_short_int")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('mod_short_int = ' + self.option_mod_short_int.currentText())
        if full or  'ignore'!=self.option_mod_int_long.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove the 'int' keyword in 'int long'.", "mod_int_long")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('mod_int_long = ' + self.option_mod_int_long.currentText())
        if full or  'ignore'!=self.option_mod_long_int.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove the 'int' keyword in 'long int'.", "mod_long_int")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('mod_long_int = ' + self.option_mod_long_int.currentText())
        if full or  'ignore'!=self.option_mod_int_signed.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove the 'int' keyword in 'int signed'.", "mod_int_signed")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('mod_int_signed = ' + self.option_mod_int_signed.currentText())
        if full or  'ignore'!=self.option_mod_signed_int.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove the 'int' keyword in 'signed int'.", "mod_signed_int")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('mod_signed_int = ' + self.option_mod_signed_int.currentText())
        if full or  'ignore'!=self.option_mod_int_unsigned.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove the 'int' keyword in 'int unsigned'.", "mod_int_unsigned")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('mod_int_unsigned = ' + self.option_mod_int_unsigned.currentText())
        if full or  'ignore'!=self.option_mod_unsigned_int.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove the 'int' keyword in 'unsigned int'.", "mod_unsigned_int")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('mod_unsigned_int = ' + self.option_mod_unsigned_int.currentText())
        if full or  'false'!=self.option_mod_int_prefer_int_on_left.currentText():
            if comment:
                s.append(self.wrap(self.tr("If there is a situation where mod_int_* and mod_*_int would result in\nmultiple int keywords, whether to keep the rightmost int (the default) or the\nleftmost int.", "mod_int_prefer_int_on_left")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_int_prefer_int_on_left = ' + self.option_mod_int_prefer_int_on_left.currentText())
        if full or  'false'!=self.option_mod_sort_oc_properties.currentText():
            if comment:
                s.append(self.wrap(self.tr("(OC) Whether to organize the properties. If true, properties will be\nrearranged according to the mod_sort_oc_property_*_weight factors.", "mod_sort_oc_properties")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('mod_sort_oc_properties = ' + self.option_mod_sort_oc_properties.currentText())
        if full or  0!=self.option_mod_sort_oc_property_class_weight.value():
            if comment:
                s.append(self.wrap(self.tr("(OC) Weight of a class property modifier.", "mod_sort_oc_property_class_weight")))
                s.append("#\n# Type: signed")
                s.append("# Default: 0 ")
            s.append('mod_sort_oc_property_class_weight = ' + str(self.option_mod_sort_oc_property_class_weight.value()))
        if full or  0!=self.option_mod_sort_oc_property_thread_safe_weight.value():
            if comment:
                s.append(self.wrap(self.tr("(OC) Weight of 'atomic' and 'nonatomic'.", "mod_sort_oc_property_thread_safe_weight")))
                s.append("#\n# Type: signed")
                s.append("# Default: 0 ")
            s.append('mod_sort_oc_property_thread_safe_weight = ' + str(self.option_mod_sort_oc_property_thread_safe_weight.value()))
        if full or  0!=self.option_mod_sort_oc_property_readwrite_weight.value():
            if comment:
                s.append(self.wrap(self.tr("(OC) Weight of 'readwrite' when organizing properties.", "mod_sort_oc_property_readwrite_weight")))
                s.append("#\n# Type: signed")
                s.append("# Default: 0 ")
            s.append('mod_sort_oc_property_readwrite_weight = ' + str(self.option_mod_sort_oc_property_readwrite_weight.value()))
        if full or  0!=self.option_mod_sort_oc_property_reference_weight.value():
            if comment:
                s.append(self.wrap(self.tr("(OC) Weight of a reference type specifier ('retain', 'copy', 'assign',\n'weak', 'strong') when organizing properties.", "mod_sort_oc_property_reference_weight")))
                s.append("#\n# Type: signed")
                s.append("# Default: 0 ")
            s.append('mod_sort_oc_property_reference_weight = ' + str(self.option_mod_sort_oc_property_reference_weight.value()))
        if full or  0!=self.option_mod_sort_oc_property_getter_weight.value():
            if comment:
                s.append(self.wrap(self.tr("(OC) Weight of getter type ('getter=') when organizing properties.", "mod_sort_oc_property_getter_weight")))
                s.append("#\n# Type: signed")
                s.append("# Default: 0 ")
            s.append('mod_sort_oc_property_getter_weight = ' + str(self.option_mod_sort_oc_property_getter_weight.value()))
        if full or  0!=self.option_mod_sort_oc_property_setter_weight.value():
            if comment:
                s.append(self.wrap(self.tr("(OC) Weight of setter type ('setter=') when organizing properties.", "mod_sort_oc_property_setter_weight")))
                s.append("#\n# Type: signed")
                s.append("# Default: 0 ")
            s.append('mod_sort_oc_property_setter_weight = ' + str(self.option_mod_sort_oc_property_setter_weight.value()))
        if full or  0!=self.option_mod_sort_oc_property_nullability_weight.value():
            if comment:
                s.append(self.wrap(self.tr("(OC) Weight of nullability type ('nullable', 'nonnull', 'null_unspecified',\n'null_resettable') when organizing properties.", "mod_sort_oc_property_nullability_weight")))
                s.append("#\n# Type: signed")
                s.append("# Default: 0 ")
            s.append('mod_sort_oc_property_nullability_weight = ' + str(self.option_mod_sort_oc_property_nullability_weight.value()))
        #================== Preprocessor options ============================================================
        if full or  comment: s.append('\n\n'+'#'*80+self.wrap(self.tr("Preprocessor options"))+'\n'+'#'*80)
        if full or  -1!=self.option_pp_indent_with_tabs.value():
            if comment:
                s.append(self.wrap(self.tr("How to use tabs when indenting preprocessor code.", "pp_indent_with_tabs"))+"\n#"+self.wrap(self.tr("-1: Use 'indent_with_tabs' setting (default)\n 0: Spaces only\n 1: Indent with tabs to brace level, align with spaces\n 2: Indent and align with tabs, using spaces when not on a tabstop", "pp_indent_with_tabs")))
                s.append("#\n# Type: signed  -1  2")
                s.append("# Default: -1 ")
            s.append('pp_indent_with_tabs = ' + str(self.option_pp_indent_with_tabs.value()))
        if full or  'ignore'!=self.option_pp_indent.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove indentation of preprocessor directives inside #if blocks\nat brace level 0 (file-level).", "pp_indent")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('pp_indent = ' + self.option_pp_indent.currentText())
        if full or  'false'!=self.option_pp_indent_at_level.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent #if/#else/#endif at the brace level. If false, these are\nindented from column 1.", "pp_indent_at_level")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('pp_indent_at_level = ' + self.option_pp_indent_at_level.currentText())
        if full or  'false'!=self.option_pp_indent_at_level0.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent #if/#else/#endif at the parenthesis level if the brace\nlevel is 0. If false, these are indented from column 1.", "pp_indent_at_level0")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('pp_indent_at_level0 = ' + self.option_pp_indent_at_level0.currentText())
        if full or  1!=self.option_pp_indent_count.value():
            if comment:
                s.append(self.wrap(self.tr("Specifies the number of columns to indent preprocessors per level\nat brace level 0 (file-level). If pp_indent_at_level=false, also specifies\nthe number of columns to indent preprocessors per level\nat brace level > 0 (function-level).", "pp_indent_count")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 1 ")
            s.append('pp_indent_count = ' + str(self.option_pp_indent_count.value()))
        if full or  'ignore'!=self.option_pp_space_after.currentText():
            if comment:
                s.append(self.wrap(self.tr("Add or remove space after # based on pp level of #if blocks.", "pp_space_after")))
                s.append("#\n# Type: ignore / add / remove / force / not_defined")
                s.append("# Default: ignore ")
            s.append('pp_space_after = ' + self.option_pp_space_after.currentText())
        if full or  0!=self.option_pp_space_count.value():
            if comment:
                s.append(self.wrap(self.tr("Sets the number of spaces per level added with pp_space_after.", "pp_space_count")))
                s.append("#\n# Type: unsigned  0  16")
                s.append("# Default: 0 ")
            s.append('pp_space_count = ' + str(self.option_pp_space_count.value()))
        if full or  0!=self.option_pp_indent_region.value():
            if comment:
                s.append(self.wrap(self.tr("The indent for '#region' and '#endregion' in C# and '#pragma region' in\nC/C++. Negative values decrease indent down to the first column.", "pp_indent_region")))
                s.append("#\n# Type: signed  -16  16")
                s.append("# Default: 0 ")
            s.append('pp_indent_region = ' + str(self.option_pp_indent_region.value()))
        if full or  'false'!=self.option_pp_region_indent_code.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent the code between #region and #endregion.", "pp_region_indent_code")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('pp_region_indent_code = ' + self.option_pp_region_indent_code.currentText())
        if full or  0!=self.option_pp_indent_if.value():
            if comment:
                s.append(self.wrap(self.tr("If pp_indent_at_level=true, sets the indent for #if, #else and #endif when\nnot at file-level. Negative values decrease indent down to the first column.", "pp_indent_if"))+"\n#"+self.wrap(self.tr("=0: Indent preprocessors using output_tab_size\n>0: Column at which all preprocessors will be indented", "pp_indent_if")))
                s.append("#\n# Type: signed  -16  16")
                s.append("# Default: 0 ")
            s.append('pp_indent_if = ' + str(self.option_pp_indent_if.value()))
        if full or  'false'!=self.option_pp_if_indent_code.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent the code between #if, #else and #endif.", "pp_if_indent_code")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('pp_if_indent_code = ' + self.option_pp_if_indent_code.currentText())
        if full or  'false'!=self.option_pp_indent_in_guard.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent the body of an #if that encompasses all the code in the file.", "pp_indent_in_guard")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('pp_indent_in_guard = ' + self.option_pp_indent_in_guard.currentText())
        if full or  'false'!=self.option_pp_define_at_level.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent '#define' at the brace level. If false, these are\nindented from column 1.", "pp_define_at_level")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('pp_define_at_level = ' + self.option_pp_define_at_level.currentText())
        if full or  'false'!=self.option_pp_include_at_level.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent '#include' at the brace level.", "pp_include_at_level")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('pp_include_at_level = ' + self.option_pp_include_at_level.currentText())
        if full or  'false'!=self.option_pp_ignore_define_body.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to ignore the '#define' body while formatting.", "pp_ignore_define_body")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('pp_ignore_define_body = ' + self.option_pp_ignore_define_body.currentText())
        if full or  8!=self.option_pp_multiline_define_body_indent.value():
            if comment:
                s.append(self.wrap(self.tr("An offset value that controls the indentation of the body of a multiline #define.\n'body' refers to all the lines of a multiline #define except the first line.\nRequires 'pp_ignore_define_body = false'.", "pp_multiline_define_body_indent"))+"\n#"+self.wrap(self.tr(" <0: Absolute column: the body indentation starts off at the specified column\n     (ex. -3 ==> the body is indented starting from column 3)\n>=0: Relative to the column of the '#' of '#define'\n     (ex.  3 ==> the body is indented starting 3 columns at the right of '#')", "pp_multiline_define_body_indent")))
                s.append("#\n# Type: signed  -32  32")
                s.append("# Default: 8 ")
            s.append('pp_multiline_define_body_indent = ' + str(self.option_pp_multiline_define_body_indent.value()))
        if full or  'true'!=self.option_pp_indent_case.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent case statements between #if, #else, and #endif.\nOnly applies to the indent of the preprocessor that the case statements\ndirectly inside of.", "pp_indent_case")))
                s.append("#\n# Type: true/false")
                s.append("# Default: true ")
            s.append('pp_indent_case = ' + self.option_pp_indent_case.currentText())
        if full or  'true'!=self.option_pp_indent_func_def.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent whole function definitions between #if, #else, and #endif.\nOnly applies to the indent of the preprocessor that the function definition\nis directly inside of.", "pp_indent_func_def")))
                s.append("#\n# Type: true/false")
                s.append("# Default: true ")
            s.append('pp_indent_func_def = ' + self.option_pp_indent_func_def.currentText())
        if full or  'true'!=self.option_pp_indent_extern.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to indent extern C blocks between #if, #else, and #endif.\nOnly applies to the indent of the preprocessor that the extern block is\ndirectly inside of.", "pp_indent_extern")))
                s.append("#\n# Type: true/false")
                s.append("# Default: true ")
            s.append('pp_indent_extern = ' + self.option_pp_indent_extern.currentText())
        if full or  1!=self.option_pp_indent_brace.value():
            if comment:
                s.append(self.wrap(self.tr("How to indent braces directly inside #if, #else, and #endif.\nRequires pp_if_indent_code=true and only applies to the indent of the\npreprocessor that the braces are directly inside of.\n 0: No extra indent\n 1: Indent by one level\n-1: Preserve original indentation", "pp_indent_brace")))
                s.append("#\n# Type: signed  -1  1")
                s.append("# Default: 1 ")
            s.append('pp_indent_brace = ' + str(self.option_pp_indent_brace.value()))
        if full or  0!=self.option_pp_unbalanced_if_action.value():
            if comment:
                s.append(self.wrap(self.tr("Action to perform when unbalanced #if and #else blocks are found.\n0: do nothing\n1: print a warning message\n2: terminate the program with an error (EX_SOFTWARE)", "pp_unbalanced_if_action"))+"\n#"+self.wrap(self.tr("The action will be triggered in the following cases:\n- if an #ifdef block ends on a different indent level than\n  where it started from. Example:", "pp_unbalanced_if_action"))+"\n#"+self.wrap(self.tr("   #ifdef TEST\n     int i;\n     {\n       int j;\n   #endif", "pp_unbalanced_if_action"))+"\n#"+self.wrap(self.tr("- an #elif/#else block ends on a different indent level than\n  the corresponding #ifdef block. Example:", "pp_unbalanced_if_action"))+"\n#"+self.wrap(self.tr("   #ifdef TEST\n       int i;\n   #else\n       }\n     int j;\n   #endif", "pp_unbalanced_if_action")))
                s.append("#\n# Type: unsigned  0  2")
                s.append("# Default: 0 ")
            s.append('pp_unbalanced_if_action = ' + str(self.option_pp_unbalanced_if_action.value()))
        #================== Sort includes options ===========================================================
        if full or  comment: s.append('\n\n'+'#'*80+self.wrap(self.tr("Sort includes options"))+'\n'+'#'*80)
        if full or  ''!=self.option_include_category_0.text():
            if comment:
                s.append(self.wrap(self.tr("The regex for include category with priority 0.", "include_category_0")))
                s.append("#\n# Type: string")
                s.append("# Default:  ")
            s.append('include_category_0 = "' + self.option_include_category_0.text()+'"\n')
        if full or  ''!=self.option_include_category_1.text():
            if comment:
                s.append(self.wrap(self.tr("The regex for include category with priority 1.", "include_category_1")))
                s.append("#\n# Type: string")
                s.append("# Default:  ")
            s.append('include_category_1 = "' + self.option_include_category_1.text()+'"\n')
        if full or  ''!=self.option_include_category_2.text():
            if comment:
                s.append(self.wrap(self.tr("The regex for include category with priority 2.", "include_category_2")))
                s.append("#\n# Type: string")
                s.append("# Default:  ")
            s.append('include_category_2 = "' + self.option_include_category_2.text()+'"\n')
        #================== Use or Do not Use options =======================================================
        if full or  comment: s.append('\n\n'+'#'*80+self.wrap(self.tr("Use or Do not Use options"))+'\n'+'#'*80)
        if full or  'true'!=self.option_use_indent_func_call_param.currentText():
            if comment:
                s.append(self.wrap(self.tr("true:  indent_func_call_param will be used (default)\nfalse: indent_func_call_param will NOT be used", "use_indent_func_call_param")))
                s.append("#\n# Type: true/false")
                s.append("# Default: true ")
            s.append('use_indent_func_call_param = ' + self.option_use_indent_func_call_param.currentText())
        if full or  'false'!=self.option_use_indent_continue_only_once.currentText():
            if comment:
                s.append(self.wrap(self.tr("The value of the indentation for a continuation line is calculated\ndifferently if the statement is:\n- a declaration: your case with QString fileName ...\n- an assignment: your case with pSettings = new QSettings( ...", "use_indent_continue_only_once"))+"\n#"+self.wrap(self.tr("At the second case the indentation value might be used twice:\n- at the assignment\n- at the function call (if present)", "use_indent_continue_only_once"))+"\n#"+self.wrap(self.tr("To prevent the double use of the indentation value, use this option with the\nvalue 'true'.", "use_indent_continue_only_once"))+"\n#"+self.wrap(self.tr("true:  indent_continue will be used only once\nfalse: indent_continue will be used every time (default)", "use_indent_continue_only_once"))+"\n#"+self.wrap(self.tr("Requires indent_ignore_first_continue=false.", "use_indent_continue_only_once")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('use_indent_continue_only_once = ' + self.option_use_indent_continue_only_once.currentText())
        if full or  'false'!=self.option_indent_cpp_lambda_only_once.currentText():
            if comment:
                s.append(self.wrap(self.tr("The indentation can be:\n- after the assignment, at the '[' character\n- at the beginning of the lambda body", "indent_cpp_lambda_only_once"))+"\n#"+self.wrap(self.tr("true:  indentation will be at the beginning of the lambda body\nfalse: indentation will be after the assignment (default)", "indent_cpp_lambda_only_once")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('indent_cpp_lambda_only_once = ' + self.option_indent_cpp_lambda_only_once.currentText())
        if full or  'false'!=self.option_use_sp_after_angle_always.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether sp_after_angle takes precedence over sp_inside_fparen. This was the\nhistoric behavior, but is probably not the desired behavior, so this is off\nby default.", "use_sp_after_angle_always")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('use_sp_after_angle_always = ' + self.option_use_sp_after_angle_always.currentText())
        if full or  'true'!=self.option_use_options_overriding_for_qt_macros.currentText():
            if comment:
                s.append(self.wrap(self.tr("Whether to apply special formatting for Qt SIGNAL/SLOT macros. Essentially,\nthis tries to format these so that they match Qt's normalized form (i.e. the\nresult of QMetaObject::normalizedSignature), which can slightly improve the\nperformance of the QObject::connect call, rather than how they would\notherwise be formatted.", "use_options_overriding_for_qt_macros"))+"\n#"+self.wrap(self.tr("See options_for_QT.cpp for details.", "use_options_overriding_for_qt_macros")))
                s.append("#\n# Type: true/false")
                s.append("# Default: true ")
            s.append('use_options_overriding_for_qt_macros = ' + self.option_use_options_overriding_for_qt_macros.currentText())
        if full or  'false'!=self.option_use_form_feed_no_more_as_whitespace_character.currentText():
            if comment:
                s.append(self.wrap(self.tr("If true: the form feed character is removed from the list of whitespace\ncharacters. See https://en.cppreference.com/w/cpp/string/byte/isspace.", "use_form_feed_no_more_as_whitespace_character")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('use_form_feed_no_more_as_whitespace_character = ' + self.option_use_form_feed_no_more_as_whitespace_character.currentText())
        #================== Warn levels - 1: error, 2: warning (default), 3: note ===========================
        if full or  comment: s.append('\n\n'+'#'*80+self.wrap(self.tr("Warn levels - 1: error, 2: warning (default), 3: note"))+'\n'+'#'*80)
        if full or  2!=self.option_warn_level_tabs_found_in_verbatim_string_literals.value():
            if comment:
                s.append(self.wrap(self.tr("(C#) Warning is given if doing tab-to-\\t replacement and we have found one\nin a C# verbatim string literal.", "warn_level_tabs_found_in_verbatim_string_literals")))
                s.append("#\n# Type: unsigned  1  3")
                s.append("# Default: 2 ")
            s.append('warn_level_tabs_found_in_verbatim_string_literals = ' + str(self.option_warn_level_tabs_found_in_verbatim_string_literals.value()))
        if full or  0!=self.option_debug_max_number_of_loops.value():
            if comment:
                s.append(self.wrap(self.tr("Limit the number of loops.\nUsed by uncrustify.cpp to exit from infinite loop.\n0: no limit.", "debug_max_number_of_loops")))
                s.append("#\n# Type: signed")
                s.append("# Default: 0 ")
            s.append('debug_max_number_of_loops = ' + str(self.option_debug_max_number_of_loops.value()))
        if full or  0!=self.option_debug_line_number_to_protocol.value():
            if comment:
                s.append(self.wrap(self.tr("Set the number of the line to protocol;\nUsed in the function prot_the_line if the 2. parameter is zero.\n0: nothing protocol.", "debug_line_number_to_protocol")))
                s.append("#\n# Type: signed")
                s.append("# Default: 0 ")
            s.append('debug_line_number_to_protocol = ' + str(self.option_debug_line_number_to_protocol.value()))
        if full or  0!=self.option_debug_timeout.value():
            if comment:
                s.append(self.wrap(self.tr("Set the number of second(s) before terminating formatting the current file,\n0: no timeout.\nonly for linux", "debug_timeout")))
                s.append("#\n# Type: signed")
                s.append("# Default: 0 ")
            s.append('debug_timeout = ' + str(self.option_debug_timeout.value()))
        if full or  0!=self.option_debug_truncate.value():
            if comment:
                s.append(self.wrap(self.tr("Set the number of characters to be printed if the text is too long,\n0: do not truncate.", "debug_truncate")))
                s.append("#\n# Type: unsigned  0  960")
                s.append("# Default: 0 ")
            s.append('debug_truncate = ' + str(self.option_debug_truncate.value()))
        if full or  'true'!=self.option_debug_sort_the_tracks.currentText():
            if comment:
                s.append(self.wrap(self.tr("sort (or not) the tracking info.", "debug_sort_the_tracks")))
                s.append("#\n# Type: true/false")
                s.append("# Default: true ")
            s.append('debug_sort_the_tracks = ' + self.option_debug_sort_the_tracks.currentText())
        if full or  'false'!=self.option_debug_decode_the_flags.currentText():
            if comment:
                s.append(self.wrap(self.tr("decode (or not) the flags as a new line.\nonly if the -p option is set.", "debug_decode_the_flags")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('debug_decode_the_flags = ' + self.option_debug_decode_the_flags.currentText())
        if full or  'true'!=self.option_debug_use_the_exit_function_pop.currentText():
            if comment:
                s.append(self.wrap(self.tr("use (or not) the exit(EX_SOFTWARE) function.", "debug_use_the_exit_function_pop")))
                s.append("#\n# Type: true/false")
                s.append("# Default: true ")
            s.append('debug_use_the_exit_function_pop = ' + self.option_debug_use_the_exit_function_pop.currentText())
        if full or  'false'!=self.option_debug_print_version.currentText():
            if comment:
                s.append(self.wrap(self.tr("print (or not) the version in the file defined at the command option -o.", "debug_print_version")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('debug_print_version = ' + self.option_debug_print_version.currentText())
        if full or  'false'!=self.option_set_numbering_for_html_output.currentText():
            if comment:
                s.append(self.wrap(self.tr("insert the number of the line at the beginning of each line", "set_numbering_for_html_output")))
                s.append("#\n# Type: true/false")
                s.append("# Default: false ")
            s.append('set_numbering_for_html_output = ' + self.option_set_numbering_for_html_output.currentText())
        return '\n'.join(s)
    ###########################################################################################
    ###########################################################################################
    ###########################################################################################
    ###########################################################################################
    ###########################################################################################
    def load(self, path):
        regexp = r"^([^#\s].+)\s*=\s*([^\n]*?)\n"
        f = open(path, encoding = "utf-8")
        d = f.read()
        f.close()
        matches = re.finditer(regexp, d, re.MULTILINE | re.IGNORECASE)
        params = {}
        for matchNum, match in enumerate(matches, start = 1):
            param = match.group(1).strip()
            val = match.group(2)
            if val[0] == '"':
                val = val[1:val.rfind('"')]
            elif val[0] == "'":
                val = val[1:val.rfind("'")]
            else:
                if val.rfind("#") > 0:
                    val = val[:val.rfind("#")]
                val = val.strip()
            params[param] = val

        #================== General options =================================================================
        if "newlines" in params: 
            try:
                self.option_newlines.setCurrentText(params["newlines"])
            except: 
                pass
        if "input_tab_size" in params:
            try:
                self.option_input_tab_size.setValue(int(params["input_tab_size"]))
            except:
                pass
        if "output_tab_size" in params:
            try:
                self.option_output_tab_size.setValue(int(params["output_tab_size"]))
            except:
                pass
        if "string_escape_char" in params:
            try:
                self.option_string_escape_char.setValue(int(params["string_escape_char"]))
            except:
                pass
        if "string_escape_char2" in params:
            try:
                self.option_string_escape_char2.setValue(int(params["string_escape_char2"]))
            except:
                pass
        if "string_replace_tab_chars" in params:
            try:
                self.option_string_replace_tab_chars.setCurrentText(params["string_replace_tab_chars"])
            except:
                pass
        if "tok_split_gte" in params:
            try:
                self.option_tok_split_gte.setCurrentText(params["tok_split_gte"])
            except:
                pass
        if "disable_processing_nl_cont" in params:
            try:
                self.option_disable_processing_nl_cont.setCurrentText(params["disable_processing_nl_cont"])
            except:
                pass
        if "disable_processing_cmt" in params:
            try:
                self.option_disable_processing_cmt.setText(params["disable_processing_cmt"])
            except:
                pass
        if "enable_processing_cmt" in params:
            try:
                self.option_enable_processing_cmt.setText(params["enable_processing_cmt"])
            except:
                pass
        if "enable_digraphs" in params:
            try:
                self.option_enable_digraphs.setCurrentText(params["enable_digraphs"])
            except:
                pass
        if "processing_cmt_as_regex" in params:
            try:
                self.option_processing_cmt_as_regex.setCurrentText(params["processing_cmt_as_regex"])
            except:
                pass
        if "utf8_bom" in params:
            try:
                self.option_utf8_bom.setCurrentText(params["utf8_bom"])
            except:
                pass
        if "utf8_byte" in params:
            try:
                self.option_utf8_byte.setCurrentText(params["utf8_byte"])
            except:
                pass
        if "utf8_force" in params:
            try:
                self.option_utf8_force.setCurrentText(params["utf8_force"])
            except:
                pass
        #================== Spacing options =================================================================
        if "sp_arith" in params:
            try:
                self.option_sp_arith.setCurrentText(params["sp_arith"])
            except:
                pass
        if "sp_arith_additive" in params:
            try:
                self.option_sp_arith_additive.setCurrentText(params["sp_arith_additive"])
            except:
                pass
        if "sp_assign" in params:
            try:
                self.option_sp_assign.setCurrentText(params["sp_assign"])
            except:
                pass
        if "sp_cpp_lambda_assign" in params:
            try:
                self.option_sp_cpp_lambda_assign.setCurrentText(params["sp_cpp_lambda_assign"])
            except:
                pass
        if "sp_cpp_lambda_square_paren" in params:
            try:
                self.option_sp_cpp_lambda_square_paren.setCurrentText(params["sp_cpp_lambda_square_paren"])
            except:
                pass
        if "sp_cpp_lambda_square_brace" in params:
            try:
                self.option_sp_cpp_lambda_square_brace.setCurrentText(params["sp_cpp_lambda_square_brace"])
            except:
                pass
        if "sp_cpp_lambda_argument_list_empty" in params:
            try:
                self.option_sp_cpp_lambda_argument_list_empty.setCurrentText(params["sp_cpp_lambda_argument_list_empty"])
            except:
                pass
        if "sp_cpp_lambda_argument_list" in params:
            try:
                self.option_sp_cpp_lambda_argument_list.setCurrentText(params["sp_cpp_lambda_argument_list"])
            except:
                pass
        if "sp_cpp_lambda_paren_brace" in params:
            try:
                self.option_sp_cpp_lambda_paren_brace.setCurrentText(params["sp_cpp_lambda_paren_brace"])
            except:
                pass
        if "sp_cpp_lambda_fparen" in params:
            try:
                self.option_sp_cpp_lambda_fparen.setCurrentText(params["sp_cpp_lambda_fparen"])
            except:
                pass
        if "sp_assign_default" in params:
            try:
                self.option_sp_assign_default.setCurrentText(params["sp_assign_default"])
            except:
                pass
        if "sp_before_assign" in params:
            try:
                self.option_sp_before_assign.setCurrentText(params["sp_before_assign"])
            except:
                pass
        if "sp_after_assign" in params:
            try:
                self.option_sp_after_assign.setCurrentText(params["sp_after_assign"])
            except:
                pass
        if "sp_enum_brace" in params:
            try:
                self.option_sp_enum_brace.setCurrentText(params["sp_enum_brace"])
            except:
                pass
        if "sp_enum_paren" in params:
            try:
                self.option_sp_enum_paren.setCurrentText(params["sp_enum_paren"])
            except:
                pass
        if "sp_enum_assign" in params:
            try:
                self.option_sp_enum_assign.setCurrentText(params["sp_enum_assign"])
            except:
                pass
        if "sp_enum_before_assign" in params:
            try:
                self.option_sp_enum_before_assign.setCurrentText(params["sp_enum_before_assign"])
            except:
                pass
        if "sp_enum_after_assign" in params:
            try:
                self.option_sp_enum_after_assign.setCurrentText(params["sp_enum_after_assign"])
            except:
                pass
        if "sp_enum_colon" in params:
            try:
                self.option_sp_enum_colon.setCurrentText(params["sp_enum_colon"])
            except:
                pass
        if "sp_pp_concat" in params:
            try:
                self.option_sp_pp_concat.setCurrentText(params["sp_pp_concat"])
            except:
                pass
        if "sp_pp_stringify" in params:
            try:
                self.option_sp_pp_stringify.setCurrentText(params["sp_pp_stringify"])
            except:
                pass
        if "sp_before_pp_stringify" in params:
            try:
                self.option_sp_before_pp_stringify.setCurrentText(params["sp_before_pp_stringify"])
            except:
                pass
        if "sp_bool" in params:
            try:
                self.option_sp_bool.setCurrentText(params["sp_bool"])
            except:
                pass
        if "sp_compare" in params:
            try:
                self.option_sp_compare.setCurrentText(params["sp_compare"])
            except:
                pass
        if "sp_inside_paren" in params:
            try:
                self.option_sp_inside_paren.setCurrentText(params["sp_inside_paren"])
            except:
                pass
        if "sp_paren_paren" in params:
            try:
                self.option_sp_paren_paren.setCurrentText(params["sp_paren_paren"])
            except:
                pass
        if "sp_cparen_oparen" in params:
            try:
                self.option_sp_cparen_oparen.setCurrentText(params["sp_cparen_oparen"])
            except:
                pass
        if "sp_paren_brace" in params:
            try:
                self.option_sp_paren_brace.setCurrentText(params["sp_paren_brace"])
            except:
                pass
        if "sp_brace_brace" in params:
            try:
                self.option_sp_brace_brace.setCurrentText(params["sp_brace_brace"])
            except:
                pass
        if "sp_before_ptr_star" in params:
            try:
                self.option_sp_before_ptr_star.setCurrentText(params["sp_before_ptr_star"])
            except:
                pass
        if "sp_before_unnamed_ptr_star" in params:
            try:
                self.option_sp_before_unnamed_ptr_star.setCurrentText(params["sp_before_unnamed_ptr_star"])
            except:
                pass
        if "sp_before_qualifier_ptr_star" in params:
            try:
                self.option_sp_before_qualifier_ptr_star.setCurrentText(params["sp_before_qualifier_ptr_star"])
            except:
                pass
        if "sp_before_operator_ptr_star" in params:
            try:
                self.option_sp_before_operator_ptr_star.setCurrentText(params["sp_before_operator_ptr_star"])
            except:
                pass
        if "sp_before_scope_ptr_star" in params:
            try:
                self.option_sp_before_scope_ptr_star.setCurrentText(params["sp_before_scope_ptr_star"])
            except:
                pass
        if "sp_before_global_scope_ptr_star" in params:
            try:
                self.option_sp_before_global_scope_ptr_star.setCurrentText(params["sp_before_global_scope_ptr_star"])
            except:
                pass
        if "sp_qualifier_unnamed_ptr_star" in params:
            try:
                self.option_sp_qualifier_unnamed_ptr_star.setCurrentText(params["sp_qualifier_unnamed_ptr_star"])
            except:
                pass
        if "sp_between_ptr_star" in params:
            try:
                self.option_sp_between_ptr_star.setCurrentText(params["sp_between_ptr_star"])
            except:
                pass
        if "sp_between_ptr_ref" in params:
            try:
                self.option_sp_between_ptr_ref.setCurrentText(params["sp_between_ptr_ref"])
            except:
                pass
        if "sp_after_ptr_star" in params:
            try:
                self.option_sp_after_ptr_star.setCurrentText(params["sp_after_ptr_star"])
            except:
                pass
        if "sp_after_ptr_block_caret" in params:
            try:
                self.option_sp_after_ptr_block_caret.setCurrentText(params["sp_after_ptr_block_caret"])
            except:
                pass
        if "sp_after_ptr_star_qualifier" in params:
            try:
                self.option_sp_after_ptr_star_qualifier.setCurrentText(params["sp_after_ptr_star_qualifier"])
            except:
                pass
        if "sp_after_ptr_star_func" in params:
            try:
                self.option_sp_after_ptr_star_func.setCurrentText(params["sp_after_ptr_star_func"])
            except:
                pass
        if "sp_after_ptr_star_trailing" in params:
            try:
                self.option_sp_after_ptr_star_trailing.setCurrentText(params["sp_after_ptr_star_trailing"])
            except:
                pass
        if "sp_ptr_star_func_var" in params:
            try:
                self.option_sp_ptr_star_func_var.setCurrentText(params["sp_ptr_star_func_var"])
            except:
                pass
        if "sp_ptr_star_func_type" in params:
            try:
                self.option_sp_ptr_star_func_type.setCurrentText(params["sp_ptr_star_func_type"])
            except:
                pass
        if "sp_ptr_star_paren" in params:
            try:
                self.option_sp_ptr_star_paren.setCurrentText(params["sp_ptr_star_paren"])
            except:
                pass
        if "sp_before_ptr_star_func" in params:
            try:
                self.option_sp_before_ptr_star_func.setCurrentText(params["sp_before_ptr_star_func"])
            except:
                pass
        if "sp_qualifier_ptr_star_func" in params:
            try:
                self.option_sp_qualifier_ptr_star_func.setCurrentText(params["sp_qualifier_ptr_star_func"])
            except:
                pass
        if "sp_before_ptr_star_trailing" in params:
            try:
                self.option_sp_before_ptr_star_trailing.setCurrentText(params["sp_before_ptr_star_trailing"])
            except:
                pass
        if "sp_qualifier_ptr_star_trailing" in params:
            try:
                self.option_sp_qualifier_ptr_star_trailing.setCurrentText(params["sp_qualifier_ptr_star_trailing"])
            except:
                pass
        if "sp_before_byref" in params:
            try:
                self.option_sp_before_byref.setCurrentText(params["sp_before_byref"])
            except:
                pass
        if "sp_before_unnamed_byref" in params:
            try:
                self.option_sp_before_unnamed_byref.setCurrentText(params["sp_before_unnamed_byref"])
            except:
                pass
        if "sp_after_byref" in params:
            try:
                self.option_sp_after_byref.setCurrentText(params["sp_after_byref"])
            except:
                pass
        if "sp_after_byref_func" in params:
            try:
                self.option_sp_after_byref_func.setCurrentText(params["sp_after_byref_func"])
            except:
                pass
        if "sp_before_byref_func" in params:
            try:
                self.option_sp_before_byref_func.setCurrentText(params["sp_before_byref_func"])
            except:
                pass
        if "sp_byref_paren" in params:
            try:
                self.option_sp_byref_paren.setCurrentText(params["sp_byref_paren"])
            except:
                pass
        if "sp_after_type" in params:
            try:
                self.option_sp_after_type.setCurrentText(params["sp_after_type"])
            except:
                pass
        if "sp_after_decltype" in params:
            try:
                self.option_sp_after_decltype.setCurrentText(params["sp_after_decltype"])
            except:
                pass
        if "sp_before_template_paren" in params:
            try:
                self.option_sp_before_template_paren.setCurrentText(params["sp_before_template_paren"])
            except:
                pass
        if "sp_template_angle" in params:
            try:
                self.option_sp_template_angle.setCurrentText(params["sp_template_angle"])
            except:
                pass
        if "sp_before_angle" in params:
            try:
                self.option_sp_before_angle.setCurrentText(params["sp_before_angle"])
            except:
                pass
        if "sp_inside_angle" in params:
            try:
                self.option_sp_inside_angle.setCurrentText(params["sp_inside_angle"])
            except:
                pass
        if "sp_inside_angle_empty" in params:
            try:
                self.option_sp_inside_angle_empty.setCurrentText(params["sp_inside_angle_empty"])
            except:
                pass
        if "sp_angle_colon" in params:
            try:
                self.option_sp_angle_colon.setCurrentText(params["sp_angle_colon"])
            except:
                pass
        if "sp_after_angle" in params:
            try:
                self.option_sp_after_angle.setCurrentText(params["sp_after_angle"])
            except:
                pass
        if "sp_angle_paren" in params:
            try:
                self.option_sp_angle_paren.setCurrentText(params["sp_angle_paren"])
            except:
                pass
        if "sp_angle_paren_empty" in params:
            try:
                self.option_sp_angle_paren_empty.setCurrentText(params["sp_angle_paren_empty"])
            except:
                pass
        if "sp_angle_word" in params:
            try:
                self.option_sp_angle_word.setCurrentText(params["sp_angle_word"])
            except:
                pass
        if "sp_angle_shift" in params:
            try:
                self.option_sp_angle_shift.setCurrentText(params["sp_angle_shift"])
            except:
                pass
        if "sp_permit_cpp11_shift" in params:
            try:
                self.option_sp_permit_cpp11_shift.setCurrentText(params["sp_permit_cpp11_shift"])
            except:
                pass
        if "sp_before_sparen" in params:
            try:
                self.option_sp_before_sparen.setCurrentText(params["sp_before_sparen"])
            except:
                pass
        if "sp_inside_sparen" in params:
            try:
                self.option_sp_inside_sparen.setCurrentText(params["sp_inside_sparen"])
            except:
                pass
        if "sp_inside_sparen_open" in params:
            try:
                self.option_sp_inside_sparen_open.setCurrentText(params["sp_inside_sparen_open"])
            except:
                pass
        if "sp_inside_sparen_close" in params:
            try:
                self.option_sp_inside_sparen_close.setCurrentText(params["sp_inside_sparen_close"])
            except:
                pass
        if "sp_inside_for" in params:
            try:
                self.option_sp_inside_for.setCurrentText(params["sp_inside_for"])
            except:
                pass
        if "sp_inside_for_open" in params:
            try:
                self.option_sp_inside_for_open.setCurrentText(params["sp_inside_for_open"])
            except:
                pass
        if "sp_inside_for_close" in params:
            try:
                self.option_sp_inside_for_close.setCurrentText(params["sp_inside_for_close"])
            except:
                pass
        if "sp_sparen_paren" in params:
            try:
                self.option_sp_sparen_paren.setCurrentText(params["sp_sparen_paren"])
            except:
                pass
        if "sp_after_sparen" in params:
            try:
                self.option_sp_after_sparen.setCurrentText(params["sp_after_sparen"])
            except:
                pass
        if "sp_sparen_brace" in params:
            try:
                self.option_sp_sparen_brace.setCurrentText(params["sp_sparen_brace"])
            except:
                pass
        if "sp_do_brace_open" in params:
            try:
                self.option_sp_do_brace_open.setCurrentText(params["sp_do_brace_open"])
            except:
                pass
        if "sp_brace_close_while" in params:
            try:
                self.option_sp_brace_close_while.setCurrentText(params["sp_brace_close_while"])
            except:
                pass
        if "sp_while_paren_open" in params:
            try:
                self.option_sp_while_paren_open.setCurrentText(params["sp_while_paren_open"])
            except:
                pass
        if "sp_invariant_paren" in params:
            try:
                self.option_sp_invariant_paren.setCurrentText(params["sp_invariant_paren"])
            except:
                pass
        if "sp_after_invariant_paren" in params:
            try:
                self.option_sp_after_invariant_paren.setCurrentText(params["sp_after_invariant_paren"])
            except:
                pass
        if "sp_special_semi" in params:
            try:
                self.option_sp_special_semi.setCurrentText(params["sp_special_semi"])
            except:
                pass
        if "sp_before_semi" in params:
            try:
                self.option_sp_before_semi.setCurrentText(params["sp_before_semi"])
            except:
                pass
        if "sp_before_semi_for" in params:
            try:
                self.option_sp_before_semi_for.setCurrentText(params["sp_before_semi_for"])
            except:
                pass
        if "sp_before_semi_for_empty" in params:
            try:
                self.option_sp_before_semi_for_empty.setCurrentText(params["sp_before_semi_for_empty"])
            except:
                pass
        if "sp_between_semi_for_empty" in params:
            try:
                self.option_sp_between_semi_for_empty.setCurrentText(params["sp_between_semi_for_empty"])
            except:
                pass
        if "sp_after_semi" in params:
            try:
                self.option_sp_after_semi.setCurrentText(params["sp_after_semi"])
            except:
                pass
        if "sp_after_semi_for" in params:
            try:
                self.option_sp_after_semi_for.setCurrentText(params["sp_after_semi_for"])
            except:
                pass
        if "sp_after_semi_for_empty" in params:
            try:
                self.option_sp_after_semi_for_empty.setCurrentText(params["sp_after_semi_for_empty"])
            except:
                pass
        if "sp_before_square" in params:
            try:
                self.option_sp_before_square.setCurrentText(params["sp_before_square"])
            except:
                pass
        if "sp_before_vardef_square" in params:
            try:
                self.option_sp_before_vardef_square.setCurrentText(params["sp_before_vardef_square"])
            except:
                pass
        if "sp_before_square_asm_block" in params:
            try:
                self.option_sp_before_square_asm_block.setCurrentText(params["sp_before_square_asm_block"])
            except:
                pass
        if "sp_before_squares" in params:
            try:
                self.option_sp_before_squares.setCurrentText(params["sp_before_squares"])
            except:
                pass
        if "sp_cpp_before_struct_binding_after_byref" in params:
            try:
                self.option_sp_cpp_before_struct_binding_after_byref.setCurrentText(params["sp_cpp_before_struct_binding_after_byref"])
            except:
                pass
        if "sp_cpp_before_struct_binding" in params:
            try:
                self.option_sp_cpp_before_struct_binding.setCurrentText(params["sp_cpp_before_struct_binding"])
            except:
                pass
        if "sp_inside_square" in params:
            try:
                self.option_sp_inside_square.setCurrentText(params["sp_inside_square"])
            except:
                pass
        if "sp_inside_square_empty" in params:
            try:
                self.option_sp_inside_square_empty.setCurrentText(params["sp_inside_square_empty"])
            except:
                pass
        if "sp_inside_square_oc_array" in params:
            try:
                self.option_sp_inside_square_oc_array.setCurrentText(params["sp_inside_square_oc_array"])
            except:
                pass
        if "sp_after_comma" in params:
            try:
                self.option_sp_after_comma.setCurrentText(params["sp_after_comma"])
            except:
                pass
        if "sp_before_comma" in params:
            try:
                self.option_sp_before_comma.setCurrentText(params["sp_before_comma"])
            except:
                pass
        if "sp_after_mdatype_commas" in params:
            try:
                self.option_sp_after_mdatype_commas.setCurrentText(params["sp_after_mdatype_commas"])
            except:
                pass
        if "sp_before_mdatype_commas" in params:
            try:
                self.option_sp_before_mdatype_commas.setCurrentText(params["sp_before_mdatype_commas"])
            except:
                pass
        if "sp_between_mdatype_commas" in params:
            try:
                self.option_sp_between_mdatype_commas.setCurrentText(params["sp_between_mdatype_commas"])
            except:
                pass
        if "sp_paren_comma" in params:
            try:
                self.option_sp_paren_comma.setCurrentText(params["sp_paren_comma"])
            except:
                pass
        if "sp_type_colon" in params:
            try:
                self.option_sp_type_colon.setCurrentText(params["sp_type_colon"])
            except:
                pass
        if "sp_after_ellipsis" in params:
            try:
                self.option_sp_after_ellipsis.setCurrentText(params["sp_after_ellipsis"])
            except:
                pass
        if "sp_before_ellipsis" in params:
            try:
                self.option_sp_before_ellipsis.setCurrentText(params["sp_before_ellipsis"])
            except:
                pass
        if "sp_type_ellipsis" in params:
            try:
                self.option_sp_type_ellipsis.setCurrentText(params["sp_type_ellipsis"])
            except:
                pass
        if "sp_ptr_type_ellipsis" in params:
            try:
                self.option_sp_ptr_type_ellipsis.setCurrentText(params["sp_ptr_type_ellipsis"])
            except:
                pass
        if "sp_paren_ellipsis" in params:
            try:
                self.option_sp_paren_ellipsis.setCurrentText(params["sp_paren_ellipsis"])
            except:
                pass
        if "sp_byref_ellipsis" in params:
            try:
                self.option_sp_byref_ellipsis.setCurrentText(params["sp_byref_ellipsis"])
            except:
                pass
        if "sp_paren_qualifier" in params:
            try:
                self.option_sp_paren_qualifier.setCurrentText(params["sp_paren_qualifier"])
            except:
                pass
        if "sp_paren_noexcept" in params:
            try:
                self.option_sp_paren_noexcept.setCurrentText(params["sp_paren_noexcept"])
            except:
                pass
        if "sp_after_class_colon" in params:
            try:
                self.option_sp_after_class_colon.setCurrentText(params["sp_after_class_colon"])
            except:
                pass
        if "sp_before_class_colon" in params:
            try:
                self.option_sp_before_class_colon.setCurrentText(params["sp_before_class_colon"])
            except:
                pass
        if "sp_after_constr_colon" in params:
            try:
                self.option_sp_after_constr_colon.setCurrentText(params["sp_after_constr_colon"])
            except:
                pass
        if "sp_before_constr_colon" in params:
            try:
                self.option_sp_before_constr_colon.setCurrentText(params["sp_before_constr_colon"])
            except:
                pass
        if "sp_before_case_colon" in params:
            try:
                self.option_sp_before_case_colon.setCurrentText(params["sp_before_case_colon"])
            except:
                pass
        if "sp_after_operator" in params:
            try:
                self.option_sp_after_operator.setCurrentText(params["sp_after_operator"])
            except:
                pass
        if "sp_after_operator_sym" in params:
            try:
                self.option_sp_after_operator_sym.setCurrentText(params["sp_after_operator_sym"])
            except:
                pass
        if "sp_after_operator_sym_empty" in params:
            try:
                self.option_sp_after_operator_sym_empty.setCurrentText(params["sp_after_operator_sym_empty"])
            except:
                pass
        if "sp_after_cast" in params:
            try:
                self.option_sp_after_cast.setCurrentText(params["sp_after_cast"])
            except:
                pass
        if "sp_inside_paren_cast" in params:
            try:
                self.option_sp_inside_paren_cast.setCurrentText(params["sp_inside_paren_cast"])
            except:
                pass
        if "sp_cpp_cast_paren" in params:
            try:
                self.option_sp_cpp_cast_paren.setCurrentText(params["sp_cpp_cast_paren"])
            except:
                pass
        if "sp_sizeof_paren" in params:
            try:
                self.option_sp_sizeof_paren.setCurrentText(params["sp_sizeof_paren"])
            except:
                pass
        if "sp_sizeof_ellipsis" in params:
            try:
                self.option_sp_sizeof_ellipsis.setCurrentText(params["sp_sizeof_ellipsis"])
            except:
                pass
        if "sp_sizeof_ellipsis_paren" in params:
            try:
                self.option_sp_sizeof_ellipsis_paren.setCurrentText(params["sp_sizeof_ellipsis_paren"])
            except:
                pass
        if "sp_ellipsis_parameter_pack" in params:
            try:
                self.option_sp_ellipsis_parameter_pack.setCurrentText(params["sp_ellipsis_parameter_pack"])
            except:
                pass
        if "sp_parameter_pack_ellipsis" in params:
            try:
                self.option_sp_parameter_pack_ellipsis.setCurrentText(params["sp_parameter_pack_ellipsis"])
            except:
                pass
        if "sp_decltype_paren" in params:
            try:
                self.option_sp_decltype_paren.setCurrentText(params["sp_decltype_paren"])
            except:
                pass
        if "sp_after_tag" in params:
            try:
                self.option_sp_after_tag.setCurrentText(params["sp_after_tag"])
            except:
                pass
        if "sp_inside_braces_enum" in params:
            try:
                self.option_sp_inside_braces_enum.setCurrentText(params["sp_inside_braces_enum"])
            except:
                pass
        if "sp_inside_braces_struct" in params:
            try:
                self.option_sp_inside_braces_struct.setCurrentText(params["sp_inside_braces_struct"])
            except:
                pass
        if "sp_inside_braces_oc_dict" in params:
            try:
                self.option_sp_inside_braces_oc_dict.setCurrentText(params["sp_inside_braces_oc_dict"])
            except:
                pass
        if "sp_after_type_brace_init_lst_open" in params:
            try:
                self.option_sp_after_type_brace_init_lst_open.setCurrentText(params["sp_after_type_brace_init_lst_open"])
            except:
                pass
        if "sp_before_type_brace_init_lst_close" in params:
            try:
                self.option_sp_before_type_brace_init_lst_close.setCurrentText(params["sp_before_type_brace_init_lst_close"])
            except:
                pass
        if "sp_inside_type_brace_init_lst" in params:
            try:
                self.option_sp_inside_type_brace_init_lst.setCurrentText(params["sp_inside_type_brace_init_lst"])
            except:
                pass
        if "sp_inside_braces" in params:
            try:
                self.option_sp_inside_braces.setCurrentText(params["sp_inside_braces"])
            except:
                pass
        if "sp_inside_braces_empty" in params:
            try:
                self.option_sp_inside_braces_empty.setCurrentText(params["sp_inside_braces_empty"])
            except:
                pass
        if "sp_trailing_return" in params:
            try:
                self.option_sp_trailing_return.setCurrentText(params["sp_trailing_return"])
            except:
                pass
        if "sp_type_func" in params:
            try:
                self.option_sp_type_func.setCurrentText(params["sp_type_func"])
            except:
                pass
        if "sp_type_brace_init_lst" in params:
            try:
                self.option_sp_type_brace_init_lst.setCurrentText(params["sp_type_brace_init_lst"])
            except:
                pass
        if "sp_func_proto_paren" in params:
            try:
                self.option_sp_func_proto_paren.setCurrentText(params["sp_func_proto_paren"])
            except:
                pass
        if "sp_func_proto_paren_empty" in params:
            try:
                self.option_sp_func_proto_paren_empty.setCurrentText(params["sp_func_proto_paren_empty"])
            except:
                pass
        if "sp_func_type_paren" in params:
            try:
                self.option_sp_func_type_paren.setCurrentText(params["sp_func_type_paren"])
            except:
                pass
        if "sp_func_def_paren" in params:
            try:
                self.option_sp_func_def_paren.setCurrentText(params["sp_func_def_paren"])
            except:
                pass
        if "sp_func_def_paren_empty" in params:
            try:
                self.option_sp_func_def_paren_empty.setCurrentText(params["sp_func_def_paren_empty"])
            except:
                pass
        if "sp_inside_fparens" in params:
            try:
                self.option_sp_inside_fparens.setCurrentText(params["sp_inside_fparens"])
            except:
                pass
        if "sp_inside_fparen" in params:
            try:
                self.option_sp_inside_fparen.setCurrentText(params["sp_inside_fparen"])
            except:
                pass
        if "sp_func_call_user_inside_rparen" in params:
            try:
                self.option_sp_func_call_user_inside_rparen.setCurrentText(params["sp_func_call_user_inside_rparen"])
            except:
                pass
        if "sp_inside_rparens" in params:
            try:
                self.option_sp_inside_rparens.setCurrentText(params["sp_inside_rparens"])
            except:
                pass
        if "sp_inside_rparen" in params:
            try:
                self.option_sp_inside_rparen.setCurrentText(params["sp_inside_rparen"])
            except:
                pass
        if "sp_inside_tparen" in params:
            try:
                self.option_sp_inside_tparen.setCurrentText(params["sp_inside_tparen"])
            except:
                pass
        if "sp_after_tparen_close" in params:
            try:
                self.option_sp_after_tparen_close.setCurrentText(params["sp_after_tparen_close"])
            except:
                pass
        if "sp_square_fparen" in params:
            try:
                self.option_sp_square_fparen.setCurrentText(params["sp_square_fparen"])
            except:
                pass
        if "sp_fparen_brace" in params:
            try:
                self.option_sp_fparen_brace.setCurrentText(params["sp_fparen_brace"])
            except:
                pass
        if "sp_fparen_brace_initializer" in params:
            try:
                self.option_sp_fparen_brace_initializer.setCurrentText(params["sp_fparen_brace_initializer"])
            except:
                pass
        if "sp_fparen_dbrace" in params:
            try:
                self.option_sp_fparen_dbrace.setCurrentText(params["sp_fparen_dbrace"])
            except:
                pass
        if "sp_func_call_paren" in params:
            try:
                self.option_sp_func_call_paren.setCurrentText(params["sp_func_call_paren"])
            except:
                pass
        if "sp_func_call_paren_empty" in params:
            try:
                self.option_sp_func_call_paren_empty.setCurrentText(params["sp_func_call_paren_empty"])
            except:
                pass
        if "sp_func_call_user_paren" in params:
            try:
                self.option_sp_func_call_user_paren.setCurrentText(params["sp_func_call_user_paren"])
            except:
                pass
        if "sp_func_call_user_inside_fparen" in params:
            try:
                self.option_sp_func_call_user_inside_fparen.setCurrentText(params["sp_func_call_user_inside_fparen"])
            except:
                pass
        if "sp_func_call_user_paren_paren" in params:
            try:
                self.option_sp_func_call_user_paren_paren.setCurrentText(params["sp_func_call_user_paren_paren"])
            except:
                pass
        if "sp_func_class_paren" in params:
            try:
                self.option_sp_func_class_paren.setCurrentText(params["sp_func_class_paren"])
            except:
                pass
        if "sp_func_class_paren_empty" in params:
            try:
                self.option_sp_func_class_paren_empty.setCurrentText(params["sp_func_class_paren_empty"])
            except:
                pass
        if "sp_return" in params:
            try:
                self.option_sp_return.setCurrentText(params["sp_return"])
            except:
                pass
        if "sp_return_paren" in params:
            try:
                self.option_sp_return_paren.setCurrentText(params["sp_return_paren"])
            except:
                pass
        if "sp_return_brace" in params:
            try:
                self.option_sp_return_brace.setCurrentText(params["sp_return_brace"])
            except:
                pass
        if "sp_attribute_paren" in params:
            try:
                self.option_sp_attribute_paren.setCurrentText(params["sp_attribute_paren"])
            except:
                pass
        if "sp_defined_paren" in params:
            try:
                self.option_sp_defined_paren.setCurrentText(params["sp_defined_paren"])
            except:
                pass
        if "sp_throw_paren" in params:
            try:
                self.option_sp_throw_paren.setCurrentText(params["sp_throw_paren"])
            except:
                pass
        if "sp_after_throw" in params:
            try:
                self.option_sp_after_throw.setCurrentText(params["sp_after_throw"])
            except:
                pass
        if "sp_catch_paren" in params:
            try:
                self.option_sp_catch_paren.setCurrentText(params["sp_catch_paren"])
            except:
                pass
        if "sp_oc_catch_paren" in params:
            try:
                self.option_sp_oc_catch_paren.setCurrentText(params["sp_oc_catch_paren"])
            except:
                pass
        if "sp_before_oc_proto_list" in params:
            try:
                self.option_sp_before_oc_proto_list.setCurrentText(params["sp_before_oc_proto_list"])
            except:
                pass
        if "sp_oc_classname_paren" in params:
            try:
                self.option_sp_oc_classname_paren.setCurrentText(params["sp_oc_classname_paren"])
            except:
                pass
        if "sp_version_paren" in params:
            try:
                self.option_sp_version_paren.setCurrentText(params["sp_version_paren"])
            except:
                pass
        if "sp_scope_paren" in params:
            try:
                self.option_sp_scope_paren.setCurrentText(params["sp_scope_paren"])
            except:
                pass
        if "sp_super_paren" in params:
            try:
                self.option_sp_super_paren.setCurrentText(params["sp_super_paren"])
            except:
                pass
        if "sp_this_paren" in params:
            try:
                self.option_sp_this_paren.setCurrentText(params["sp_this_paren"])
            except:
                pass
        if "sp_macro" in params:
            try:
                self.option_sp_macro.setCurrentText(params["sp_macro"])
            except:
                pass
        if "sp_macro_func" in params:
            try:
                self.option_sp_macro_func.setCurrentText(params["sp_macro_func"])
            except:
                pass
        if "sp_else_brace" in params:
            try:
                self.option_sp_else_brace.setCurrentText(params["sp_else_brace"])
            except:
                pass
        if "sp_brace_else" in params:
            try:
                self.option_sp_brace_else.setCurrentText(params["sp_brace_else"])
            except:
                pass
        if "sp_brace_typedef" in params:
            try:
                self.option_sp_brace_typedef.setCurrentText(params["sp_brace_typedef"])
            except:
                pass
        if "sp_catch_brace" in params:
            try:
                self.option_sp_catch_brace.setCurrentText(params["sp_catch_brace"])
            except:
                pass
        if "sp_oc_catch_brace" in params:
            try:
                self.option_sp_oc_catch_brace.setCurrentText(params["sp_oc_catch_brace"])
            except:
                pass
        if "sp_brace_catch" in params:
            try:
                self.option_sp_brace_catch.setCurrentText(params["sp_brace_catch"])
            except:
                pass
        if "sp_oc_brace_catch" in params:
            try:
                self.option_sp_oc_brace_catch.setCurrentText(params["sp_oc_brace_catch"])
            except:
                pass
        if "sp_finally_brace" in params:
            try:
                self.option_sp_finally_brace.setCurrentText(params["sp_finally_brace"])
            except:
                pass
        if "sp_brace_finally" in params:
            try:
                self.option_sp_brace_finally.setCurrentText(params["sp_brace_finally"])
            except:
                pass
        if "sp_try_brace" in params:
            try:
                self.option_sp_try_brace.setCurrentText(params["sp_try_brace"])
            except:
                pass
        if "sp_getset_brace" in params:
            try:
                self.option_sp_getset_brace.setCurrentText(params["sp_getset_brace"])
            except:
                pass
        if "sp_word_brace_init_lst" in params:
            try:
                self.option_sp_word_brace_init_lst.setCurrentText(params["sp_word_brace_init_lst"])
            except:
                pass
        if "sp_word_brace_ns" in params:
            try:
                self.option_sp_word_brace_ns.setCurrentText(params["sp_word_brace_ns"])
            except:
                pass
        if "sp_before_dc" in params:
            try:
                self.option_sp_before_dc.setCurrentText(params["sp_before_dc"])
            except:
                pass
        if "sp_after_dc" in params:
            try:
                self.option_sp_after_dc.setCurrentText(params["sp_after_dc"])
            except:
                pass
        if "sp_d_array_colon" in params:
            try:
                self.option_sp_d_array_colon.setCurrentText(params["sp_d_array_colon"])
            except:
                pass
        if "sp_not" in params:
            try:
                self.option_sp_not.setCurrentText(params["sp_not"])
            except:
                pass
        if "sp_not_not" in params:
            try:
                self.option_sp_not_not.setCurrentText(params["sp_not_not"])
            except:
                pass
        if "sp_inv" in params:
            try:
                self.option_sp_inv.setCurrentText(params["sp_inv"])
            except:
                pass
        if "sp_addr" in params:
            try:
                self.option_sp_addr.setCurrentText(params["sp_addr"])
            except:
                pass
        if "sp_member" in params:
            try:
                self.option_sp_member.setCurrentText(params["sp_member"])
            except:
                pass
        if "sp_deref" in params:
            try:
                self.option_sp_deref.setCurrentText(params["sp_deref"])
            except:
                pass
        if "sp_sign" in params:
            try:
                self.option_sp_sign.setCurrentText(params["sp_sign"])
            except:
                pass
        if "sp_incdec" in params:
            try:
                self.option_sp_incdec.setCurrentText(params["sp_incdec"])
            except:
                pass
        if "sp_before_nl_cont" in params:
            try:
                self.option_sp_before_nl_cont.setCurrentText(params["sp_before_nl_cont"])
            except:
                pass
        if "sp_after_oc_scope" in params:
            try:
                self.option_sp_after_oc_scope.setCurrentText(params["sp_after_oc_scope"])
            except:
                pass
        if "sp_after_oc_colon" in params:
            try:
                self.option_sp_after_oc_colon.setCurrentText(params["sp_after_oc_colon"])
            except:
                pass
        if "sp_before_oc_colon" in params:
            try:
                self.option_sp_before_oc_colon.setCurrentText(params["sp_before_oc_colon"])
            except:
                pass
        if "sp_after_oc_dict_colon" in params:
            try:
                self.option_sp_after_oc_dict_colon.setCurrentText(params["sp_after_oc_dict_colon"])
            except:
                pass
        if "sp_before_oc_dict_colon" in params:
            try:
                self.option_sp_before_oc_dict_colon.setCurrentText(params["sp_before_oc_dict_colon"])
            except:
                pass
        if "sp_after_send_oc_colon" in params:
            try:
                self.option_sp_after_send_oc_colon.setCurrentText(params["sp_after_send_oc_colon"])
            except:
                pass
        if "sp_before_send_oc_colon" in params:
            try:
                self.option_sp_before_send_oc_colon.setCurrentText(params["sp_before_send_oc_colon"])
            except:
                pass
        if "sp_after_oc_type" in params:
            try:
                self.option_sp_after_oc_type.setCurrentText(params["sp_after_oc_type"])
            except:
                pass
        if "sp_after_oc_return_type" in params:
            try:
                self.option_sp_after_oc_return_type.setCurrentText(params["sp_after_oc_return_type"])
            except:
                pass
        if "sp_after_oc_at_sel" in params:
            try:
                self.option_sp_after_oc_at_sel.setCurrentText(params["sp_after_oc_at_sel"])
            except:
                pass
        if "sp_after_oc_at_sel_parens" in params:
            try:
                self.option_sp_after_oc_at_sel_parens.setCurrentText(params["sp_after_oc_at_sel_parens"])
            except:
                pass
        if "sp_inside_oc_at_sel_parens" in params:
            try:
                self.option_sp_inside_oc_at_sel_parens.setCurrentText(params["sp_inside_oc_at_sel_parens"])
            except:
                pass
        if "sp_before_oc_block_caret" in params:
            try:
                self.option_sp_before_oc_block_caret.setCurrentText(params["sp_before_oc_block_caret"])
            except:
                pass
        if "sp_after_oc_block_caret" in params:
            try:
                self.option_sp_after_oc_block_caret.setCurrentText(params["sp_after_oc_block_caret"])
            except:
                pass
        if "sp_after_oc_msg_receiver" in params:
            try:
                self.option_sp_after_oc_msg_receiver.setCurrentText(params["sp_after_oc_msg_receiver"])
            except:
                pass
        if "sp_after_oc_property" in params:
            try:
                self.option_sp_after_oc_property.setCurrentText(params["sp_after_oc_property"])
            except:
                pass
        if "sp_after_oc_synchronized" in params:
            try:
                self.option_sp_after_oc_synchronized.setCurrentText(params["sp_after_oc_synchronized"])
            except:
                pass
        if "sp_cond_colon" in params:
            try:
                self.option_sp_cond_colon.setCurrentText(params["sp_cond_colon"])
            except:
                pass
        if "sp_cond_colon_before" in params:
            try:
                self.option_sp_cond_colon_before.setCurrentText(params["sp_cond_colon_before"])
            except:
                pass
        if "sp_cond_colon_after" in params:
            try:
                self.option_sp_cond_colon_after.setCurrentText(params["sp_cond_colon_after"])
            except:
                pass
        if "sp_cond_question" in params:
            try:
                self.option_sp_cond_question.setCurrentText(params["sp_cond_question"])
            except:
                pass
        if "sp_cond_question_before" in params:
            try:
                self.option_sp_cond_question_before.setCurrentText(params["sp_cond_question_before"])
            except:
                pass
        if "sp_cond_question_after" in params:
            try:
                self.option_sp_cond_question_after.setCurrentText(params["sp_cond_question_after"])
            except:
                pass
        if "sp_cond_ternary_short" in params:
            try:
                self.option_sp_cond_ternary_short.setCurrentText(params["sp_cond_ternary_short"])
            except:
                pass
        if "sp_case_label" in params:
            try:
                self.option_sp_case_label.setCurrentText(params["sp_case_label"])
            except:
                pass
        if "sp_range" in params:
            try:
                self.option_sp_range.setCurrentText(params["sp_range"])
            except:
                pass
        if "sp_after_for_colon" in params:
            try:
                self.option_sp_after_for_colon.setCurrentText(params["sp_after_for_colon"])
            except:
                pass
        if "sp_before_for_colon" in params:
            try:
                self.option_sp_before_for_colon.setCurrentText(params["sp_before_for_colon"])
            except:
                pass
        if "sp_extern_paren" in params:
            try:
                self.option_sp_extern_paren.setCurrentText(params["sp_extern_paren"])
            except:
                pass
        if "sp_cmt_cpp_start" in params:
            try:
                self.option_sp_cmt_cpp_start.setCurrentText(params["sp_cmt_cpp_start"])
            except:
                pass
        if "sp_cmt_cpp_pvs" in params:
            try:
                self.option_sp_cmt_cpp_pvs.setCurrentText(params["sp_cmt_cpp_pvs"])
            except:
                pass
        if "sp_cmt_cpp_lint" in params:
            try:
                self.option_sp_cmt_cpp_lint.setCurrentText(params["sp_cmt_cpp_lint"])
            except:
                pass
        if "sp_cmt_cpp_region" in params:
            try:
                self.option_sp_cmt_cpp_region.setCurrentText(params["sp_cmt_cpp_region"])
            except:
                pass
        if "sp_cmt_cpp_doxygen" in params:
            try:
                self.option_sp_cmt_cpp_doxygen.setCurrentText(params["sp_cmt_cpp_doxygen"])
            except:
                pass
        if "sp_cmt_cpp_qttr" in params:
            try:
                self.option_sp_cmt_cpp_qttr.setCurrentText(params["sp_cmt_cpp_qttr"])
            except:
                pass
        if "sp_endif_cmt" in params:
            try:
                self.option_sp_endif_cmt.setCurrentText(params["sp_endif_cmt"])
            except:
                pass
        if "sp_after_new" in params:
            try:
                self.option_sp_after_new.setCurrentText(params["sp_after_new"])
            except:
                pass
        if "sp_between_new_paren" in params:
            try:
                self.option_sp_between_new_paren.setCurrentText(params["sp_between_new_paren"])
            except:
                pass
        if "sp_after_newop_paren" in params:
            try:
                self.option_sp_after_newop_paren.setCurrentText(params["sp_after_newop_paren"])
            except:
                pass
        if "sp_inside_newop_paren" in params:
            try:
                self.option_sp_inside_newop_paren.setCurrentText(params["sp_inside_newop_paren"])
            except:
                pass
        if "sp_inside_newop_paren_open" in params:
            try:
                self.option_sp_inside_newop_paren_open.setCurrentText(params["sp_inside_newop_paren_open"])
            except:
                pass
        if "sp_inside_newop_paren_close" in params:
            try:
                self.option_sp_inside_newop_paren_close.setCurrentText(params["sp_inside_newop_paren_close"])
            except:
                pass
        if "sp_before_tr_cmt" in params:
            try:
                self.option_sp_before_tr_cmt.setCurrentText(params["sp_before_tr_cmt"])
            except:
                pass
        if "sp_num_before_tr_cmt" in params:
            try:
                self.option_sp_num_before_tr_cmt.setValue(int(params["sp_num_before_tr_cmt"]))
            except:
                pass
        if "sp_before_emb_cmt" in params:
            try:
                self.option_sp_before_emb_cmt.setCurrentText(params["sp_before_emb_cmt"])
            except:
                pass
        if "sp_num_before_emb_cmt" in params:
            try:
                self.option_sp_num_before_emb_cmt.setValue(int(params["sp_num_before_emb_cmt"]))
            except:
                pass
        if "sp_after_emb_cmt" in params:
            try:
                self.option_sp_after_emb_cmt.setCurrentText(params["sp_after_emb_cmt"])
            except:
                pass
        if "sp_num_after_emb_cmt" in params:
            try:
                self.option_sp_num_after_emb_cmt.setValue(int(params["sp_num_after_emb_cmt"]))
            except:
                pass
        if "sp_emb_cmt_priority" in params:
            try:
                self.option_sp_emb_cmt_priority.setCurrentText(params["sp_emb_cmt_priority"])
            except:
                pass
        if "sp_annotation_paren" in params:
            try:
                self.option_sp_annotation_paren.setCurrentText(params["sp_annotation_paren"])
            except:
                pass
        if "sp_skip_vbrace_tokens" in params:
            try:
                self.option_sp_skip_vbrace_tokens.setCurrentText(params["sp_skip_vbrace_tokens"])
            except:
                pass
        if "sp_after_noexcept" in params:
            try:
                self.option_sp_after_noexcept.setCurrentText(params["sp_after_noexcept"])
            except:
                pass
        if "sp_vala_after_translation" in params:
            try:
                self.option_sp_vala_after_translation.setCurrentText(params["sp_vala_after_translation"])
            except:
                pass
        if "sp_before_bit_colon" in params:
            try:
                self.option_sp_before_bit_colon.setCurrentText(params["sp_before_bit_colon"])
            except:
                pass
        if "sp_after_bit_colon" in params:
            try:
                self.option_sp_after_bit_colon.setCurrentText(params["sp_after_bit_colon"])
            except:
                pass
        if "force_tab_after_define" in params:
            try:
                self.option_force_tab_after_define.setCurrentText(params["force_tab_after_define"])
            except:
                pass
        if "sp_string_string" in params:
            try:
                self.option_sp_string_string.setCurrentText(params["sp_string_string"])
            except:
                pass
        if "sp_struct_type" in params:
            try:
                self.option_sp_struct_type.setCurrentText(params["sp_struct_type"])
            except:
                pass
        #================== Indenting options ===============================================================
        if "indent_columns" in params:
            try:
                self.option_indent_columns.setValue(int(params["indent_columns"]))
            except:
                pass
        if "indent_ignore_first_continue" in params:
            try:
                self.option_indent_ignore_first_continue.setCurrentText(params["indent_ignore_first_continue"])
            except:
                pass
        if "indent_continue" in params:
            try:
                self.option_indent_continue.setValue(int(params["indent_continue"]))
            except:
                pass
        if "indent_continue_class_head" in params:
            try:
                self.option_indent_continue_class_head.setValue(int(params["indent_continue_class_head"]))
            except:
                pass
        if "indent_single_newlines" in params:
            try:
                self.option_indent_single_newlines.setCurrentText(params["indent_single_newlines"])
            except:
                pass
        if "indent_param" in params:
            try:
                self.option_indent_param.setValue(int(params["indent_param"]))
            except:
                pass
        if "indent_with_tabs" in params:
            try:
                self.option_indent_with_tabs.setValue(int(params["indent_with_tabs"]))
            except:
                pass
        if "indent_cmt_with_tabs" in params:
            try:
                self.option_indent_cmt_with_tabs.setCurrentText(params["indent_cmt_with_tabs"])
            except:
                pass
        if "indent_align_string" in params:
            try:
                self.option_indent_align_string.setCurrentText(params["indent_align_string"])
            except:
                pass
        if "indent_xml_string" in params:
            try:
                self.option_indent_xml_string.setValue(int(params["indent_xml_string"]))
            except:
                pass
        if "indent_brace" in params:
            try:
                self.option_indent_brace.setValue(int(params["indent_brace"]))
            except:
                pass
        if "indent_braces" in params:
            try:
                self.option_indent_braces.setCurrentText(params["indent_braces"])
            except:
                pass
        if "indent_braces_no_func" in params:
            try:
                self.option_indent_braces_no_func.setCurrentText(params["indent_braces_no_func"])
            except:
                pass
        if "indent_braces_no_class" in params:
            try:
                self.option_indent_braces_no_class.setCurrentText(params["indent_braces_no_class"])
            except:
                pass
        if "indent_braces_no_struct" in params:
            try:
                self.option_indent_braces_no_struct.setCurrentText(params["indent_braces_no_struct"])
            except:
                pass
        if "indent_brace_parent" in params:
            try:
                self.option_indent_brace_parent.setCurrentText(params["indent_brace_parent"])
            except:
                pass
        if "indent_paren_open_brace" in params:
            try:
                self.option_indent_paren_open_brace.setCurrentText(params["indent_paren_open_brace"])
            except:
                pass
        if "indent_cs_delegate_brace" in params:
            try:
                self.option_indent_cs_delegate_brace.setCurrentText(params["indent_cs_delegate_brace"])
            except:
                pass
        if "indent_cs_delegate_body" in params:
            try:
                self.option_indent_cs_delegate_body.setCurrentText(params["indent_cs_delegate_body"])
            except:
                pass
        if "indent_namespace" in params:
            try:
                self.option_indent_namespace.setCurrentText(params["indent_namespace"])
            except:
                pass
        if "indent_namespace_single_indent" in params:
            try:
                self.option_indent_namespace_single_indent.setCurrentText(params["indent_namespace_single_indent"])
            except:
                pass
        if "indent_namespace_level" in params:
            try:
                self.option_indent_namespace_level.setValue(int(params["indent_namespace_level"]))
            except:
                pass
        if "indent_namespace_limit" in params:
            try:
                self.option_indent_namespace_limit.setValue(int(params["indent_namespace_limit"]))
            except:
                pass
        if "indent_namespace_inner_only" in params:
            try:
                self.option_indent_namespace_inner_only.setCurrentText(params["indent_namespace_inner_only"])
            except:
                pass
        if "indent_extern" in params:
            try:
                self.option_indent_extern.setCurrentText(params["indent_extern"])
            except:
                pass
        if "indent_class" in params:
            try:
                self.option_indent_class.setCurrentText(params["indent_class"])
            except:
                pass
        if "indent_ignore_before_class_colon" in params:
            try:
                self.option_indent_ignore_before_class_colon.setCurrentText(params["indent_ignore_before_class_colon"])
            except:
                pass
        if "indent_before_class_colon" in params:
            try:
                self.option_indent_before_class_colon.setValue(int(params["indent_before_class_colon"]))
            except:
                pass
        if "indent_class_colon" in params:
            try:
                self.option_indent_class_colon.setCurrentText(params["indent_class_colon"])
            except:
                pass
        if "indent_class_on_colon" in params:
            try:
                self.option_indent_class_on_colon.setCurrentText(params["indent_class_on_colon"])
            except:
                pass
        if "indent_ignore_before_constr_colon" in params:
            try:
                self.option_indent_ignore_before_constr_colon.setCurrentText(params["indent_ignore_before_constr_colon"])
            except:
                pass
        if "indent_constr_colon" in params:
            try:
                self.option_indent_constr_colon.setCurrentText(params["indent_constr_colon"])
            except:
                pass
        if "indent_ctor_init_leading" in params:
            try:
                self.option_indent_ctor_init_leading.setValue(int(params["indent_ctor_init_leading"]))
            except:
                pass
        if "indent_ctor_init_following" in params:
            try:
                self.option_indent_ctor_init_following.setValue(int(params["indent_ctor_init_following"]))
            except:
                pass
        if "indent_ctor_init" in params:
            try:
                self.option_indent_ctor_init.setValue(int(params["indent_ctor_init"]))
            except:
                pass
        if "indent_else_if" in params:
            try:
                self.option_indent_else_if.setCurrentText(params["indent_else_if"])
            except:
                pass
        if "indent_var_def_blk" in params:
            try:
                self.option_indent_var_def_blk.setValue(int(params["indent_var_def_blk"]))
            except:
                pass
        if "indent_var_def_cont" in params:
            try:
                self.option_indent_var_def_cont.setCurrentText(params["indent_var_def_cont"])
            except:
                pass
        if "indent_shift" in params:
            try:
                self.option_indent_shift.setValue(int(params["indent_shift"]))
            except:
                pass
        if "indent_func_def_force_col1" in params:
            try:
                self.option_indent_func_def_force_col1.setCurrentText(params["indent_func_def_force_col1"])
            except:
                pass
        if "indent_func_call_param" in params:
            try:
                self.option_indent_func_call_param.setCurrentText(params["indent_func_call_param"])
            except:
                pass
        if "indent_func_def_param" in params:
            try:
                self.option_indent_func_def_param.setCurrentText(params["indent_func_def_param"])
            except:
                pass
        if "indent_func_def_param_paren_pos_threshold" in params:
            try:
                self.option_indent_func_def_param_paren_pos_threshold.setValue(int(params["indent_func_def_param_paren_pos_threshold"]))
            except:
                pass
        if "indent_func_proto_param" in params:
            try:
                self.option_indent_func_proto_param.setCurrentText(params["indent_func_proto_param"])
            except:
                pass
        if "indent_func_class_param" in params:
            try:
                self.option_indent_func_class_param.setCurrentText(params["indent_func_class_param"])
            except:
                pass
        if "indent_func_ctor_var_param" in params:
            try:
                self.option_indent_func_ctor_var_param.setCurrentText(params["indent_func_ctor_var_param"])
            except:
                pass
        if "indent_template_param" in params:
            try:
                self.option_indent_template_param.setCurrentText(params["indent_template_param"])
            except:
                pass
        if "indent_func_param_double" in params:
            try:
                self.option_indent_func_param_double.setCurrentText(params["indent_func_param_double"])
            except:
                pass
        if "indent_func_const" in params:
            try:
                self.option_indent_func_const.setValue(int(params["indent_func_const"]))
            except:
                pass
        if "indent_func_throw" in params:
            try:
                self.option_indent_func_throw.setValue(int(params["indent_func_throw"]))
            except:
                pass
        if "indent_macro_brace" in params:
            try:
                self.option_indent_macro_brace.setCurrentText(params["indent_macro_brace"])
            except:
                pass
        if "indent_member" in params:
            try:
                self.option_indent_member.setValue(int(params["indent_member"]))
            except:
                pass
        if "indent_member_single" in params:
            try:
                self.option_indent_member_single.setCurrentText(params["indent_member_single"])
            except:
                pass
        if "indent_single_line_comments_before" in params:
            try:
                self.option_indent_single_line_comments_before.setValue(int(params["indent_single_line_comments_before"]))
            except:
                pass
        if "indent_single_line_comments_after" in params:
            try:
                self.option_indent_single_line_comments_after.setValue(int(params["indent_single_line_comments_after"]))
            except:
                pass
        if "indent_sparen_extra" in params:
            try:
                self.option_indent_sparen_extra.setValue(int(params["indent_sparen_extra"]))
            except:
                pass
        if "indent_relative_single_line_comments" in params:
            try:
                self.option_indent_relative_single_line_comments.setCurrentText(params["indent_relative_single_line_comments"])
            except:
                pass
        if "indent_switch_case" in params:
            try:
                self.option_indent_switch_case.setValue(int(params["indent_switch_case"]))
            except:
                pass
        if "indent_switch_body" in params:
            try:
                self.option_indent_switch_body.setValue(int(params["indent_switch_body"]))
            except:
                pass
        if "indent_ignore_case_brace" in params:
            try:
                self.option_indent_ignore_case_brace.setCurrentText(params["indent_ignore_case_brace"])
            except:
                pass
        if "indent_case_brace" in params:
            try:
                self.option_indent_case_brace.setValue(int(params["indent_case_brace"]))
            except:
                pass
        if "indent_switch_break_with_case" in params:
            try:
                self.option_indent_switch_break_with_case.setCurrentText(params["indent_switch_break_with_case"])
            except:
                pass
        if "indent_switch_pp" in params:
            try:
                self.option_indent_switch_pp.setCurrentText(params["indent_switch_pp"])
            except:
                pass
        if "indent_case_shift" in params:
            try:
                self.option_indent_case_shift.setValue(int(params["indent_case_shift"]))
            except:
                pass
        if "indent_case_comment" in params:
            try:
                self.option_indent_case_comment.setCurrentText(params["indent_case_comment"])
            except:
                pass
        if "indent_comment" in params:
            try:
                self.option_indent_comment.setCurrentText(params["indent_comment"])
            except:
                pass
        if "indent_col1_comment" in params:
            try:
                self.option_indent_col1_comment.setCurrentText(params["indent_col1_comment"])
            except:
                pass
        if "indent_col1_multi_string_literal" in params:
            try:
                self.option_indent_col1_multi_string_literal.setCurrentText(params["indent_col1_multi_string_literal"])
            except:
                pass
        if "indent_comment_align_thresh" in params:
            try:
                self.option_indent_comment_align_thresh.setValue(int(params["indent_comment_align_thresh"]))
            except:
                pass
        if "indent_ignore_label" in params:
            try:
                self.option_indent_ignore_label.setCurrentText(params["indent_ignore_label"])
            except:
                pass
        if "indent_label" in params:
            try:
                self.option_indent_label.setValue(int(params["indent_label"]))
            except:
                pass
        if "indent_access_spec" in params:
            try:
                self.option_indent_access_spec.setValue(int(params["indent_access_spec"]))
            except:
                pass
        if "indent_access_spec_body" in params:
            try:
                self.option_indent_access_spec_body.setCurrentText(params["indent_access_spec_body"])
            except:
                pass
        if "indent_paren_nl" in params:
            try:
                self.option_indent_paren_nl.setCurrentText(params["indent_paren_nl"])
            except:
                pass
        if "indent_paren_close" in params:
            try:
                self.option_indent_paren_close.setValue(int(params["indent_paren_close"]))
            except:
                pass
        if "indent_paren_after_func_def" in params:
            try:
                self.option_indent_paren_after_func_def.setCurrentText(params["indent_paren_after_func_def"])
            except:
                pass
        if "indent_paren_after_func_decl" in params:
            try:
                self.option_indent_paren_after_func_decl.setCurrentText(params["indent_paren_after_func_decl"])
            except:
                pass
        if "indent_paren_after_func_call" in params:
            try:
                self.option_indent_paren_after_func_call.setCurrentText(params["indent_paren_after_func_call"])
            except:
                pass
        if "indent_comma_brace" in params:
            try:
                self.option_indent_comma_brace.setValue(int(params["indent_comma_brace"]))
            except:
                pass
        if "indent_comma_paren" in params:
            try:
                self.option_indent_comma_paren.setValue(int(params["indent_comma_paren"]))
            except:
                pass
        if "indent_bool_paren" in params:
            try:
                self.option_indent_bool_paren.setValue(int(params["indent_bool_paren"]))
            except:
                pass
        if "indent_ignore_bool" in params:
            try:
                self.option_indent_ignore_bool.setCurrentText(params["indent_ignore_bool"])
            except:
                pass
        if "indent_ignore_arith" in params:
            try:
                self.option_indent_ignore_arith.setCurrentText(params["indent_ignore_arith"])
            except:
                pass
        if "indent_semicolon_for_paren" in params:
            try:
                self.option_indent_semicolon_for_paren.setCurrentText(params["indent_semicolon_for_paren"])
            except:
                pass
        if "indent_ignore_semicolon" in params:
            try:
                self.option_indent_ignore_semicolon.setCurrentText(params["indent_ignore_semicolon"])
            except:
                pass
        if "indent_first_bool_expr" in params:
            try:
                self.option_indent_first_bool_expr.setCurrentText(params["indent_first_bool_expr"])
            except:
                pass
        if "indent_first_for_expr" in params:
            try:
                self.option_indent_first_for_expr.setCurrentText(params["indent_first_for_expr"])
            except:
                pass
        if "indent_square_nl" in params:
            try:
                self.option_indent_square_nl.setCurrentText(params["indent_square_nl"])
            except:
                pass
        if "indent_preserve_sql" in params:
            try:
                self.option_indent_preserve_sql.setCurrentText(params["indent_preserve_sql"])
            except:
                pass
        if "indent_ignore_assign" in params:
            try:
                self.option_indent_ignore_assign.setCurrentText(params["indent_ignore_assign"])
            except:
                pass
        if "indent_align_assign" in params:
            try:
                self.option_indent_align_assign.setCurrentText(params["indent_align_assign"])
            except:
                pass
        if "indent_off_after_assign" in params:
            try:
                self.option_indent_off_after_assign.setCurrentText(params["indent_off_after_assign"])
            except:
                pass
        if "indent_align_paren" in params:
            try:
                self.option_indent_align_paren.setCurrentText(params["indent_align_paren"])
            except:
                pass
        if "indent_oc_inside_msg_sel" in params:
            try:
                self.option_indent_oc_inside_msg_sel.setCurrentText(params["indent_oc_inside_msg_sel"])
            except:
                pass
        if "indent_oc_block" in params:
            try:
                self.option_indent_oc_block.setCurrentText(params["indent_oc_block"])
            except:
                pass
        if "indent_oc_block_msg" in params:
            try:
                self.option_indent_oc_block_msg.setValue(int(params["indent_oc_block_msg"]))
            except:
                pass
        if "indent_oc_msg_colon" in params:
            try:
                self.option_indent_oc_msg_colon.setValue(int(params["indent_oc_msg_colon"]))
            except:
                pass
        if "indent_oc_msg_prioritize_first_colon" in params:
            try:
                self.option_indent_oc_msg_prioritize_first_colon.setCurrentText(params["indent_oc_msg_prioritize_first_colon"])
            except:
                pass
        if "indent_oc_block_msg_xcode_style" in params:
            try:
                self.option_indent_oc_block_msg_xcode_style.setCurrentText(params["indent_oc_block_msg_xcode_style"])
            except:
                pass
        if "indent_oc_block_msg_from_keyword" in params:
            try:
                self.option_indent_oc_block_msg_from_keyword.setCurrentText(params["indent_oc_block_msg_from_keyword"])
            except:
                pass
        if "indent_oc_block_msg_from_colon" in params:
            try:
                self.option_indent_oc_block_msg_from_colon.setCurrentText(params["indent_oc_block_msg_from_colon"])
            except:
                pass
        if "indent_oc_block_msg_from_caret" in params:
            try:
                self.option_indent_oc_block_msg_from_caret.setCurrentText(params["indent_oc_block_msg_from_caret"])
            except:
                pass
        if "indent_oc_block_msg_from_brace" in params:
            try:
                self.option_indent_oc_block_msg_from_brace.setCurrentText(params["indent_oc_block_msg_from_brace"])
            except:
                pass
        if "indent_min_vbrace_open" in params:
            try:
                self.option_indent_min_vbrace_open.setValue(int(params["indent_min_vbrace_open"]))
            except:
                pass
        if "indent_vbrace_open_on_tabstop" in params:
            try:
                self.option_indent_vbrace_open_on_tabstop.setCurrentText(params["indent_vbrace_open_on_tabstop"])
            except:
                pass
        if "indent_token_after_brace" in params:
            try:
                self.option_indent_token_after_brace.setCurrentText(params["indent_token_after_brace"])
            except:
                pass
        if "indent_cpp_lambda_body" in params:
            try:
                self.option_indent_cpp_lambda_body.setCurrentText(params["indent_cpp_lambda_body"])
            except:
                pass
        if "indent_compound_literal_return" in params:
            try:
                self.option_indent_compound_literal_return.setCurrentText(params["indent_compound_literal_return"])
            except:
                pass
        if "indent_using_block" in params:
            try:
                self.option_indent_using_block.setCurrentText(params["indent_using_block"])
            except:
                pass
        if "indent_ternary_operator" in params:
            try:
                self.option_indent_ternary_operator.setValue(int(params["indent_ternary_operator"]))
            except:
                pass
        if "indent_inside_ternary_operator" in params:
            try:
                self.option_indent_inside_ternary_operator.setCurrentText(params["indent_inside_ternary_operator"])
            except:
                pass
        if "indent_off_after_return" in params:
            try:
                self.option_indent_off_after_return.setCurrentText(params["indent_off_after_return"])
            except:
                pass
        if "indent_off_after_return_new" in params:
            try:
                self.option_indent_off_after_return_new.setCurrentText(params["indent_off_after_return_new"])
            except:
                pass
        if "indent_single_after_return" in params:
            try:
                self.option_indent_single_after_return.setCurrentText(params["indent_single_after_return"])
            except:
                pass
        if "indent_ignore_asm_block" in params:
            try:
                self.option_indent_ignore_asm_block.setCurrentText(params["indent_ignore_asm_block"])
            except:
                pass
        if "donot_indent_func_def_close_paren" in params:
            try:
                self.option_donot_indent_func_def_close_paren.setCurrentText(params["donot_indent_func_def_close_paren"])
            except:
                pass
        #================== Newline adding and removing options =============================================
        if "nl_collapse_empty_body" in params:
            try:
                self.option_nl_collapse_empty_body.setCurrentText(params["nl_collapse_empty_body"])
            except:
                pass
        if "nl_collapse_empty_body_functions" in params:
            try:
                self.option_nl_collapse_empty_body_functions.setCurrentText(params["nl_collapse_empty_body_functions"])
            except:
                pass
        if "nl_assign_leave_one_liners" in params:
            try:
                self.option_nl_assign_leave_one_liners.setCurrentText(params["nl_assign_leave_one_liners"])
            except:
                pass
        if "nl_class_leave_one_liners" in params:
            try:
                self.option_nl_class_leave_one_liners.setCurrentText(params["nl_class_leave_one_liners"])
            except:
                pass
        if "nl_enum_leave_one_liners" in params:
            try:
                self.option_nl_enum_leave_one_liners.setCurrentText(params["nl_enum_leave_one_liners"])
            except:
                pass
        if "nl_getset_leave_one_liners" in params:
            try:
                self.option_nl_getset_leave_one_liners.setCurrentText(params["nl_getset_leave_one_liners"])
            except:
                pass
        if "nl_cs_property_leave_one_liners" in params:
            try:
                self.option_nl_cs_property_leave_one_liners.setCurrentText(params["nl_cs_property_leave_one_liners"])
            except:
                pass
        if "nl_func_leave_one_liners" in params:
            try:
                self.option_nl_func_leave_one_liners.setCurrentText(params["nl_func_leave_one_liners"])
            except:
                pass
        if "nl_cpp_lambda_leave_one_liners" in params:
            try:
                self.option_nl_cpp_lambda_leave_one_liners.setCurrentText(params["nl_cpp_lambda_leave_one_liners"])
            except:
                pass
        if "nl_if_leave_one_liners" in params:
            try:
                self.option_nl_if_leave_one_liners.setCurrentText(params["nl_if_leave_one_liners"])
            except:
                pass
        if "nl_while_leave_one_liners" in params:
            try:
                self.option_nl_while_leave_one_liners.setCurrentText(params["nl_while_leave_one_liners"])
            except:
                pass
        if "nl_do_leave_one_liners" in params:
            try:
                self.option_nl_do_leave_one_liners.setCurrentText(params["nl_do_leave_one_liners"])
            except:
                pass
        if "nl_for_leave_one_liners" in params:
            try:
                self.option_nl_for_leave_one_liners.setCurrentText(params["nl_for_leave_one_liners"])
            except:
                pass
        if "nl_oc_msg_leave_one_liner" in params:
            try:
                self.option_nl_oc_msg_leave_one_liner.setCurrentText(params["nl_oc_msg_leave_one_liner"])
            except:
                pass
        if "nl_oc_mdef_brace" in params:
            try:
                self.option_nl_oc_mdef_brace.setCurrentText(params["nl_oc_mdef_brace"])
            except:
                pass
        if "nl_oc_block_brace" in params:
            try:
                self.option_nl_oc_block_brace.setCurrentText(params["nl_oc_block_brace"])
            except:
                pass
        if "nl_oc_before_interface" in params:
            try:
                self.option_nl_oc_before_interface.setCurrentText(params["nl_oc_before_interface"])
            except:
                pass
        if "nl_oc_before_implementation" in params:
            try:
                self.option_nl_oc_before_implementation.setCurrentText(params["nl_oc_before_implementation"])
            except:
                pass
        if "nl_oc_before_end" in params:
            try:
                self.option_nl_oc_before_end.setCurrentText(params["nl_oc_before_end"])
            except:
                pass
        if "nl_oc_interface_brace" in params:
            try:
                self.option_nl_oc_interface_brace.setCurrentText(params["nl_oc_interface_brace"])
            except:
                pass
        if "nl_oc_implementation_brace" in params:
            try:
                self.option_nl_oc_implementation_brace.setCurrentText(params["nl_oc_implementation_brace"])
            except:
                pass
        if "nl_start_of_file" in params:
            try:
                self.option_nl_start_of_file.setCurrentText(params["nl_start_of_file"])
            except:
                pass
        if "nl_start_of_file_min" in params:
            try:
                self.option_nl_start_of_file_min.setValue(int(params["nl_start_of_file_min"]))
            except:
                pass
        if "nl_end_of_file" in params:
            try:
                self.option_nl_end_of_file.setCurrentText(params["nl_end_of_file"])
            except:
                pass
        if "nl_end_of_file_min" in params:
            try:
                self.option_nl_end_of_file_min.setValue(int(params["nl_end_of_file_min"]))
            except:
                pass
        if "nl_assign_brace" in params:
            try:
                self.option_nl_assign_brace.setCurrentText(params["nl_assign_brace"])
            except:
                pass
        if "nl_assign_square" in params:
            try:
                self.option_nl_assign_square.setCurrentText(params["nl_assign_square"])
            except:
                pass
        if "nl_tsquare_brace" in params:
            try:
                self.option_nl_tsquare_brace.setCurrentText(params["nl_tsquare_brace"])
            except:
                pass
        if "nl_after_square_assign" in params:
            try:
                self.option_nl_after_square_assign.setCurrentText(params["nl_after_square_assign"])
            except:
                pass
        if "nl_fcall_brace" in params:
            try:
                self.option_nl_fcall_brace.setCurrentText(params["nl_fcall_brace"])
            except:
                pass
        if "nl_enum_brace" in params:
            try:
                self.option_nl_enum_brace.setCurrentText(params["nl_enum_brace"])
            except:
                pass
        if "nl_enum_class" in params:
            try:
                self.option_nl_enum_class.setCurrentText(params["nl_enum_class"])
            except:
                pass
        if "nl_enum_class_identifier" in params:
            try:
                self.option_nl_enum_class_identifier.setCurrentText(params["nl_enum_class_identifier"])
            except:
                pass
        if "nl_enum_identifier_colon" in params:
            try:
                self.option_nl_enum_identifier_colon.setCurrentText(params["nl_enum_identifier_colon"])
            except:
                pass
        if "nl_enum_colon_type" in params:
            try:
                self.option_nl_enum_colon_type.setCurrentText(params["nl_enum_colon_type"])
            except:
                pass
        if "nl_struct_brace" in params:
            try:
                self.option_nl_struct_brace.setCurrentText(params["nl_struct_brace"])
            except:
                pass
        if "nl_union_brace" in params:
            try:
                self.option_nl_union_brace.setCurrentText(params["nl_union_brace"])
            except:
                pass
        if "nl_if_brace" in params:
            try:
                self.option_nl_if_brace.setCurrentText(params["nl_if_brace"])
            except:
                pass
        if "nl_brace_else" in params:
            try:
                self.option_nl_brace_else.setCurrentText(params["nl_brace_else"])
            except:
                pass
        if "nl_elseif_brace" in params:
            try:
                self.option_nl_elseif_brace.setCurrentText(params["nl_elseif_brace"])
            except:
                pass
        if "nl_else_brace" in params:
            try:
                self.option_nl_else_brace.setCurrentText(params["nl_else_brace"])
            except:
                pass
        if "nl_else_if" in params:
            try:
                self.option_nl_else_if.setCurrentText(params["nl_else_if"])
            except:
                pass
        if "nl_before_opening_brace_func_class_def" in params:
            try:
                self.option_nl_before_opening_brace_func_class_def.setCurrentText(params["nl_before_opening_brace_func_class_def"])
            except:
                pass
        if "nl_before_if_closing_paren" in params:
            try:
                self.option_nl_before_if_closing_paren.setCurrentText(params["nl_before_if_closing_paren"])
            except:
                pass
        if "nl_brace_finally" in params:
            try:
                self.option_nl_brace_finally.setCurrentText(params["nl_brace_finally"])
            except:
                pass
        if "nl_finally_brace" in params:
            try:
                self.option_nl_finally_brace.setCurrentText(params["nl_finally_brace"])
            except:
                pass
        if "nl_try_brace" in params:
            try:
                self.option_nl_try_brace.setCurrentText(params["nl_try_brace"])
            except:
                pass
        if "nl_getset_brace" in params:
            try:
                self.option_nl_getset_brace.setCurrentText(params["nl_getset_brace"])
            except:
                pass
        if "nl_for_brace" in params:
            try:
                self.option_nl_for_brace.setCurrentText(params["nl_for_brace"])
            except:
                pass
        if "nl_catch_brace" in params:
            try:
                self.option_nl_catch_brace.setCurrentText(params["nl_catch_brace"])
            except:
                pass
        if "nl_oc_catch_brace" in params:
            try:
                self.option_nl_oc_catch_brace.setCurrentText(params["nl_oc_catch_brace"])
            except:
                pass
        if "nl_brace_catch" in params:
            try:
                self.option_nl_brace_catch.setCurrentText(params["nl_brace_catch"])
            except:
                pass
        if "nl_oc_brace_catch" in params:
            try:
                self.option_nl_oc_brace_catch.setCurrentText(params["nl_oc_brace_catch"])
            except:
                pass
        if "nl_brace_square" in params:
            try:
                self.option_nl_brace_square.setCurrentText(params["nl_brace_square"])
            except:
                pass
        if "nl_brace_fparen" in params:
            try:
                self.option_nl_brace_fparen.setCurrentText(params["nl_brace_fparen"])
            except:
                pass
        if "nl_while_brace" in params:
            try:
                self.option_nl_while_brace.setCurrentText(params["nl_while_brace"])
            except:
                pass
        if "nl_scope_brace" in params:
            try:
                self.option_nl_scope_brace.setCurrentText(params["nl_scope_brace"])
            except:
                pass
        if "nl_unittest_brace" in params:
            try:
                self.option_nl_unittest_brace.setCurrentText(params["nl_unittest_brace"])
            except:
                pass
        if "nl_version_brace" in params:
            try:
                self.option_nl_version_brace.setCurrentText(params["nl_version_brace"])
            except:
                pass
        if "nl_using_brace" in params:
            try:
                self.option_nl_using_brace.setCurrentText(params["nl_using_brace"])
            except:
                pass
        if "nl_brace_brace" in params:
            try:
                self.option_nl_brace_brace.setCurrentText(params["nl_brace_brace"])
            except:
                pass
        if "nl_do_brace" in params:
            try:
                self.option_nl_do_brace.setCurrentText(params["nl_do_brace"])
            except:
                pass
        if "nl_brace_while" in params:
            try:
                self.option_nl_brace_while.setCurrentText(params["nl_brace_while"])
            except:
                pass
        if "nl_switch_brace" in params:
            try:
                self.option_nl_switch_brace.setCurrentText(params["nl_switch_brace"])
            except:
                pass
        if "nl_synchronized_brace" in params:
            try:
                self.option_nl_synchronized_brace.setCurrentText(params["nl_synchronized_brace"])
            except:
                pass
        if "nl_multi_line_cond" in params:
            try:
                self.option_nl_multi_line_cond.setCurrentText(params["nl_multi_line_cond"])
            except:
                pass
        if "nl_multi_line_sparen_open" in params:
            try:
                self.option_nl_multi_line_sparen_open.setCurrentText(params["nl_multi_line_sparen_open"])
            except:
                pass
        if "nl_multi_line_sparen_close" in params:
            try:
                self.option_nl_multi_line_sparen_close.setCurrentText(params["nl_multi_line_sparen_close"])
            except:
                pass
        if "nl_multi_line_define" in params:
            try:
                self.option_nl_multi_line_define.setCurrentText(params["nl_multi_line_define"])
            except:
                pass
        if "nl_before_case" in params:
            try:
                self.option_nl_before_case.setCurrentText(params["nl_before_case"])
            except:
                pass
        if "nl_after_case" in params:
            try:
                self.option_nl_after_case.setCurrentText(params["nl_after_case"])
            except:
                pass
        if "nl_case_colon_brace" in params:
            try:
                self.option_nl_case_colon_brace.setCurrentText(params["nl_case_colon_brace"])
            except:
                pass
        if "nl_before_throw" in params:
            try:
                self.option_nl_before_throw.setCurrentText(params["nl_before_throw"])
            except:
                pass
        if "nl_namespace_brace" in params:
            try:
                self.option_nl_namespace_brace.setCurrentText(params["nl_namespace_brace"])
            except:
                pass
        if "nl_template_class" in params:
            try:
                self.option_nl_template_class.setCurrentText(params["nl_template_class"])
            except:
                pass
        if "nl_template_class_decl" in params:
            try:
                self.option_nl_template_class_decl.setCurrentText(params["nl_template_class_decl"])
            except:
                pass
        if "nl_template_class_decl_special" in params:
            try:
                self.option_nl_template_class_decl_special.setCurrentText(params["nl_template_class_decl_special"])
            except:
                pass
        if "nl_template_class_def" in params:
            try:
                self.option_nl_template_class_def.setCurrentText(params["nl_template_class_def"])
            except:
                pass
        if "nl_template_class_def_special" in params:
            try:
                self.option_nl_template_class_def_special.setCurrentText(params["nl_template_class_def_special"])
            except:
                pass
        if "nl_template_func" in params:
            try:
                self.option_nl_template_func.setCurrentText(params["nl_template_func"])
            except:
                pass
        if "nl_template_func_decl" in params:
            try:
                self.option_nl_template_func_decl.setCurrentText(params["nl_template_func_decl"])
            except:
                pass
        if "nl_template_func_decl_special" in params:
            try:
                self.option_nl_template_func_decl_special.setCurrentText(params["nl_template_func_decl_special"])
            except:
                pass
        if "nl_template_func_def" in params:
            try:
                self.option_nl_template_func_def.setCurrentText(params["nl_template_func_def"])
            except:
                pass
        if "nl_template_func_def_special" in params:
            try:
                self.option_nl_template_func_def_special.setCurrentText(params["nl_template_func_def_special"])
            except:
                pass
        if "nl_template_var" in params:
            try:
                self.option_nl_template_var.setCurrentText(params["nl_template_var"])
            except:
                pass
        if "nl_template_using" in params:
            try:
                self.option_nl_template_using.setCurrentText(params["nl_template_using"])
            except:
                pass
        if "nl_class_brace" in params:
            try:
                self.option_nl_class_brace.setCurrentText(params["nl_class_brace"])
            except:
                pass
        if "nl_class_init_args" in params:
            try:
                self.option_nl_class_init_args.setCurrentText(params["nl_class_init_args"])
            except:
                pass
        if "nl_constr_init_args" in params:
            try:
                self.option_nl_constr_init_args.setCurrentText(params["nl_constr_init_args"])
            except:
                pass
        if "nl_enum_own_lines" in params:
            try:
                self.option_nl_enum_own_lines.setCurrentText(params["nl_enum_own_lines"])
            except:
                pass
        if "nl_func_type_name" in params:
            try:
                self.option_nl_func_type_name.setCurrentText(params["nl_func_type_name"])
            except:
                pass
        if "nl_func_type_name_class" in params:
            try:
                self.option_nl_func_type_name_class.setCurrentText(params["nl_func_type_name_class"])
            except:
                pass
        if "nl_func_class_scope" in params:
            try:
                self.option_nl_func_class_scope.setCurrentText(params["nl_func_class_scope"])
            except:
                pass
        if "nl_func_scope_name" in params:
            try:
                self.option_nl_func_scope_name.setCurrentText(params["nl_func_scope_name"])
            except:
                pass
        if "nl_func_proto_type_name" in params:
            try:
                self.option_nl_func_proto_type_name.setCurrentText(params["nl_func_proto_type_name"])
            except:
                pass
        if "nl_func_paren" in params:
            try:
                self.option_nl_func_paren.setCurrentText(params["nl_func_paren"])
            except:
                pass
        if "nl_func_paren_empty" in params:
            try:
                self.option_nl_func_paren_empty.setCurrentText(params["nl_func_paren_empty"])
            except:
                pass
        if "nl_func_def_paren" in params:
            try:
                self.option_nl_func_def_paren.setCurrentText(params["nl_func_def_paren"])
            except:
                pass
        if "nl_func_def_paren_empty" in params:
            try:
                self.option_nl_func_def_paren_empty.setCurrentText(params["nl_func_def_paren_empty"])
            except:
                pass
        if "nl_func_call_paren" in params:
            try:
                self.option_nl_func_call_paren.setCurrentText(params["nl_func_call_paren"])
            except:
                pass
        if "nl_func_call_paren_empty" in params:
            try:
                self.option_nl_func_call_paren_empty.setCurrentText(params["nl_func_call_paren_empty"])
            except:
                pass
        if "nl_func_decl_start" in params:
            try:
                self.option_nl_func_decl_start.setCurrentText(params["nl_func_decl_start"])
            except:
                pass
        if "nl_func_def_start" in params:
            try:
                self.option_nl_func_def_start.setCurrentText(params["nl_func_def_start"])
            except:
                pass
        if "nl_func_decl_start_single" in params:
            try:
                self.option_nl_func_decl_start_single.setCurrentText(params["nl_func_decl_start_single"])
            except:
                pass
        if "nl_func_def_start_single" in params:
            try:
                self.option_nl_func_def_start_single.setCurrentText(params["nl_func_def_start_single"])
            except:
                pass
        if "nl_func_decl_start_multi_line" in params:
            try:
                self.option_nl_func_decl_start_multi_line.setCurrentText(params["nl_func_decl_start_multi_line"])
            except:
                pass
        if "nl_func_def_start_multi_line" in params:
            try:
                self.option_nl_func_def_start_multi_line.setCurrentText(params["nl_func_def_start_multi_line"])
            except:
                pass
        if "nl_func_decl_args" in params:
            try:
                self.option_nl_func_decl_args.setCurrentText(params["nl_func_decl_args"])
            except:
                pass
        if "nl_func_def_args" in params:
            try:
                self.option_nl_func_def_args.setCurrentText(params["nl_func_def_args"])
            except:
                pass
        if "nl_func_call_args" in params:
            try:
                self.option_nl_func_call_args.setCurrentText(params["nl_func_call_args"])
            except:
                pass
        if "nl_func_decl_args_multi_line" in params:
            try:
                self.option_nl_func_decl_args_multi_line.setCurrentText(params["nl_func_decl_args_multi_line"])
            except:
                pass
        if "nl_func_def_args_multi_line" in params:
            try:
                self.option_nl_func_def_args_multi_line.setCurrentText(params["nl_func_def_args_multi_line"])
            except:
                pass
        if "nl_func_decl_end" in params:
            try:
                self.option_nl_func_decl_end.setCurrentText(params["nl_func_decl_end"])
            except:
                pass
        if "nl_func_def_end" in params:
            try:
                self.option_nl_func_def_end.setCurrentText(params["nl_func_def_end"])
            except:
                pass
        if "nl_func_decl_end_single" in params:
            try:
                self.option_nl_func_decl_end_single.setCurrentText(params["nl_func_decl_end_single"])
            except:
                pass
        if "nl_func_def_end_single" in params:
            try:
                self.option_nl_func_def_end_single.setCurrentText(params["nl_func_def_end_single"])
            except:
                pass
        if "nl_func_decl_end_multi_line" in params:
            try:
                self.option_nl_func_decl_end_multi_line.setCurrentText(params["nl_func_decl_end_multi_line"])
            except:
                pass
        if "nl_func_def_end_multi_line" in params:
            try:
                self.option_nl_func_def_end_multi_line.setCurrentText(params["nl_func_def_end_multi_line"])
            except:
                pass
        if "nl_func_decl_empty" in params:
            try:
                self.option_nl_func_decl_empty.setCurrentText(params["nl_func_decl_empty"])
            except:
                pass
        if "nl_func_def_empty" in params:
            try:
                self.option_nl_func_def_empty.setCurrentText(params["nl_func_def_empty"])
            except:
                pass
        if "nl_func_call_empty" in params:
            try:
                self.option_nl_func_call_empty.setCurrentText(params["nl_func_call_empty"])
            except:
                pass
        if "nl_func_call_start" in params:
            try:
                self.option_nl_func_call_start.setCurrentText(params["nl_func_call_start"])
            except:
                pass
        if "nl_func_call_end" in params:
            try:
                self.option_nl_func_call_end.setCurrentText(params["nl_func_call_end"])
            except:
                pass
        if "nl_func_call_start_multi_line" in params:
            try:
                self.option_nl_func_call_start_multi_line.setCurrentText(params["nl_func_call_start_multi_line"])
            except:
                pass
        if "nl_func_call_args_multi_line" in params:
            try:
                self.option_nl_func_call_args_multi_line.setCurrentText(params["nl_func_call_args_multi_line"])
            except:
                pass
        if "nl_func_call_end_multi_line" in params:
            try:
                self.option_nl_func_call_end_multi_line.setCurrentText(params["nl_func_call_end_multi_line"])
            except:
                pass
        if "nl_func_call_args_multi_line_ignore_closures" in params:
            try:
                self.option_nl_func_call_args_multi_line_ignore_closures.setCurrentText(params["nl_func_call_args_multi_line_ignore_closures"])
            except:
                pass
        if "nl_template_start" in params:
            try:
                self.option_nl_template_start.setCurrentText(params["nl_template_start"])
            except:
                pass
        if "nl_template_args" in params:
            try:
                self.option_nl_template_args.setCurrentText(params["nl_template_args"])
            except:
                pass
        if "nl_template_end" in params:
            try:
                self.option_nl_template_end.setCurrentText(params["nl_template_end"])
            except:
                pass
        if "nl_oc_msg_args" in params:
            try:
                self.option_nl_oc_msg_args.setCurrentText(params["nl_oc_msg_args"])
            except:
                pass
        if "nl_oc_msg_args_min_params" in params:
            try:
                self.option_nl_oc_msg_args_min_params.setValue(int(params["nl_oc_msg_args_min_params"]))
            except:
                pass
        if "nl_oc_msg_args_max_code_width" in params:
            try:
                self.option_nl_oc_msg_args_max_code_width.setValue(int(params["nl_oc_msg_args_max_code_width"]))
            except:
                pass
        if "nl_oc_msg_args_finish_multi_line" in params:
            try:
                self.option_nl_oc_msg_args_finish_multi_line.setCurrentText(params["nl_oc_msg_args_finish_multi_line"])
            except:
                pass
        if "nl_fdef_brace" in params:
            try:
                self.option_nl_fdef_brace.setCurrentText(params["nl_fdef_brace"])
            except:
                pass
        if "nl_fdef_brace_cond" in params:
            try:
                self.option_nl_fdef_brace_cond.setCurrentText(params["nl_fdef_brace_cond"])
            except:
                pass
        if "nl_cpp_ldef_brace" in params:
            try:
                self.option_nl_cpp_ldef_brace.setCurrentText(params["nl_cpp_ldef_brace"])
            except:
                pass
        if "nl_return_expr" in params:
            try:
                self.option_nl_return_expr.setCurrentText(params["nl_return_expr"])
            except:
                pass
        if "nl_throw_expr" in params:
            try:
                self.option_nl_throw_expr.setCurrentText(params["nl_throw_expr"])
            except:
                pass
        if "nl_after_semicolon" in params:
            try:
                self.option_nl_after_semicolon.setCurrentText(params["nl_after_semicolon"])
            except:
                pass
        if "nl_paren_dbrace_open" in params:
            try:
                self.option_nl_paren_dbrace_open.setCurrentText(params["nl_paren_dbrace_open"])
            except:
                pass
        if "nl_type_brace_init_lst" in params:
            try:
                self.option_nl_type_brace_init_lst.setCurrentText(params["nl_type_brace_init_lst"])
            except:
                pass
        if "nl_type_brace_init_lst_open" in params:
            try:
                self.option_nl_type_brace_init_lst_open.setCurrentText(params["nl_type_brace_init_lst_open"])
            except:
                pass
        if "nl_type_brace_init_lst_close" in params:
            try:
                self.option_nl_type_brace_init_lst_close.setCurrentText(params["nl_type_brace_init_lst_close"])
            except:
                pass
        if "nl_before_brace_open" in params:
            try:
                self.option_nl_before_brace_open.setCurrentText(params["nl_before_brace_open"])
            except:
                pass
        if "nl_after_brace_open" in params:
            try:
                self.option_nl_after_brace_open.setCurrentText(params["nl_after_brace_open"])
            except:
                pass
        if "nl_after_brace_open_cmt" in params:
            try:
                self.option_nl_after_brace_open_cmt.setCurrentText(params["nl_after_brace_open_cmt"])
            except:
                pass
        if "nl_after_vbrace_open" in params:
            try:
                self.option_nl_after_vbrace_open.setCurrentText(params["nl_after_vbrace_open"])
            except:
                pass
        if "nl_after_vbrace_open_empty" in params:
            try:
                self.option_nl_after_vbrace_open_empty.setCurrentText(params["nl_after_vbrace_open_empty"])
            except:
                pass
        if "nl_after_brace_close" in params:
            try:
                self.option_nl_after_brace_close.setCurrentText(params["nl_after_brace_close"])
            except:
                pass
        if "nl_after_vbrace_close" in params:
            try:
                self.option_nl_after_vbrace_close.setCurrentText(params["nl_after_vbrace_close"])
            except:
                pass
        if "nl_brace_struct_var" in params:
            try:
                self.option_nl_brace_struct_var.setCurrentText(params["nl_brace_struct_var"])
            except:
                pass
        if "nl_define_macro" in params:
            try:
                self.option_nl_define_macro.setCurrentText(params["nl_define_macro"])
            except:
                pass
        if "nl_squeeze_paren_close" in params:
            try:
                self.option_nl_squeeze_paren_close.setCurrentText(params["nl_squeeze_paren_close"])
            except:
                pass
        if "nl_squeeze_ifdef" in params:
            try:
                self.option_nl_squeeze_ifdef.setCurrentText(params["nl_squeeze_ifdef"])
            except:
                pass
        if "nl_squeeze_ifdef_top_level" in params:
            try:
                self.option_nl_squeeze_ifdef_top_level.setCurrentText(params["nl_squeeze_ifdef_top_level"])
            except:
                pass
        if "nl_before_if" in params:
            try:
                self.option_nl_before_if.setCurrentText(params["nl_before_if"])
            except:
                pass
        if "nl_after_if" in params:
            try:
                self.option_nl_after_if.setCurrentText(params["nl_after_if"])
            except:
                pass
        if "nl_before_for" in params:
            try:
                self.option_nl_before_for.setCurrentText(params["nl_before_for"])
            except:
                pass
        if "nl_after_for" in params:
            try:
                self.option_nl_after_for.setCurrentText(params["nl_after_for"])
            except:
                pass
        if "nl_before_while" in params:
            try:
                self.option_nl_before_while.setCurrentText(params["nl_before_while"])
            except:
                pass
        if "nl_after_while" in params:
            try:
                self.option_nl_after_while.setCurrentText(params["nl_after_while"])
            except:
                pass
        if "nl_before_switch" in params:
            try:
                self.option_nl_before_switch.setCurrentText(params["nl_before_switch"])
            except:
                pass
        if "nl_after_switch" in params:
            try:
                self.option_nl_after_switch.setCurrentText(params["nl_after_switch"])
            except:
                pass
        if "nl_before_synchronized" in params:
            try:
                self.option_nl_before_synchronized.setCurrentText(params["nl_before_synchronized"])
            except:
                pass
        if "nl_after_synchronized" in params:
            try:
                self.option_nl_after_synchronized.setCurrentText(params["nl_after_synchronized"])
            except:
                pass
        if "nl_before_do" in params:
            try:
                self.option_nl_before_do.setCurrentText(params["nl_before_do"])
            except:
                pass
        if "nl_after_do" in params:
            try:
                self.option_nl_after_do.setCurrentText(params["nl_after_do"])
            except:
                pass
        if "nl_before_ignore_after_case" in params:
            try:
                self.option_nl_before_ignore_after_case.setCurrentText(params["nl_before_ignore_after_case"])
            except:
                pass
        if "nl_before_return" in params:
            try:
                self.option_nl_before_return.setCurrentText(params["nl_before_return"])
            except:
                pass
        if "nl_after_return" in params:
            try:
                self.option_nl_after_return.setCurrentText(params["nl_after_return"])
            except:
                pass
        if "nl_before_member" in params:
            try:
                self.option_nl_before_member.setCurrentText(params["nl_before_member"])
            except:
                pass
        if "nl_after_member" in params:
            try:
                self.option_nl_after_member.setCurrentText(params["nl_after_member"])
            except:
                pass
        if "nl_ds_struct_enum_cmt" in params:
            try:
                self.option_nl_ds_struct_enum_cmt.setCurrentText(params["nl_ds_struct_enum_cmt"])
            except:
                pass
        if "nl_ds_struct_enum_close_brace" in params:
            try:
                self.option_nl_ds_struct_enum_close_brace.setCurrentText(params["nl_ds_struct_enum_close_brace"])
            except:
                pass
        if "nl_class_colon" in params:
            try:
                self.option_nl_class_colon.setCurrentText(params["nl_class_colon"])
            except:
                pass
        if "nl_constr_colon" in params:
            try:
                self.option_nl_constr_colon.setCurrentText(params["nl_constr_colon"])
            except:
                pass
        if "nl_namespace_two_to_one_liner" in params:
            try:
                self.option_nl_namespace_two_to_one_liner.setCurrentText(params["nl_namespace_two_to_one_liner"])
            except:
                pass
        if "nl_create_if_one_liner" in params:
            try:
                self.option_nl_create_if_one_liner.setCurrentText(params["nl_create_if_one_liner"])
            except:
                pass
        if "nl_create_for_one_liner" in params:
            try:
                self.option_nl_create_for_one_liner.setCurrentText(params["nl_create_for_one_liner"])
            except:
                pass
        if "nl_create_while_one_liner" in params:
            try:
                self.option_nl_create_while_one_liner.setCurrentText(params["nl_create_while_one_liner"])
            except:
                pass
        if "nl_create_func_def_one_liner" in params:
            try:
                self.option_nl_create_func_def_one_liner.setCurrentText(params["nl_create_func_def_one_liner"])
            except:
                pass
        if "nl_create_list_one_liner" in params:
            try:
                self.option_nl_create_list_one_liner.setCurrentText(params["nl_create_list_one_liner"])
            except:
                pass
        if "nl_split_if_one_liner" in params:
            try:
                self.option_nl_split_if_one_liner.setCurrentText(params["nl_split_if_one_liner"])
            except:
                pass
        if "nl_split_for_one_liner" in params:
            try:
                self.option_nl_split_for_one_liner.setCurrentText(params["nl_split_for_one_liner"])
            except:
                pass
        if "nl_split_while_one_liner" in params:
            try:
                self.option_nl_split_while_one_liner.setCurrentText(params["nl_split_while_one_liner"])
            except:
                pass
        if "donot_add_nl_before_cpp_comment" in params:
            try:
                self.option_donot_add_nl_before_cpp_comment.setCurrentText(params["donot_add_nl_before_cpp_comment"])
            except:
                pass
        #================== Blank line options ==============================================================
        if "nl_max" in params:
            try:
                self.option_nl_max.setValue(int(params["nl_max"]))
            except:
                pass
        if "nl_max_blank_in_func" in params:
            try:
                self.option_nl_max_blank_in_func.setValue(int(params["nl_max_blank_in_func"]))
            except:
                pass
        if "nl_inside_empty_func" in params:
            try:
                self.option_nl_inside_empty_func.setValue(int(params["nl_inside_empty_func"]))
            except:
                pass
        if "nl_before_func_body_proto" in params:
            try:
                self.option_nl_before_func_body_proto.setValue(int(params["nl_before_func_body_proto"]))
            except:
                pass
        if "nl_before_func_body_def" in params:
            try:
                self.option_nl_before_func_body_def.setValue(int(params["nl_before_func_body_def"]))
            except:
                pass
        if "nl_before_func_class_proto" in params:
            try:
                self.option_nl_before_func_class_proto.setValue(int(params["nl_before_func_class_proto"]))
            except:
                pass
        if "nl_before_func_class_def" in params:
            try:
                self.option_nl_before_func_class_def.setValue(int(params["nl_before_func_class_def"]))
            except:
                pass
        if "nl_after_func_proto" in params:
            try:
                self.option_nl_after_func_proto.setValue(int(params["nl_after_func_proto"]))
            except:
                pass
        if "nl_after_func_proto_group" in params:
            try:
                self.option_nl_after_func_proto_group.setValue(int(params["nl_after_func_proto_group"]))
            except:
                pass
        if "nl_after_func_class_proto" in params:
            try:
                self.option_nl_after_func_class_proto.setValue(int(params["nl_after_func_class_proto"]))
            except:
                pass
        if "nl_after_func_class_proto_group" in params:
            try:
                self.option_nl_after_func_class_proto_group.setValue(int(params["nl_after_func_class_proto_group"]))
            except:
                pass
        if "nl_class_leave_one_liner_groups" in params:
            try:
                self.option_nl_class_leave_one_liner_groups.setCurrentText(params["nl_class_leave_one_liner_groups"])
            except:
                pass
        if "nl_after_func_body" in params:
            try:
                self.option_nl_after_func_body.setValue(int(params["nl_after_func_body"]))
            except:
                pass
        if "nl_min_after_func_body" in params:
            try:
                self.option_nl_min_after_func_body.setValue(int(params["nl_min_after_func_body"]))
            except:
                pass
        if "nl_max_after_func_body" in params:
            try:
                self.option_nl_max_after_func_body.setValue(int(params["nl_max_after_func_body"]))
            except:
                pass
        if "nl_after_func_body_class" in params:
            try:
                self.option_nl_after_func_body_class.setValue(int(params["nl_after_func_body_class"]))
            except:
                pass
        if "nl_after_func_body_one_liner" in params:
            try:
                self.option_nl_after_func_body_one_liner.setValue(int(params["nl_after_func_body_one_liner"]))
            except:
                pass
        if "nl_typedef_blk_start" in params:
            try:
                self.option_nl_typedef_blk_start.setValue(int(params["nl_typedef_blk_start"]))
            except:
                pass
        if "nl_typedef_blk_end" in params:
            try:
                self.option_nl_typedef_blk_end.setValue(int(params["nl_typedef_blk_end"]))
            except:
                pass
        if "nl_typedef_blk_in" in params:
            try:
                self.option_nl_typedef_blk_in.setValue(int(params["nl_typedef_blk_in"]))
            except:
                pass
        if "nl_var_def_blk_end_func_top" in params:
            try:
                self.option_nl_var_def_blk_end_func_top.setValue(int(params["nl_var_def_blk_end_func_top"]))
            except:
                pass
        if "nl_var_def_blk_start" in params:
            try:
                self.option_nl_var_def_blk_start.setValue(int(params["nl_var_def_blk_start"]))
            except:
                pass
        if "nl_var_def_blk_end" in params:
            try:
                self.option_nl_var_def_blk_end.setValue(int(params["nl_var_def_blk_end"]))
            except:
                pass
        if "nl_var_def_blk_in" in params:
            try:
                self.option_nl_var_def_blk_in.setValue(int(params["nl_var_def_blk_in"]))
            except:
                pass
        if "nl_before_block_comment" in params:
            try:
                self.option_nl_before_block_comment.setValue(int(params["nl_before_block_comment"]))
            except:
                pass
        if "nl_before_c_comment" in params:
            try:
                self.option_nl_before_c_comment.setValue(int(params["nl_before_c_comment"]))
            except:
                pass
        if "nl_before_cpp_comment" in params:
            try:
                self.option_nl_before_cpp_comment.setValue(int(params["nl_before_cpp_comment"]))
            except:
                pass
        if "nl_after_multiline_comment" in params:
            try:
                self.option_nl_after_multiline_comment.setCurrentText(params["nl_after_multiline_comment"])
            except:
                pass
        if "nl_after_label_colon" in params:
            try:
                self.option_nl_after_label_colon.setCurrentText(params["nl_after_label_colon"])
            except:
                pass
        if "nl_before_struct" in params:
            try:
                self.option_nl_before_struct.setValue(int(params["nl_before_struct"]))
            except:
                pass
        if "nl_after_struct" in params:
            try:
                self.option_nl_after_struct.setValue(int(params["nl_after_struct"]))
            except:
                pass
        if "nl_before_class" in params:
            try:
                self.option_nl_before_class.setValue(int(params["nl_before_class"]))
            except:
                pass
        if "nl_after_class" in params:
            try:
                self.option_nl_after_class.setValue(int(params["nl_after_class"]))
            except:
                pass
        if "nl_before_namespace" in params:
            try:
                self.option_nl_before_namespace.setValue(int(params["nl_before_namespace"]))
            except:
                pass
        if "nl_inside_namespace" in params:
            try:
                self.option_nl_inside_namespace.setValue(int(params["nl_inside_namespace"]))
            except:
                pass
        if "nl_after_namespace" in params:
            try:
                self.option_nl_after_namespace.setValue(int(params["nl_after_namespace"]))
            except:
                pass
        if "nl_before_access_spec" in params:
            try:
                self.option_nl_before_access_spec.setValue(int(params["nl_before_access_spec"]))
            except:
                pass
        if "nl_after_access_spec" in params:
            try:
                self.option_nl_after_access_spec.setValue(int(params["nl_after_access_spec"]))
            except:
                pass
        if "nl_comment_func_def" in params:
            try:
                self.option_nl_comment_func_def.setValue(int(params["nl_comment_func_def"]))
            except:
                pass
        if "nl_after_try_catch_finally" in params:
            try:
                self.option_nl_after_try_catch_finally.setValue(int(params["nl_after_try_catch_finally"]))
            except:
                pass
        if "nl_around_cs_property" in params:
            try:
                self.option_nl_around_cs_property.setValue(int(params["nl_around_cs_property"]))
            except:
                pass
        if "nl_between_get_set" in params:
            try:
                self.option_nl_between_get_set.setValue(int(params["nl_between_get_set"]))
            except:
                pass
        if "nl_property_brace" in params:
            try:
                self.option_nl_property_brace.setCurrentText(params["nl_property_brace"])
            except:
                pass
        if "eat_blanks_after_open_brace" in params:
            try:
                self.option_eat_blanks_after_open_brace.setCurrentText(params["eat_blanks_after_open_brace"])
            except:
                pass
        if "eat_blanks_before_close_brace" in params:
            try:
                self.option_eat_blanks_before_close_brace.setCurrentText(params["eat_blanks_before_close_brace"])
            except:
                pass
        if "nl_remove_extra_newlines" in params:
            try:
                self.option_nl_remove_extra_newlines.setValue(int(params["nl_remove_extra_newlines"]))
            except:
                pass
        if "nl_after_annotation" in params:
            try:
                self.option_nl_after_annotation.setCurrentText(params["nl_after_annotation"])
            except:
                pass
        if "nl_between_annotation" in params:
            try:
                self.option_nl_between_annotation.setCurrentText(params["nl_between_annotation"])
            except:
                pass
        if "nl_before_whole_file_ifdef" in params:
            try:
                self.option_nl_before_whole_file_ifdef.setValue(int(params["nl_before_whole_file_ifdef"]))
            except:
                pass
        if "nl_after_whole_file_ifdef" in params:
            try:
                self.option_nl_after_whole_file_ifdef.setValue(int(params["nl_after_whole_file_ifdef"]))
            except:
                pass
        if "nl_before_whole_file_endif" in params:
            try:
                self.option_nl_before_whole_file_endif.setValue(int(params["nl_before_whole_file_endif"]))
            except:
                pass
        if "nl_after_whole_file_endif" in params:
            try:
                self.option_nl_after_whole_file_endif.setValue(int(params["nl_after_whole_file_endif"]))
            except:
                pass
        #================== Positioning options =============================================================
        if "pos_arith" in params:
            try:
                self.option_pos_arith.setCurrentText(params["pos_arith"])
            except:
                pass
        if "pos_assign" in params:
            try:
                self.option_pos_assign.setCurrentText(params["pos_assign"])
            except:
                pass
        if "pos_bool" in params:
            try:
                self.option_pos_bool.setCurrentText(params["pos_bool"])
            except:
                pass
        if "pos_compare" in params:
            try:
                self.option_pos_compare.setCurrentText(params["pos_compare"])
            except:
                pass
        if "pos_conditional" in params:
            try:
                self.option_pos_conditional.setCurrentText(params["pos_conditional"])
            except:
                pass
        if "pos_comma" in params:
            try:
                self.option_pos_comma.setCurrentText(params["pos_comma"])
            except:
                pass
        if "pos_enum_comma" in params:
            try:
                self.option_pos_enum_comma.setCurrentText(params["pos_enum_comma"])
            except:
                pass
        if "pos_class_comma" in params:
            try:
                self.option_pos_class_comma.setCurrentText(params["pos_class_comma"])
            except:
                pass
        if "pos_constr_comma" in params:
            try:
                self.option_pos_constr_comma.setCurrentText(params["pos_constr_comma"])
            except:
                pass
        if "pos_class_colon" in params:
            try:
                self.option_pos_class_colon.setCurrentText(params["pos_class_colon"])
            except:
                pass
        if "pos_constr_colon" in params:
            try:
                self.option_pos_constr_colon.setCurrentText(params["pos_constr_colon"])
            except:
                pass
        if "pos_shift" in params:
            try:
                self.option_pos_shift.setCurrentText(params["pos_shift"])
            except:
                pass
        #================== Line splitting options ==========================================================
        if "code_width" in params:
            try:
                self.option_code_width.setValue(int(params["code_width"]))
            except:
                pass
        if "ls_for_split_full" in params:
            try:
                self.option_ls_for_split_full.setCurrentText(params["ls_for_split_full"])
            except:
                pass
        if "ls_func_split_full" in params:
            try:
                self.option_ls_func_split_full.setCurrentText(params["ls_func_split_full"])
            except:
                pass
        if "ls_code_width" in params:
            try:
                self.option_ls_code_width.setCurrentText(params["ls_code_width"])
            except:
                pass
        #================== Code alignment options (not left column spaces/tabs) ============================
        if "align_keep_tabs" in params:
            try:
                self.option_align_keep_tabs.setCurrentText(params["align_keep_tabs"])
            except:
                pass
        if "align_with_tabs" in params:
            try:
                self.option_align_with_tabs.setCurrentText(params["align_with_tabs"])
            except:
                pass
        if "align_on_tabstop" in params:
            try:
                self.option_align_on_tabstop.setCurrentText(params["align_on_tabstop"])
            except:
                pass
        if "align_number_right" in params:
            try:
                self.option_align_number_right.setCurrentText(params["align_number_right"])
            except:
                pass
        if "align_keep_extra_space" in params:
            try:
                self.option_align_keep_extra_space.setCurrentText(params["align_keep_extra_space"])
            except:
                pass
        if "align_func_params" in params:
            try:
                self.option_align_func_params.setCurrentText(params["align_func_params"])
            except:
                pass
        if "align_func_params_span" in params:
            try:
                self.option_align_func_params_span.setValue(int(params["align_func_params_span"]))
            except:
                pass
        if "align_func_params_thresh" in params:
            try:
                self.option_align_func_params_thresh.setValue(int(params["align_func_params_thresh"]))
            except:
                pass
        if "align_func_params_gap" in params:
            try:
                self.option_align_func_params_gap.setValue(int(params["align_func_params_gap"]))
            except:
                pass
        if "align_constr_value_span" in params:
            try:
                self.option_align_constr_value_span.setValue(int(params["align_constr_value_span"]))
            except:
                pass
        if "align_constr_value_thresh" in params:
            try:
                self.option_align_constr_value_thresh.setValue(int(params["align_constr_value_thresh"]))
            except:
                pass
        if "align_constr_value_gap" in params:
            try:
                self.option_align_constr_value_gap.setValue(int(params["align_constr_value_gap"]))
            except:
                pass
        if "align_same_func_call_params" in params:
            try:
                self.option_align_same_func_call_params.setCurrentText(params["align_same_func_call_params"])
            except:
                pass
        if "align_same_func_call_params_span" in params:
            try:
                self.option_align_same_func_call_params_span.setValue(int(params["align_same_func_call_params_span"]))
            except:
                pass
        if "align_same_func_call_params_thresh" in params:
            try:
                self.option_align_same_func_call_params_thresh.setValue(int(params["align_same_func_call_params_thresh"]))
            except:
                pass
        if "align_var_def_span" in params:
            try:
                self.option_align_var_def_span.setValue(int(params["align_var_def_span"]))
            except:
                pass
        if "align_var_def_star_style" in params:
            try:
                self.option_align_var_def_star_style.setValue(int(params["align_var_def_star_style"]))
            except:
                pass
        if "align_var_def_amp_style" in params:
            try:
                self.option_align_var_def_amp_style.setValue(int(params["align_var_def_amp_style"]))
            except:
                pass
        if "align_var_def_thresh" in params:
            try:
                self.option_align_var_def_thresh.setValue(int(params["align_var_def_thresh"]))
            except:
                pass
        if "align_var_def_gap" in params:
            try:
                self.option_align_var_def_gap.setValue(int(params["align_var_def_gap"]))
            except:
                pass
        if "align_var_def_colon" in params:
            try:
                self.option_align_var_def_colon.setCurrentText(params["align_var_def_colon"])
            except:
                pass
        if "align_var_def_colon_gap" in params:
            try:
                self.option_align_var_def_colon_gap.setValue(int(params["align_var_def_colon_gap"]))
            except:
                pass
        if "align_var_def_attribute" in params:
            try:
                self.option_align_var_def_attribute.setCurrentText(params["align_var_def_attribute"])
            except:
                pass
        if "align_var_def_inline" in params:
            try:
                self.option_align_var_def_inline.setCurrentText(params["align_var_def_inline"])
            except:
                pass
        if "align_assign_span" in params:
            try:
                self.option_align_assign_span.setValue(int(params["align_assign_span"]))
            except:
                pass
        if "align_assign_func_proto_span" in params:
            try:
                self.option_align_assign_func_proto_span.setValue(int(params["align_assign_func_proto_span"]))
            except:
                pass
        if "align_assign_thresh" in params:
            try:
                self.option_align_assign_thresh.setValue(int(params["align_assign_thresh"]))
            except:
                pass
        if "align_assign_on_multi_var_defs" in params:
            try:
                self.option_align_assign_on_multi_var_defs.setCurrentText(params["align_assign_on_multi_var_defs"])
            except:
                pass
        if "align_braced_init_list_span" in params:
            try:
                self.option_align_braced_init_list_span.setValue(int(params["align_braced_init_list_span"]))
            except:
                pass
        if "align_braced_init_list_thresh" in params:
            try:
                self.option_align_braced_init_list_thresh.setValue(int(params["align_braced_init_list_thresh"]))
            except:
                pass
        if "align_assign_decl_func" in params:
            try:
                self.option_align_assign_decl_func.setValue(int(params["align_assign_decl_func"]))
            except:
                pass
        if "align_enum_equ_span" in params:
            try:
                self.option_align_enum_equ_span.setValue(int(params["align_enum_equ_span"]))
            except:
                pass
        if "align_enum_equ_thresh" in params:
            try:
                self.option_align_enum_equ_thresh.setValue(int(params["align_enum_equ_thresh"]))
            except:
                pass
        if "align_var_class_span" in params:
            try:
                self.option_align_var_class_span.setValue(int(params["align_var_class_span"]))
            except:
                pass
        if "align_var_class_thresh" in params:
            try:
                self.option_align_var_class_thresh.setValue(int(params["align_var_class_thresh"]))
            except:
                pass
        if "align_var_class_gap" in params:
            try:
                self.option_align_var_class_gap.setValue(int(params["align_var_class_gap"]))
            except:
                pass
        if "align_var_struct_span" in params:
            try:
                self.option_align_var_struct_span.setValue(int(params["align_var_struct_span"]))
            except:
                pass
        if "align_var_struct_thresh" in params:
            try:
                self.option_align_var_struct_thresh.setValue(int(params["align_var_struct_thresh"]))
            except:
                pass
        if "align_var_struct_gap" in params:
            try:
                self.option_align_var_struct_gap.setValue(int(params["align_var_struct_gap"]))
            except:
                pass
        if "align_struct_init_span" in params:
            try:
                self.option_align_struct_init_span.setValue(int(params["align_struct_init_span"]))
            except:
                pass
        if "align_typedef_span" in params:
            try:
                self.option_align_typedef_span.setValue(int(params["align_typedef_span"]))
            except:
                pass
        if "align_typedef_gap" in params:
            try:
                self.option_align_typedef_gap.setValue(int(params["align_typedef_gap"]))
            except:
                pass
        if "align_typedef_func" in params:
            try:
                self.option_align_typedef_func.setValue(int(params["align_typedef_func"]))
            except:
                pass
        if "align_typedef_star_style" in params:
            try:
                self.option_align_typedef_star_style.setValue(int(params["align_typedef_star_style"]))
            except:
                pass
        if "align_typedef_amp_style" in params:
            try:
                self.option_align_typedef_amp_style.setValue(int(params["align_typedef_amp_style"]))
            except:
                pass
        if "align_right_cmt_span" in params:
            try:
                self.option_align_right_cmt_span.setValue(int(params["align_right_cmt_span"]))
            except:
                pass
        if "align_right_cmt_gap" in params:
            try:
                self.option_align_right_cmt_gap.setValue(int(params["align_right_cmt_gap"]))
            except:
                pass
        if "align_right_cmt_mix" in params:
            try:
                self.option_align_right_cmt_mix.setCurrentText(params["align_right_cmt_mix"])
            except:
                pass
        if "align_right_cmt_same_level" in params:
            try:
                self.option_align_right_cmt_same_level.setCurrentText(params["align_right_cmt_same_level"])
            except:
                pass
        if "align_right_cmt_at_col" in params:
            try:
                self.option_align_right_cmt_at_col.setValue(int(params["align_right_cmt_at_col"]))
            except:
                pass
        if "align_func_proto_span" in params:
            try:
                self.option_align_func_proto_span.setValue(int(params["align_func_proto_span"]))
            except:
                pass
        if "align_func_proto_span_ignore_cont_lines" in params:
            try:
                self.option_align_func_proto_span_ignore_cont_lines.setCurrentText(params["align_func_proto_span_ignore_cont_lines"])
            except:
                pass
        if "align_func_proto_star_style" in params:
            try:
                self.option_align_func_proto_star_style.setValue(int(params["align_func_proto_star_style"]))
            except:
                pass
        if "align_func_proto_amp_style" in params:
            try:
                self.option_align_func_proto_amp_style.setValue(int(params["align_func_proto_amp_style"]))
            except:
                pass
        if "align_func_proto_thresh" in params:
            try:
                self.option_align_func_proto_thresh.setValue(int(params["align_func_proto_thresh"]))
            except:
                pass
        if "align_func_proto_gap" in params:
            try:
                self.option_align_func_proto_gap.setValue(int(params["align_func_proto_gap"]))
            except:
                pass
        if "align_on_operator" in params:
            try:
                self.option_align_on_operator.setCurrentText(params["align_on_operator"])
            except:
                pass
        if "align_mix_var_proto" in params:
            try:
                self.option_align_mix_var_proto.setCurrentText(params["align_mix_var_proto"])
            except:
                pass
        if "align_single_line_func" in params:
            try:
                self.option_align_single_line_func.setCurrentText(params["align_single_line_func"])
            except:
                pass
        if "align_single_line_brace" in params:
            try:
                self.option_align_single_line_brace.setCurrentText(params["align_single_line_brace"])
            except:
                pass
        if "align_single_line_brace_gap" in params:
            try:
                self.option_align_single_line_brace_gap.setValue(int(params["align_single_line_brace_gap"]))
            except:
                pass
        if "align_oc_msg_spec_span" in params:
            try:
                self.option_align_oc_msg_spec_span.setValue(int(params["align_oc_msg_spec_span"]))
            except:
                pass
        if "align_nl_cont" in params:
            try:
                self.option_align_nl_cont.setValue(int(params["align_nl_cont"]))
            except:
                pass
        if "align_nl_cont_spaces" in params:
            try:
                self.option_align_nl_cont_spaces.setValue(int(params["align_nl_cont_spaces"]))
            except:
                pass
        if "align_pp_define_together" in params:
            try:
                self.option_align_pp_define_together.setCurrentText(params["align_pp_define_together"])
            except:
                pass
        if "align_pp_define_span" in params:
            try:
                self.option_align_pp_define_span.setValue(int(params["align_pp_define_span"]))
            except:
                pass
        if "align_pp_define_gap" in params:
            try:
                self.option_align_pp_define_gap.setValue(int(params["align_pp_define_gap"]))
            except:
                pass
        if "align_left_shift" in params:
            try:
                self.option_align_left_shift.setCurrentText(params["align_left_shift"])
            except:
                pass
        if "align_eigen_comma_init" in params:
            try:
                self.option_align_eigen_comma_init.setCurrentText(params["align_eigen_comma_init"])
            except:
                pass
        if "align_asm_colon" in params:
            try:
                self.option_align_asm_colon.setCurrentText(params["align_asm_colon"])
            except:
                pass
        if "align_oc_msg_colon_span" in params:
            try:
                self.option_align_oc_msg_colon_span.setValue(int(params["align_oc_msg_colon_span"]))
            except:
                pass
        if "align_oc_msg_colon_first" in params:
            try:
                self.option_align_oc_msg_colon_first.setCurrentText(params["align_oc_msg_colon_first"])
            except:
                pass
        if "align_oc_decl_colon" in params:
            try:
                self.option_align_oc_decl_colon.setCurrentText(params["align_oc_decl_colon"])
            except:
                pass
        if "align_oc_msg_colon_xcode_like" in params:
            try:
                self.option_align_oc_msg_colon_xcode_like.setCurrentText(params["align_oc_msg_colon_xcode_like"])
            except:
                pass
        #================== Comment modification options ====================================================
        if "cmt_width" in params:
            try:
                self.option_cmt_width.setValue(int(params["cmt_width"]))
            except:
                pass
        if "cmt_reflow_mode" in params:
            try:
                self.option_cmt_reflow_mode.setValue(int(params["cmt_reflow_mode"]))
            except:
                pass
        if "cmt_reflow_fold_regex_file" in params:
            try:
                self.option_cmt_reflow_fold_regex_file.setText(params["cmt_reflow_fold_regex_file"])
            except:
                pass
        if "cmt_reflow_indent_to_paragraph_start" in params:
            try:
                self.option_cmt_reflow_indent_to_paragraph_start.setCurrentText(params["cmt_reflow_indent_to_paragraph_start"])
            except:
                pass
        if "cmt_convert_tab_to_spaces" in params:
            try:
                self.option_cmt_convert_tab_to_spaces.setCurrentText(params["cmt_convert_tab_to_spaces"])
            except:
                pass
        if "cmt_indent_multi" in params:
            try:
                self.option_cmt_indent_multi.setCurrentText(params["cmt_indent_multi"])
            except:
                pass
        if "cmt_align_doxygen_javadoc_tags" in params:
            try:
                self.option_cmt_align_doxygen_javadoc_tags.setCurrentText(params["cmt_align_doxygen_javadoc_tags"])
            except:
                pass
        if "cmt_sp_before_doxygen_javadoc_tags" in params:
            try:
                self.option_cmt_sp_before_doxygen_javadoc_tags.setValue(int(params["cmt_sp_before_doxygen_javadoc_tags"]))
            except:
                pass
        if "cmt_trailing_single_line_c_to_cpp" in params:
            try:
                self.option_cmt_trailing_single_line_c_to_cpp.setCurrentText(params["cmt_trailing_single_line_c_to_cpp"])
            except:
                pass
        if "cmt_c_group" in params:
            try:
                self.option_cmt_c_group.setCurrentText(params["cmt_c_group"])
            except:
                pass
        if "cmt_c_nl_start" in params:
            try:
                self.option_cmt_c_nl_start.setCurrentText(params["cmt_c_nl_start"])
            except:
                pass
        if "cmt_c_nl_end" in params:
            try:
                self.option_cmt_c_nl_end.setCurrentText(params["cmt_c_nl_end"])
            except:
                pass
        if "cmt_cpp_to_c" in params:
            try:
                self.option_cmt_cpp_to_c.setCurrentText(params["cmt_cpp_to_c"])
            except:
                pass
        if "cmt_cpp_group" in params:
            try:
                self.option_cmt_cpp_group.setCurrentText(params["cmt_cpp_group"])
            except:
                pass
        if "cmt_cpp_nl_start" in params:
            try:
                self.option_cmt_cpp_nl_start.setCurrentText(params["cmt_cpp_nl_start"])
            except:
                pass
        if "cmt_cpp_nl_end" in params:
            try:
                self.option_cmt_cpp_nl_end.setCurrentText(params["cmt_cpp_nl_end"])
            except:
                pass
        if "cmt_star_cont" in params:
            try:
                self.option_cmt_star_cont.setCurrentText(params["cmt_star_cont"])
            except:
                pass
        if "cmt_sp_before_star_cont" in params:
            try:
                self.option_cmt_sp_before_star_cont.setValue(int(params["cmt_sp_before_star_cont"]))
            except:
                pass
        if "cmt_sp_after_star_cont" in params:
            try:
                self.option_cmt_sp_after_star_cont.setValue(int(params["cmt_sp_after_star_cont"]))
            except:
                pass
        if "cmt_multi_check_last" in params:
            try:
                self.option_cmt_multi_check_last.setCurrentText(params["cmt_multi_check_last"])
            except:
                pass
        if "cmt_multi_first_len_minimum" in params:
            try:
                self.option_cmt_multi_first_len_minimum.setValue(int(params["cmt_multi_first_len_minimum"]))
            except:
                pass
        if "cmt_insert_file_header" in params:
            try:
                self.option_cmt_insert_file_header.setText(params["cmt_insert_file_header"])
            except:
                pass
        if "cmt_insert_file_footer" in params:
            try:
                self.option_cmt_insert_file_footer.setText(params["cmt_insert_file_footer"])
            except:
                pass
        if "cmt_insert_func_header" in params:
            try:
                self.option_cmt_insert_func_header.setText(params["cmt_insert_func_header"])
            except:
                pass
        if "cmt_insert_class_header" in params:
            try:
                self.option_cmt_insert_class_header.setText(params["cmt_insert_class_header"])
            except:
                pass
        if "cmt_insert_oc_msg_header" in params:
            try:
                self.option_cmt_insert_oc_msg_header.setText(params["cmt_insert_oc_msg_header"])
            except:
                pass
        if "cmt_insert_before_preproc" in params:
            try:
                self.option_cmt_insert_before_preproc.setCurrentText(params["cmt_insert_before_preproc"])
            except:
                pass
        if "cmt_insert_before_inlines" in params:
            try:
                self.option_cmt_insert_before_inlines.setCurrentText(params["cmt_insert_before_inlines"])
            except:
                pass
        if "cmt_insert_before_ctor_dtor" in params:
            try:
                self.option_cmt_insert_before_ctor_dtor.setCurrentText(params["cmt_insert_before_ctor_dtor"])
            except:
                pass
        #================== Code modifying options (non-whitespace) =========================================
        if "mod_full_brace_do" in params:
            try:
                self.option_mod_full_brace_do.setCurrentText(params["mod_full_brace_do"])
            except:
                pass
        if "mod_full_brace_for" in params:
            try:
                self.option_mod_full_brace_for.setCurrentText(params["mod_full_brace_for"])
            except:
                pass
        if "mod_full_brace_function" in params:
            try:
                self.option_mod_full_brace_function.setCurrentText(params["mod_full_brace_function"])
            except:
                pass
        if "mod_full_brace_if" in params:
            try:
                self.option_mod_full_brace_if.setCurrentText(params["mod_full_brace_if"])
            except:
                pass
        if "mod_full_brace_if_chain" in params:
            try:
                self.option_mod_full_brace_if_chain.setValue(int(params["mod_full_brace_if_chain"]))
            except:
                pass
        if "mod_full_brace_if_chain_only" in params:
            try:
                self.option_mod_full_brace_if_chain_only.setCurrentText(params["mod_full_brace_if_chain_only"])
            except:
                pass
        if "mod_full_brace_while" in params:
            try:
                self.option_mod_full_brace_while.setCurrentText(params["mod_full_brace_while"])
            except:
                pass
        if "mod_full_brace_using" in params:
            try:
                self.option_mod_full_brace_using.setCurrentText(params["mod_full_brace_using"])
            except:
                pass
        if "mod_full_brace_nl" in params:
            try:
                self.option_mod_full_brace_nl.setValue(int(params["mod_full_brace_nl"]))
            except:
                pass
        if "mod_full_brace_nl_block_rem_mlcond" in params:
            try:
                self.option_mod_full_brace_nl_block_rem_mlcond.setCurrentText(params["mod_full_brace_nl_block_rem_mlcond"])
            except:
                pass
        if "mod_paren_on_return" in params:
            try:
                self.option_mod_paren_on_return.setCurrentText(params["mod_paren_on_return"])
            except:
                pass
        if "mod_paren_on_throw" in params:
            try:
                self.option_mod_paren_on_throw.setCurrentText(params["mod_paren_on_throw"])
            except:
                pass
        if "mod_pawn_semicolon" in params:
            try:
                self.option_mod_pawn_semicolon.setCurrentText(params["mod_pawn_semicolon"])
            except:
                pass
        if "mod_full_paren_if_bool" in params:
            try:
                self.option_mod_full_paren_if_bool.setCurrentText(params["mod_full_paren_if_bool"])
            except:
                pass
        if "mod_full_paren_assign_bool" in params:
            try:
                self.option_mod_full_paren_assign_bool.setCurrentText(params["mod_full_paren_assign_bool"])
            except:
                pass
        if "mod_full_paren_return_bool" in params:
            try:
                self.option_mod_full_paren_return_bool.setCurrentText(params["mod_full_paren_return_bool"])
            except:
                pass
        if "mod_remove_extra_semicolon" in params:
            try:
                self.option_mod_remove_extra_semicolon.setCurrentText(params["mod_remove_extra_semicolon"])
            except:
                pass
        if "mod_remove_duplicate_include" in params:
            try:
                self.option_mod_remove_duplicate_include.setCurrentText(params["mod_remove_duplicate_include"])
            except:
                pass
        if "mod_add_force_c_closebrace_comment" in params:
            try:
                self.option_mod_add_force_c_closebrace_comment.setCurrentText(params["mod_add_force_c_closebrace_comment"])
            except:
                pass
        if "mod_add_long_function_closebrace_comment" in params:
            try:
                self.option_mod_add_long_function_closebrace_comment.setValue(int(params["mod_add_long_function_closebrace_comment"]))
            except:
                pass
        if "mod_add_long_namespace_closebrace_comment" in params:
            try:
                self.option_mod_add_long_namespace_closebrace_comment.setValue(int(params["mod_add_long_namespace_closebrace_comment"]))
            except:
                pass
        if "mod_add_long_class_closebrace_comment" in params:
            try:
                self.option_mod_add_long_class_closebrace_comment.setValue(int(params["mod_add_long_class_closebrace_comment"]))
            except:
                pass
        if "mod_add_long_switch_closebrace_comment" in params:
            try:
                self.option_mod_add_long_switch_closebrace_comment.setValue(int(params["mod_add_long_switch_closebrace_comment"]))
            except:
                pass
        if "mod_add_long_ifdef_endif_comment" in params:
            try:
                self.option_mod_add_long_ifdef_endif_comment.setValue(int(params["mod_add_long_ifdef_endif_comment"]))
            except:
                pass
        if "mod_add_long_ifdef_else_comment" in params:
            try:
                self.option_mod_add_long_ifdef_else_comment.setValue(int(params["mod_add_long_ifdef_else_comment"]))
            except:
                pass
        if "mod_sort_case_sensitive" in params:
            try:
                self.option_mod_sort_case_sensitive.setCurrentText(params["mod_sort_case_sensitive"])
            except:
                pass
        if "mod_sort_import" in params:
            try:
                self.option_mod_sort_import.setCurrentText(params["mod_sort_import"])
            except:
                pass
        if "mod_sort_using" in params:
            try:
                self.option_mod_sort_using.setCurrentText(params["mod_sort_using"])
            except:
                pass
        if "mod_sort_include" in params:
            try:
                self.option_mod_sort_include.setCurrentText(params["mod_sort_include"])
            except:
                pass
        if "mod_sort_incl_import_prioritize_filename" in params:
            try:
                self.option_mod_sort_incl_import_prioritize_filename.setCurrentText(params["mod_sort_incl_import_prioritize_filename"])
            except:
                pass
        if "mod_sort_incl_import_prioritize_extensionless" in params:
            try:
                self.option_mod_sort_incl_import_prioritize_extensionless.setCurrentText(params["mod_sort_incl_import_prioritize_extensionless"])
            except:
                pass
        if "mod_sort_incl_import_prioritize_angle_over_quotes" in params:
            try:
                self.option_mod_sort_incl_import_prioritize_angle_over_quotes.setCurrentText(params["mod_sort_incl_import_prioritize_angle_over_quotes"])
            except:
                pass
        if "mod_sort_incl_import_ignore_extension" in params:
            try:
                self.option_mod_sort_incl_import_ignore_extension.setCurrentText(params["mod_sort_incl_import_ignore_extension"])
            except:
                pass
        if "mod_sort_incl_import_grouping_enabled" in params:
            try:
                self.option_mod_sort_incl_import_grouping_enabled.setCurrentText(params["mod_sort_incl_import_grouping_enabled"])
            except:
                pass
        if "mod_move_case_break" in params:
            try:
                self.option_mod_move_case_break.setCurrentText(params["mod_move_case_break"])
            except:
                pass
        if "mod_move_case_return" in params:
            try:
                self.option_mod_move_case_return.setCurrentText(params["mod_move_case_return"])
            except:
                pass
        if "mod_case_brace" in params:
            try:
                self.option_mod_case_brace.setCurrentText(params["mod_case_brace"])
            except:
                pass
        if "mod_remove_empty_return" in params:
            try:
                self.option_mod_remove_empty_return.setCurrentText(params["mod_remove_empty_return"])
            except:
                pass
        if "mod_enum_last_comma" in params:
            try:
                self.option_mod_enum_last_comma.setCurrentText(params["mod_enum_last_comma"])
            except:
                pass
        if "mod_infinite_loop" in params:
            try:
                self.option_mod_infinite_loop.setValue(int(params["mod_infinite_loop"]))
            except:
                pass
        if "mod_int_short" in params:
            try:
                self.option_mod_int_short.setCurrentText(params["mod_int_short"])
            except:
                pass
        if "mod_short_int" in params:
            try:
                self.option_mod_short_int.setCurrentText(params["mod_short_int"])
            except:
                pass
        if "mod_int_long" in params:
            try:
                self.option_mod_int_long.setCurrentText(params["mod_int_long"])
            except:
                pass
        if "mod_long_int" in params:
            try:
                self.option_mod_long_int.setCurrentText(params["mod_long_int"])
            except:
                pass
        if "mod_int_signed" in params:
            try:
                self.option_mod_int_signed.setCurrentText(params["mod_int_signed"])
            except:
                pass
        if "mod_signed_int" in params:
            try:
                self.option_mod_signed_int.setCurrentText(params["mod_signed_int"])
            except:
                pass
        if "mod_int_unsigned" in params:
            try:
                self.option_mod_int_unsigned.setCurrentText(params["mod_int_unsigned"])
            except:
                pass
        if "mod_unsigned_int" in params:
            try:
                self.option_mod_unsigned_int.setCurrentText(params["mod_unsigned_int"])
            except:
                pass
        if "mod_int_prefer_int_on_left" in params:
            try:
                self.option_mod_int_prefer_int_on_left.setCurrentText(params["mod_int_prefer_int_on_left"])
            except:
                pass
        if "mod_sort_oc_properties" in params:
            try:
                self.option_mod_sort_oc_properties.setCurrentText(params["mod_sort_oc_properties"])
            except:
                pass
        if "mod_sort_oc_property_class_weight" in params:
            try:
                self.option_mod_sort_oc_property_class_weight.setValue(int(params["mod_sort_oc_property_class_weight"]))
            except:
                pass
        if "mod_sort_oc_property_thread_safe_weight" in params:
            try:
                self.option_mod_sort_oc_property_thread_safe_weight.setValue(int(params["mod_sort_oc_property_thread_safe_weight"]))
            except:
                pass
        if "mod_sort_oc_property_readwrite_weight" in params:
            try:
                self.option_mod_sort_oc_property_readwrite_weight.setValue(int(params["mod_sort_oc_property_readwrite_weight"]))
            except:
                pass
        if "mod_sort_oc_property_reference_weight" in params:
            try:
                self.option_mod_sort_oc_property_reference_weight.setValue(int(params["mod_sort_oc_property_reference_weight"]))
            except:
                pass
        if "mod_sort_oc_property_getter_weight" in params:
            try:
                self.option_mod_sort_oc_property_getter_weight.setValue(int(params["mod_sort_oc_property_getter_weight"]))
            except:
                pass
        if "mod_sort_oc_property_setter_weight" in params:
            try:
                self.option_mod_sort_oc_property_setter_weight.setValue(int(params["mod_sort_oc_property_setter_weight"]))
            except:
                pass
        if "mod_sort_oc_property_nullability_weight" in params:
            try:
                self.option_mod_sort_oc_property_nullability_weight.setValue(int(params["mod_sort_oc_property_nullability_weight"]))
            except:
                pass
        #================== Preprocessor options ============================================================
        if "pp_indent_with_tabs" in params:
            try:
                self.option_pp_indent_with_tabs.setValue(int(params["pp_indent_with_tabs"]))
            except:
                pass
        if "pp_indent" in params:
            try:
                self.option_pp_indent.setCurrentText(params["pp_indent"])
            except:
                pass
        if "pp_indent_at_level" in params:
            try:
                self.option_pp_indent_at_level.setCurrentText(params["pp_indent_at_level"])
            except:
                pass
        if "pp_indent_at_level0" in params:
            try:
                self.option_pp_indent_at_level0.setCurrentText(params["pp_indent_at_level0"])
            except:
                pass
        if "pp_indent_count" in params:
            try:
                self.option_pp_indent_count.setValue(int(params["pp_indent_count"]))
            except:
                pass
        if "pp_space_after" in params:
            try:
                self.option_pp_space_after.setCurrentText(params["pp_space_after"])
            except:
                pass
        if "pp_space_count" in params:
            try:
                self.option_pp_space_count.setValue(int(params["pp_space_count"]))
            except:
                pass
        if "pp_indent_region" in params:
            try:
                self.option_pp_indent_region.setValue(int(params["pp_indent_region"]))
            except:
                pass
        if "pp_region_indent_code" in params:
            try:
                self.option_pp_region_indent_code.setCurrentText(params["pp_region_indent_code"])
            except:
                pass
        if "pp_indent_if" in params:
            try:
                self.option_pp_indent_if.setValue(int(params["pp_indent_if"]))
            except:
                pass
        if "pp_if_indent_code" in params:
            try:
                self.option_pp_if_indent_code.setCurrentText(params["pp_if_indent_code"])
            except:
                pass
        if "pp_indent_in_guard" in params:
            try:
                self.option_pp_indent_in_guard.setCurrentText(params["pp_indent_in_guard"])
            except:
                pass
        if "pp_define_at_level" in params:
            try:
                self.option_pp_define_at_level.setCurrentText(params["pp_define_at_level"])
            except:
                pass
        if "pp_include_at_level" in params:
            try:
                self.option_pp_include_at_level.setCurrentText(params["pp_include_at_level"])
            except:
                pass
        if "pp_ignore_define_body" in params:
            try:
                self.option_pp_ignore_define_body.setCurrentText(params["pp_ignore_define_body"])
            except:
                pass
        if "pp_multiline_define_body_indent" in params:
            try:
                self.option_pp_multiline_define_body_indent.setValue(int(params["pp_multiline_define_body_indent"]))
            except:
                pass
        if "pp_indent_case" in params:
            try:
                self.option_pp_indent_case.setCurrentText(params["pp_indent_case"])
            except:
                pass
        if "pp_indent_func_def" in params:
            try:
                self.option_pp_indent_func_def.setCurrentText(params["pp_indent_func_def"])
            except:
                pass
        if "pp_indent_extern" in params:
            try:
                self.option_pp_indent_extern.setCurrentText(params["pp_indent_extern"])
            except:
                pass
        if "pp_indent_brace" in params:
            try:
                self.option_pp_indent_brace.setValue(int(params["pp_indent_brace"]))
            except:
                pass
        if "pp_unbalanced_if_action" in params:
            try:
                self.option_pp_unbalanced_if_action.setValue(int(params["pp_unbalanced_if_action"]))
            except:
                pass
        #================== Sort includes options ===========================================================
        if "include_category_0" in params:
            try:
                self.option_include_category_0.setText(params["include_category_0"])
            except:
                pass
        if "include_category_1" in params:
            try:
                self.option_include_category_1.setText(params["include_category_1"])
            except:
                pass
        if "include_category_2" in params:
            try:
                self.option_include_category_2.setText(params["include_category_2"])
            except:
                pass
        #================== Use or Do not Use options =======================================================
        if "use_indent_func_call_param" in params:
            try:
                self.option_use_indent_func_call_param.setCurrentText(params["use_indent_func_call_param"])
            except:
                pass
        if "use_indent_continue_only_once" in params:
            try:
                self.option_use_indent_continue_only_once.setCurrentText(params["use_indent_continue_only_once"])
            except:
                pass
        if "indent_cpp_lambda_only_once" in params:
            try:
                self.option_indent_cpp_lambda_only_once.setCurrentText(params["indent_cpp_lambda_only_once"])
            except:
                pass
        if "use_sp_after_angle_always" in params:
            try:
                self.option_use_sp_after_angle_always.setCurrentText(params["use_sp_after_angle_always"])
            except:
                pass
        if "use_options_overriding_for_qt_macros" in params:
            try:
                self.option_use_options_overriding_for_qt_macros.setCurrentText(params["use_options_overriding_for_qt_macros"])
            except:
                pass
        if "use_form_feed_no_more_as_whitespace_character" in params:
            try:
                self.option_use_form_feed_no_more_as_whitespace_character.setCurrentText(params["use_form_feed_no_more_as_whitespace_character"])
            except:
                pass
        #================== Warn levels - 1: error, 2: warning (default), 3: note ===========================
        if "warn_level_tabs_found_in_verbatim_string_literals" in params:
            try:
                self.option_warn_level_tabs_found_in_verbatim_string_literals.setValue(int(params["warn_level_tabs_found_in_verbatim_string_literals"]))
            except:
                pass
        if "debug_max_number_of_loops" in params:
            try:
                self.option_debug_max_number_of_loops.setValue(int(params["debug_max_number_of_loops"]))
            except:
                pass
        if "debug_line_number_to_protocol" in params:
            try:
                self.option_debug_line_number_to_protocol.setValue(int(params["debug_line_number_to_protocol"]))
            except:
                pass
        if "debug_timeout" in params:
            try:
                self.option_debug_timeout.setValue(int(params["debug_timeout"]))
            except:
                pass
        if "debug_truncate" in params:
            try:
                self.option_debug_truncate.setValue(int(params["debug_truncate"]))
            except:
                pass
        if "debug_sort_the_tracks" in params:
            try:
                self.option_debug_sort_the_tracks.setCurrentText(params["debug_sort_the_tracks"])
            except:
                pass
        if "debug_decode_the_flags" in params:
            try:
                self.option_debug_decode_the_flags.setCurrentText(params["debug_decode_the_flags"])
            except:
                pass
        if "debug_use_the_exit_function_pop" in params:
            try:
                self.option_debug_use_the_exit_function_pop.setCurrentText(params["debug_use_the_exit_function_pop"])
            except:
                pass
        if "debug_print_version" in params:
            try:
                self.option_debug_print_version.setCurrentText(params["debug_print_version"])
            except:
                pass
        if "set_numbering_for_html_output" in params:
            try:
                self.option_set_numbering_for_html_output.setCurrentText(params["set_numbering_for_html_output"])
            except:
                pass
    ###########################################################################################
    ###########################################################################################
    ###########################################################################################
    ###########################################################################################
    ###########################################################################################
    def filter(self, filter):
        pass

        self.label_newlines.setVisible(filter=='' or 'newlines'.find(filter)!=-1)
        self.option_newlines.setVisible(filter=='' or 'newlines'.find(filter)!=-1)
        self.label_input_tab_size.setVisible(filter=='' or 'input_tab_size'.find(filter)!=-1)
        self.option_input_tab_size.setVisible(filter=='' or 'input_tab_size'.find(filter)!=-1)
        self.label_output_tab_size.setVisible(filter=='' or 'output_tab_size'.find(filter)!=-1)
        self.option_output_tab_size.setVisible(filter=='' or 'output_tab_size'.find(filter)!=-1)
        self.label_string_escape_char.setVisible(filter=='' or 'string_escape_char'.find(filter)!=-1)
        self.option_string_escape_char.setVisible(filter=='' or 'string_escape_char'.find(filter)!=-1)
        self.label_string_escape_char2.setVisible(filter=='' or 'string_escape_char2'.find(filter)!=-1)
        self.option_string_escape_char2.setVisible(filter=='' or 'string_escape_char2'.find(filter)!=-1)
        self.label_string_replace_tab_chars.setVisible(filter=='' or 'string_replace_tab_chars'.find(filter)!=-1)
        self.option_string_replace_tab_chars.setVisible(filter=='' or 'string_replace_tab_chars'.find(filter)!=-1)
        self.label_tok_split_gte.setVisible(filter=='' or 'tok_split_gte'.find(filter)!=-1)
        self.option_tok_split_gte.setVisible(filter=='' or 'tok_split_gte'.find(filter)!=-1)
        self.label_disable_processing_nl_cont.setVisible(filter=='' or 'disable_processing_nl_cont'.find(filter)!=-1)
        self.option_disable_processing_nl_cont.setVisible(filter=='' or 'disable_processing_nl_cont'.find(filter)!=-1)
        self.label_disable_processing_cmt.setVisible(filter=='' or 'disable_processing_cmt'.find(filter)!=-1)
        self.option_disable_processing_cmt.setVisible(filter=='' or 'disable_processing_cmt'.find(filter)!=-1)
        self.label_enable_processing_cmt.setVisible(filter=='' or 'enable_processing_cmt'.find(filter)!=-1)
        self.option_enable_processing_cmt.setVisible(filter=='' or 'enable_processing_cmt'.find(filter)!=-1)
        self.label_enable_digraphs.setVisible(filter=='' or 'enable_digraphs'.find(filter)!=-1)
        self.option_enable_digraphs.setVisible(filter=='' or 'enable_digraphs'.find(filter)!=-1)
        self.label_processing_cmt_as_regex.setVisible(filter=='' or 'processing_cmt_as_regex'.find(filter)!=-1)
        self.option_processing_cmt_as_regex.setVisible(filter=='' or 'processing_cmt_as_regex'.find(filter)!=-1)
        self.label_utf8_bom.setVisible(filter=='' or 'utf8_bom'.find(filter)!=-1)
        self.option_utf8_bom.setVisible(filter=='' or 'utf8_bom'.find(filter)!=-1)
        self.label_utf8_byte.setVisible(filter=='' or 'utf8_byte'.find(filter)!=-1)
        self.option_utf8_byte.setVisible(filter=='' or 'utf8_byte'.find(filter)!=-1)
        self.label_utf8_force.setVisible(filter=='' or 'utf8_force'.find(filter)!=-1)
        self.option_utf8_force.setVisible(filter=='' or 'utf8_force'.find(filter)!=-1)
        self.label_sp_arith.setVisible(filter=='' or 'sp_arith'.find(filter)!=-1)
        self.option_sp_arith.setVisible(filter=='' or 'sp_arith'.find(filter)!=-1)
        self.label_sp_arith_additive.setVisible(filter=='' or 'sp_arith_additive'.find(filter)!=-1)
        self.option_sp_arith_additive.setVisible(filter=='' or 'sp_arith_additive'.find(filter)!=-1)
        self.label_sp_assign.setVisible(filter=='' or 'sp_assign'.find(filter)!=-1)
        self.option_sp_assign.setVisible(filter=='' or 'sp_assign'.find(filter)!=-1)
        self.label_sp_cpp_lambda_assign.setVisible(filter=='' or 'sp_cpp_lambda_assign'.find(filter)!=-1)
        self.option_sp_cpp_lambda_assign.setVisible(filter=='' or 'sp_cpp_lambda_assign'.find(filter)!=-1)
        self.label_sp_cpp_lambda_square_paren.setVisible(filter=='' or 'sp_cpp_lambda_square_paren'.find(filter)!=-1)
        self.option_sp_cpp_lambda_square_paren.setVisible(filter=='' or 'sp_cpp_lambda_square_paren'.find(filter)!=-1)
        self.label_sp_cpp_lambda_square_brace.setVisible(filter=='' or 'sp_cpp_lambda_square_brace'.find(filter)!=-1)
        self.option_sp_cpp_lambda_square_brace.setVisible(filter=='' or 'sp_cpp_lambda_square_brace'.find(filter)!=-1)
        self.label_sp_cpp_lambda_argument_list_empty.setVisible(filter=='' or 'sp_cpp_lambda_argument_list_empty'.find(filter)!=-1)
        self.option_sp_cpp_lambda_argument_list_empty.setVisible(filter=='' or 'sp_cpp_lambda_argument_list_empty'.find(filter)!=-1)
        self.label_sp_cpp_lambda_argument_list.setVisible(filter=='' or 'sp_cpp_lambda_argument_list'.find(filter)!=-1)
        self.option_sp_cpp_lambda_argument_list.setVisible(filter=='' or 'sp_cpp_lambda_argument_list'.find(filter)!=-1)
        self.label_sp_cpp_lambda_paren_brace.setVisible(filter=='' or 'sp_cpp_lambda_paren_brace'.find(filter)!=-1)
        self.option_sp_cpp_lambda_paren_brace.setVisible(filter=='' or 'sp_cpp_lambda_paren_brace'.find(filter)!=-1)
        self.label_sp_cpp_lambda_fparen.setVisible(filter=='' or 'sp_cpp_lambda_fparen'.find(filter)!=-1)
        self.option_sp_cpp_lambda_fparen.setVisible(filter=='' or 'sp_cpp_lambda_fparen'.find(filter)!=-1)
        self.label_sp_assign_default.setVisible(filter=='' or 'sp_assign_default'.find(filter)!=-1)
        self.option_sp_assign_default.setVisible(filter=='' or 'sp_assign_default'.find(filter)!=-1)
        self.label_sp_before_assign.setVisible(filter=='' or 'sp_before_assign'.find(filter)!=-1)
        self.option_sp_before_assign.setVisible(filter=='' or 'sp_before_assign'.find(filter)!=-1)
        self.label_sp_after_assign.setVisible(filter=='' or 'sp_after_assign'.find(filter)!=-1)
        self.option_sp_after_assign.setVisible(filter=='' or 'sp_after_assign'.find(filter)!=-1)
        self.label_sp_enum_brace.setVisible(filter=='' or 'sp_enum_brace'.find(filter)!=-1)
        self.option_sp_enum_brace.setVisible(filter=='' or 'sp_enum_brace'.find(filter)!=-1)
        self.label_sp_enum_paren.setVisible(filter=='' or 'sp_enum_paren'.find(filter)!=-1)
        self.option_sp_enum_paren.setVisible(filter=='' or 'sp_enum_paren'.find(filter)!=-1)
        self.label_sp_enum_assign.setVisible(filter=='' or 'sp_enum_assign'.find(filter)!=-1)
        self.option_sp_enum_assign.setVisible(filter=='' or 'sp_enum_assign'.find(filter)!=-1)
        self.label_sp_enum_before_assign.setVisible(filter=='' or 'sp_enum_before_assign'.find(filter)!=-1)
        self.option_sp_enum_before_assign.setVisible(filter=='' or 'sp_enum_before_assign'.find(filter)!=-1)
        self.label_sp_enum_after_assign.setVisible(filter=='' or 'sp_enum_after_assign'.find(filter)!=-1)
        self.option_sp_enum_after_assign.setVisible(filter=='' or 'sp_enum_after_assign'.find(filter)!=-1)
        self.label_sp_enum_colon.setVisible(filter=='' or 'sp_enum_colon'.find(filter)!=-1)
        self.option_sp_enum_colon.setVisible(filter=='' or 'sp_enum_colon'.find(filter)!=-1)
        self.label_sp_pp_concat.setVisible(filter=='' or 'sp_pp_concat'.find(filter)!=-1)
        self.option_sp_pp_concat.setVisible(filter=='' or 'sp_pp_concat'.find(filter)!=-1)
        self.label_sp_pp_stringify.setVisible(filter=='' or 'sp_pp_stringify'.find(filter)!=-1)
        self.option_sp_pp_stringify.setVisible(filter=='' or 'sp_pp_stringify'.find(filter)!=-1)
        self.label_sp_before_pp_stringify.setVisible(filter=='' or 'sp_before_pp_stringify'.find(filter)!=-1)
        self.option_sp_before_pp_stringify.setVisible(filter=='' or 'sp_before_pp_stringify'.find(filter)!=-1)
        self.label_sp_bool.setVisible(filter=='' or 'sp_bool'.find(filter)!=-1)
        self.option_sp_bool.setVisible(filter=='' or 'sp_bool'.find(filter)!=-1)
        self.label_sp_compare.setVisible(filter=='' or 'sp_compare'.find(filter)!=-1)
        self.option_sp_compare.setVisible(filter=='' or 'sp_compare'.find(filter)!=-1)
        self.label_sp_inside_paren.setVisible(filter=='' or 'sp_inside_paren'.find(filter)!=-1)
        self.option_sp_inside_paren.setVisible(filter=='' or 'sp_inside_paren'.find(filter)!=-1)
        self.label_sp_paren_paren.setVisible(filter=='' or 'sp_paren_paren'.find(filter)!=-1)
        self.option_sp_paren_paren.setVisible(filter=='' or 'sp_paren_paren'.find(filter)!=-1)
        self.label_sp_cparen_oparen.setVisible(filter=='' or 'sp_cparen_oparen'.find(filter)!=-1)
        self.option_sp_cparen_oparen.setVisible(filter=='' or 'sp_cparen_oparen'.find(filter)!=-1)
        self.label_sp_paren_brace.setVisible(filter=='' or 'sp_paren_brace'.find(filter)!=-1)
        self.option_sp_paren_brace.setVisible(filter=='' or 'sp_paren_brace'.find(filter)!=-1)
        self.label_sp_brace_brace.setVisible(filter=='' or 'sp_brace_brace'.find(filter)!=-1)
        self.option_sp_brace_brace.setVisible(filter=='' or 'sp_brace_brace'.find(filter)!=-1)
        self.label_sp_before_ptr_star.setVisible(filter=='' or 'sp_before_ptr_star'.find(filter)!=-1)
        self.option_sp_before_ptr_star.setVisible(filter=='' or 'sp_before_ptr_star'.find(filter)!=-1)
        self.label_sp_before_unnamed_ptr_star.setVisible(filter=='' or 'sp_before_unnamed_ptr_star'.find(filter)!=-1)
        self.option_sp_before_unnamed_ptr_star.setVisible(filter=='' or 'sp_before_unnamed_ptr_star'.find(filter)!=-1)
        self.label_sp_before_qualifier_ptr_star.setVisible(filter=='' or 'sp_before_qualifier_ptr_star'.find(filter)!=-1)
        self.option_sp_before_qualifier_ptr_star.setVisible(filter=='' or 'sp_before_qualifier_ptr_star'.find(filter)!=-1)
        self.label_sp_before_operator_ptr_star.setVisible(filter=='' or 'sp_before_operator_ptr_star'.find(filter)!=-1)
        self.option_sp_before_operator_ptr_star.setVisible(filter=='' or 'sp_before_operator_ptr_star'.find(filter)!=-1)
        self.label_sp_before_scope_ptr_star.setVisible(filter=='' or 'sp_before_scope_ptr_star'.find(filter)!=-1)
        self.option_sp_before_scope_ptr_star.setVisible(filter=='' or 'sp_before_scope_ptr_star'.find(filter)!=-1)
        self.label_sp_before_global_scope_ptr_star.setVisible(filter=='' or 'sp_before_global_scope_ptr_star'.find(filter)!=-1)
        self.option_sp_before_global_scope_ptr_star.setVisible(filter=='' or 'sp_before_global_scope_ptr_star'.find(filter)!=-1)
        self.label_sp_qualifier_unnamed_ptr_star.setVisible(filter=='' or 'sp_qualifier_unnamed_ptr_star'.find(filter)!=-1)
        self.option_sp_qualifier_unnamed_ptr_star.setVisible(filter=='' or 'sp_qualifier_unnamed_ptr_star'.find(filter)!=-1)
        self.label_sp_between_ptr_star.setVisible(filter=='' or 'sp_between_ptr_star'.find(filter)!=-1)
        self.option_sp_between_ptr_star.setVisible(filter=='' or 'sp_between_ptr_star'.find(filter)!=-1)
        self.label_sp_between_ptr_ref.setVisible(filter=='' or 'sp_between_ptr_ref'.find(filter)!=-1)
        self.option_sp_between_ptr_ref.setVisible(filter=='' or 'sp_between_ptr_ref'.find(filter)!=-1)
        self.label_sp_after_ptr_star.setVisible(filter=='' or 'sp_after_ptr_star'.find(filter)!=-1)
        self.option_sp_after_ptr_star.setVisible(filter=='' or 'sp_after_ptr_star'.find(filter)!=-1)
        self.label_sp_after_ptr_block_caret.setVisible(filter=='' or 'sp_after_ptr_block_caret'.find(filter)!=-1)
        self.option_sp_after_ptr_block_caret.setVisible(filter=='' or 'sp_after_ptr_block_caret'.find(filter)!=-1)
        self.label_sp_after_ptr_star_qualifier.setVisible(filter=='' or 'sp_after_ptr_star_qualifier'.find(filter)!=-1)
        self.option_sp_after_ptr_star_qualifier.setVisible(filter=='' or 'sp_after_ptr_star_qualifier'.find(filter)!=-1)
        self.label_sp_after_ptr_star_func.setVisible(filter=='' or 'sp_after_ptr_star_func'.find(filter)!=-1)
        self.option_sp_after_ptr_star_func.setVisible(filter=='' or 'sp_after_ptr_star_func'.find(filter)!=-1)
        self.label_sp_after_ptr_star_trailing.setVisible(filter=='' or 'sp_after_ptr_star_trailing'.find(filter)!=-1)
        self.option_sp_after_ptr_star_trailing.setVisible(filter=='' or 'sp_after_ptr_star_trailing'.find(filter)!=-1)
        self.label_sp_ptr_star_func_var.setVisible(filter=='' or 'sp_ptr_star_func_var'.find(filter)!=-1)
        self.option_sp_ptr_star_func_var.setVisible(filter=='' or 'sp_ptr_star_func_var'.find(filter)!=-1)
        self.label_sp_ptr_star_func_type.setVisible(filter=='' or 'sp_ptr_star_func_type'.find(filter)!=-1)
        self.option_sp_ptr_star_func_type.setVisible(filter=='' or 'sp_ptr_star_func_type'.find(filter)!=-1)
        self.label_sp_ptr_star_paren.setVisible(filter=='' or 'sp_ptr_star_paren'.find(filter)!=-1)
        self.option_sp_ptr_star_paren.setVisible(filter=='' or 'sp_ptr_star_paren'.find(filter)!=-1)
        self.label_sp_before_ptr_star_func.setVisible(filter=='' or 'sp_before_ptr_star_func'.find(filter)!=-1)
        self.option_sp_before_ptr_star_func.setVisible(filter=='' or 'sp_before_ptr_star_func'.find(filter)!=-1)
        self.label_sp_qualifier_ptr_star_func.setVisible(filter=='' or 'sp_qualifier_ptr_star_func'.find(filter)!=-1)
        self.option_sp_qualifier_ptr_star_func.setVisible(filter=='' or 'sp_qualifier_ptr_star_func'.find(filter)!=-1)
        self.label_sp_before_ptr_star_trailing.setVisible(filter=='' or 'sp_before_ptr_star_trailing'.find(filter)!=-1)
        self.option_sp_before_ptr_star_trailing.setVisible(filter=='' or 'sp_before_ptr_star_trailing'.find(filter)!=-1)
        self.label_sp_qualifier_ptr_star_trailing.setVisible(filter=='' or 'sp_qualifier_ptr_star_trailing'.find(filter)!=-1)
        self.option_sp_qualifier_ptr_star_trailing.setVisible(filter=='' or 'sp_qualifier_ptr_star_trailing'.find(filter)!=-1)
        self.label_sp_before_byref.setVisible(filter=='' or 'sp_before_byref'.find(filter)!=-1)
        self.option_sp_before_byref.setVisible(filter=='' or 'sp_before_byref'.find(filter)!=-1)
        self.label_sp_before_unnamed_byref.setVisible(filter=='' or 'sp_before_unnamed_byref'.find(filter)!=-1)
        self.option_sp_before_unnamed_byref.setVisible(filter=='' or 'sp_before_unnamed_byref'.find(filter)!=-1)
        self.label_sp_after_byref.setVisible(filter=='' or 'sp_after_byref'.find(filter)!=-1)
        self.option_sp_after_byref.setVisible(filter=='' or 'sp_after_byref'.find(filter)!=-1)
        self.label_sp_after_byref_func.setVisible(filter=='' or 'sp_after_byref_func'.find(filter)!=-1)
        self.option_sp_after_byref_func.setVisible(filter=='' or 'sp_after_byref_func'.find(filter)!=-1)
        self.label_sp_before_byref_func.setVisible(filter=='' or 'sp_before_byref_func'.find(filter)!=-1)
        self.option_sp_before_byref_func.setVisible(filter=='' or 'sp_before_byref_func'.find(filter)!=-1)
        self.label_sp_byref_paren.setVisible(filter=='' or 'sp_byref_paren'.find(filter)!=-1)
        self.option_sp_byref_paren.setVisible(filter=='' or 'sp_byref_paren'.find(filter)!=-1)
        self.label_sp_after_type.setVisible(filter=='' or 'sp_after_type'.find(filter)!=-1)
        self.option_sp_after_type.setVisible(filter=='' or 'sp_after_type'.find(filter)!=-1)
        self.label_sp_after_decltype.setVisible(filter=='' or 'sp_after_decltype'.find(filter)!=-1)
        self.option_sp_after_decltype.setVisible(filter=='' or 'sp_after_decltype'.find(filter)!=-1)
        self.label_sp_before_template_paren.setVisible(filter=='' or 'sp_before_template_paren'.find(filter)!=-1)
        self.option_sp_before_template_paren.setVisible(filter=='' or 'sp_before_template_paren'.find(filter)!=-1)
        self.label_sp_template_angle.setVisible(filter=='' or 'sp_template_angle'.find(filter)!=-1)
        self.option_sp_template_angle.setVisible(filter=='' or 'sp_template_angle'.find(filter)!=-1)
        self.label_sp_before_angle.setVisible(filter=='' or 'sp_before_angle'.find(filter)!=-1)
        self.option_sp_before_angle.setVisible(filter=='' or 'sp_before_angle'.find(filter)!=-1)
        self.label_sp_inside_angle.setVisible(filter=='' or 'sp_inside_angle'.find(filter)!=-1)
        self.option_sp_inside_angle.setVisible(filter=='' or 'sp_inside_angle'.find(filter)!=-1)
        self.label_sp_inside_angle_empty.setVisible(filter=='' or 'sp_inside_angle_empty'.find(filter)!=-1)
        self.option_sp_inside_angle_empty.setVisible(filter=='' or 'sp_inside_angle_empty'.find(filter)!=-1)
        self.label_sp_angle_colon.setVisible(filter=='' or 'sp_angle_colon'.find(filter)!=-1)
        self.option_sp_angle_colon.setVisible(filter=='' or 'sp_angle_colon'.find(filter)!=-1)
        self.label_sp_after_angle.setVisible(filter=='' or 'sp_after_angle'.find(filter)!=-1)
        self.option_sp_after_angle.setVisible(filter=='' or 'sp_after_angle'.find(filter)!=-1)
        self.label_sp_angle_paren.setVisible(filter=='' or 'sp_angle_paren'.find(filter)!=-1)
        self.option_sp_angle_paren.setVisible(filter=='' or 'sp_angle_paren'.find(filter)!=-1)
        self.label_sp_angle_paren_empty.setVisible(filter=='' or 'sp_angle_paren_empty'.find(filter)!=-1)
        self.option_sp_angle_paren_empty.setVisible(filter=='' or 'sp_angle_paren_empty'.find(filter)!=-1)
        self.label_sp_angle_word.setVisible(filter=='' or 'sp_angle_word'.find(filter)!=-1)
        self.option_sp_angle_word.setVisible(filter=='' or 'sp_angle_word'.find(filter)!=-1)
        self.label_sp_angle_shift.setVisible(filter=='' or 'sp_angle_shift'.find(filter)!=-1)
        self.option_sp_angle_shift.setVisible(filter=='' or 'sp_angle_shift'.find(filter)!=-1)
        self.label_sp_permit_cpp11_shift.setVisible(filter=='' or 'sp_permit_cpp11_shift'.find(filter)!=-1)
        self.option_sp_permit_cpp11_shift.setVisible(filter=='' or 'sp_permit_cpp11_shift'.find(filter)!=-1)
        self.label_sp_before_sparen.setVisible(filter=='' or 'sp_before_sparen'.find(filter)!=-1)
        self.option_sp_before_sparen.setVisible(filter=='' or 'sp_before_sparen'.find(filter)!=-1)
        self.label_sp_inside_sparen.setVisible(filter=='' or 'sp_inside_sparen'.find(filter)!=-1)
        self.option_sp_inside_sparen.setVisible(filter=='' or 'sp_inside_sparen'.find(filter)!=-1)
        self.label_sp_inside_sparen_open.setVisible(filter=='' or 'sp_inside_sparen_open'.find(filter)!=-1)
        self.option_sp_inside_sparen_open.setVisible(filter=='' or 'sp_inside_sparen_open'.find(filter)!=-1)
        self.label_sp_inside_sparen_close.setVisible(filter=='' or 'sp_inside_sparen_close'.find(filter)!=-1)
        self.option_sp_inside_sparen_close.setVisible(filter=='' or 'sp_inside_sparen_close'.find(filter)!=-1)
        self.label_sp_inside_for.setVisible(filter=='' or 'sp_inside_for'.find(filter)!=-1)
        self.option_sp_inside_for.setVisible(filter=='' or 'sp_inside_for'.find(filter)!=-1)
        self.label_sp_inside_for_open.setVisible(filter=='' or 'sp_inside_for_open'.find(filter)!=-1)
        self.option_sp_inside_for_open.setVisible(filter=='' or 'sp_inside_for_open'.find(filter)!=-1)
        self.label_sp_inside_for_close.setVisible(filter=='' or 'sp_inside_for_close'.find(filter)!=-1)
        self.option_sp_inside_for_close.setVisible(filter=='' or 'sp_inside_for_close'.find(filter)!=-1)
        self.label_sp_sparen_paren.setVisible(filter=='' or 'sp_sparen_paren'.find(filter)!=-1)
        self.option_sp_sparen_paren.setVisible(filter=='' or 'sp_sparen_paren'.find(filter)!=-1)
        self.label_sp_after_sparen.setVisible(filter=='' or 'sp_after_sparen'.find(filter)!=-1)
        self.option_sp_after_sparen.setVisible(filter=='' or 'sp_after_sparen'.find(filter)!=-1)
        self.label_sp_sparen_brace.setVisible(filter=='' or 'sp_sparen_brace'.find(filter)!=-1)
        self.option_sp_sparen_brace.setVisible(filter=='' or 'sp_sparen_brace'.find(filter)!=-1)
        self.label_sp_do_brace_open.setVisible(filter=='' or 'sp_do_brace_open'.find(filter)!=-1)
        self.option_sp_do_brace_open.setVisible(filter=='' or 'sp_do_brace_open'.find(filter)!=-1)
        self.label_sp_brace_close_while.setVisible(filter=='' or 'sp_brace_close_while'.find(filter)!=-1)
        self.option_sp_brace_close_while.setVisible(filter=='' or 'sp_brace_close_while'.find(filter)!=-1)
        self.label_sp_while_paren_open.setVisible(filter=='' or 'sp_while_paren_open'.find(filter)!=-1)
        self.option_sp_while_paren_open.setVisible(filter=='' or 'sp_while_paren_open'.find(filter)!=-1)
        self.label_sp_invariant_paren.setVisible(filter=='' or 'sp_invariant_paren'.find(filter)!=-1)
        self.option_sp_invariant_paren.setVisible(filter=='' or 'sp_invariant_paren'.find(filter)!=-1)
        self.label_sp_after_invariant_paren.setVisible(filter=='' or 'sp_after_invariant_paren'.find(filter)!=-1)
        self.option_sp_after_invariant_paren.setVisible(filter=='' or 'sp_after_invariant_paren'.find(filter)!=-1)
        self.label_sp_special_semi.setVisible(filter=='' or 'sp_special_semi'.find(filter)!=-1)
        self.option_sp_special_semi.setVisible(filter=='' or 'sp_special_semi'.find(filter)!=-1)
        self.label_sp_before_semi.setVisible(filter=='' or 'sp_before_semi'.find(filter)!=-1)
        self.option_sp_before_semi.setVisible(filter=='' or 'sp_before_semi'.find(filter)!=-1)
        self.label_sp_before_semi_for.setVisible(filter=='' or 'sp_before_semi_for'.find(filter)!=-1)
        self.option_sp_before_semi_for.setVisible(filter=='' or 'sp_before_semi_for'.find(filter)!=-1)
        self.label_sp_before_semi_for_empty.setVisible(filter=='' or 'sp_before_semi_for_empty'.find(filter)!=-1)
        self.option_sp_before_semi_for_empty.setVisible(filter=='' or 'sp_before_semi_for_empty'.find(filter)!=-1)
        self.label_sp_between_semi_for_empty.setVisible(filter=='' or 'sp_between_semi_for_empty'.find(filter)!=-1)
        self.option_sp_between_semi_for_empty.setVisible(filter=='' or 'sp_between_semi_for_empty'.find(filter)!=-1)
        self.label_sp_after_semi.setVisible(filter=='' or 'sp_after_semi'.find(filter)!=-1)
        self.option_sp_after_semi.setVisible(filter=='' or 'sp_after_semi'.find(filter)!=-1)
        self.label_sp_after_semi_for.setVisible(filter=='' or 'sp_after_semi_for'.find(filter)!=-1)
        self.option_sp_after_semi_for.setVisible(filter=='' or 'sp_after_semi_for'.find(filter)!=-1)
        self.label_sp_after_semi_for_empty.setVisible(filter=='' or 'sp_after_semi_for_empty'.find(filter)!=-1)
        self.option_sp_after_semi_for_empty.setVisible(filter=='' or 'sp_after_semi_for_empty'.find(filter)!=-1)
        self.label_sp_before_square.setVisible(filter=='' or 'sp_before_square'.find(filter)!=-1)
        self.option_sp_before_square.setVisible(filter=='' or 'sp_before_square'.find(filter)!=-1)
        self.label_sp_before_vardef_square.setVisible(filter=='' or 'sp_before_vardef_square'.find(filter)!=-1)
        self.option_sp_before_vardef_square.setVisible(filter=='' or 'sp_before_vardef_square'.find(filter)!=-1)
        self.label_sp_before_square_asm_block.setVisible(filter=='' or 'sp_before_square_asm_block'.find(filter)!=-1)
        self.option_sp_before_square_asm_block.setVisible(filter=='' or 'sp_before_square_asm_block'.find(filter)!=-1)
        self.label_sp_before_squares.setVisible(filter=='' or 'sp_before_squares'.find(filter)!=-1)
        self.option_sp_before_squares.setVisible(filter=='' or 'sp_before_squares'.find(filter)!=-1)
        self.label_sp_cpp_before_struct_binding_after_byref.setVisible(filter=='' or 'sp_cpp_before_struct_binding_after_byref'.find(filter)!=-1)
        self.option_sp_cpp_before_struct_binding_after_byref.setVisible(filter=='' or 'sp_cpp_before_struct_binding_after_byref'.find(filter)!=-1)
        self.label_sp_cpp_before_struct_binding.setVisible(filter=='' or 'sp_cpp_before_struct_binding'.find(filter)!=-1)
        self.option_sp_cpp_before_struct_binding.setVisible(filter=='' or 'sp_cpp_before_struct_binding'.find(filter)!=-1)
        self.label_sp_inside_square.setVisible(filter=='' or 'sp_inside_square'.find(filter)!=-1)
        self.option_sp_inside_square.setVisible(filter=='' or 'sp_inside_square'.find(filter)!=-1)
        self.label_sp_inside_square_empty.setVisible(filter=='' or 'sp_inside_square_empty'.find(filter)!=-1)
        self.option_sp_inside_square_empty.setVisible(filter=='' or 'sp_inside_square_empty'.find(filter)!=-1)
        self.label_sp_inside_square_oc_array.setVisible(filter=='' or 'sp_inside_square_oc_array'.find(filter)!=-1)
        self.option_sp_inside_square_oc_array.setVisible(filter=='' or 'sp_inside_square_oc_array'.find(filter)!=-1)
        self.label_sp_after_comma.setVisible(filter=='' or 'sp_after_comma'.find(filter)!=-1)
        self.option_sp_after_comma.setVisible(filter=='' or 'sp_after_comma'.find(filter)!=-1)
        self.label_sp_before_comma.setVisible(filter=='' or 'sp_before_comma'.find(filter)!=-1)
        self.option_sp_before_comma.setVisible(filter=='' or 'sp_before_comma'.find(filter)!=-1)
        self.label_sp_after_mdatype_commas.setVisible(filter=='' or 'sp_after_mdatype_commas'.find(filter)!=-1)
        self.option_sp_after_mdatype_commas.setVisible(filter=='' or 'sp_after_mdatype_commas'.find(filter)!=-1)
        self.label_sp_before_mdatype_commas.setVisible(filter=='' or 'sp_before_mdatype_commas'.find(filter)!=-1)
        self.option_sp_before_mdatype_commas.setVisible(filter=='' or 'sp_before_mdatype_commas'.find(filter)!=-1)
        self.label_sp_between_mdatype_commas.setVisible(filter=='' or 'sp_between_mdatype_commas'.find(filter)!=-1)
        self.option_sp_between_mdatype_commas.setVisible(filter=='' or 'sp_between_mdatype_commas'.find(filter)!=-1)
        self.label_sp_paren_comma.setVisible(filter=='' or 'sp_paren_comma'.find(filter)!=-1)
        self.option_sp_paren_comma.setVisible(filter=='' or 'sp_paren_comma'.find(filter)!=-1)
        self.label_sp_type_colon.setVisible(filter=='' or 'sp_type_colon'.find(filter)!=-1)
        self.option_sp_type_colon.setVisible(filter=='' or 'sp_type_colon'.find(filter)!=-1)
        self.label_sp_after_ellipsis.setVisible(filter=='' or 'sp_after_ellipsis'.find(filter)!=-1)
        self.option_sp_after_ellipsis.setVisible(filter=='' or 'sp_after_ellipsis'.find(filter)!=-1)
        self.label_sp_before_ellipsis.setVisible(filter=='' or 'sp_before_ellipsis'.find(filter)!=-1)
        self.option_sp_before_ellipsis.setVisible(filter=='' or 'sp_before_ellipsis'.find(filter)!=-1)
        self.label_sp_type_ellipsis.setVisible(filter=='' or 'sp_type_ellipsis'.find(filter)!=-1)
        self.option_sp_type_ellipsis.setVisible(filter=='' or 'sp_type_ellipsis'.find(filter)!=-1)
        self.label_sp_ptr_type_ellipsis.setVisible(filter=='' or 'sp_ptr_type_ellipsis'.find(filter)!=-1)
        self.option_sp_ptr_type_ellipsis.setVisible(filter=='' or 'sp_ptr_type_ellipsis'.find(filter)!=-1)
        self.label_sp_paren_ellipsis.setVisible(filter=='' or 'sp_paren_ellipsis'.find(filter)!=-1)
        self.option_sp_paren_ellipsis.setVisible(filter=='' or 'sp_paren_ellipsis'.find(filter)!=-1)
        self.label_sp_byref_ellipsis.setVisible(filter=='' or 'sp_byref_ellipsis'.find(filter)!=-1)
        self.option_sp_byref_ellipsis.setVisible(filter=='' or 'sp_byref_ellipsis'.find(filter)!=-1)
        self.label_sp_paren_qualifier.setVisible(filter=='' or 'sp_paren_qualifier'.find(filter)!=-1)
        self.option_sp_paren_qualifier.setVisible(filter=='' or 'sp_paren_qualifier'.find(filter)!=-1)
        self.label_sp_paren_noexcept.setVisible(filter=='' or 'sp_paren_noexcept'.find(filter)!=-1)
        self.option_sp_paren_noexcept.setVisible(filter=='' or 'sp_paren_noexcept'.find(filter)!=-1)
        self.label_sp_after_class_colon.setVisible(filter=='' or 'sp_after_class_colon'.find(filter)!=-1)
        self.option_sp_after_class_colon.setVisible(filter=='' or 'sp_after_class_colon'.find(filter)!=-1)
        self.label_sp_before_class_colon.setVisible(filter=='' or 'sp_before_class_colon'.find(filter)!=-1)
        self.option_sp_before_class_colon.setVisible(filter=='' or 'sp_before_class_colon'.find(filter)!=-1)
        self.label_sp_after_constr_colon.setVisible(filter=='' or 'sp_after_constr_colon'.find(filter)!=-1)
        self.option_sp_after_constr_colon.setVisible(filter=='' or 'sp_after_constr_colon'.find(filter)!=-1)
        self.label_sp_before_constr_colon.setVisible(filter=='' or 'sp_before_constr_colon'.find(filter)!=-1)
        self.option_sp_before_constr_colon.setVisible(filter=='' or 'sp_before_constr_colon'.find(filter)!=-1)
        self.label_sp_before_case_colon.setVisible(filter=='' or 'sp_before_case_colon'.find(filter)!=-1)
        self.option_sp_before_case_colon.setVisible(filter=='' or 'sp_before_case_colon'.find(filter)!=-1)
        self.label_sp_after_operator.setVisible(filter=='' or 'sp_after_operator'.find(filter)!=-1)
        self.option_sp_after_operator.setVisible(filter=='' or 'sp_after_operator'.find(filter)!=-1)
        self.label_sp_after_operator_sym.setVisible(filter=='' or 'sp_after_operator_sym'.find(filter)!=-1)
        self.option_sp_after_operator_sym.setVisible(filter=='' or 'sp_after_operator_sym'.find(filter)!=-1)
        self.label_sp_after_operator_sym_empty.setVisible(filter=='' or 'sp_after_operator_sym_empty'.find(filter)!=-1)
        self.option_sp_after_operator_sym_empty.setVisible(filter=='' or 'sp_after_operator_sym_empty'.find(filter)!=-1)
        self.label_sp_after_cast.setVisible(filter=='' or 'sp_after_cast'.find(filter)!=-1)
        self.option_sp_after_cast.setVisible(filter=='' or 'sp_after_cast'.find(filter)!=-1)
        self.label_sp_inside_paren_cast.setVisible(filter=='' or 'sp_inside_paren_cast'.find(filter)!=-1)
        self.option_sp_inside_paren_cast.setVisible(filter=='' or 'sp_inside_paren_cast'.find(filter)!=-1)
        self.label_sp_cpp_cast_paren.setVisible(filter=='' or 'sp_cpp_cast_paren'.find(filter)!=-1)
        self.option_sp_cpp_cast_paren.setVisible(filter=='' or 'sp_cpp_cast_paren'.find(filter)!=-1)
        self.label_sp_sizeof_paren.setVisible(filter=='' or 'sp_sizeof_paren'.find(filter)!=-1)
        self.option_sp_sizeof_paren.setVisible(filter=='' or 'sp_sizeof_paren'.find(filter)!=-1)
        self.label_sp_sizeof_ellipsis.setVisible(filter=='' or 'sp_sizeof_ellipsis'.find(filter)!=-1)
        self.option_sp_sizeof_ellipsis.setVisible(filter=='' or 'sp_sizeof_ellipsis'.find(filter)!=-1)
        self.label_sp_sizeof_ellipsis_paren.setVisible(filter=='' or 'sp_sizeof_ellipsis_paren'.find(filter)!=-1)
        self.option_sp_sizeof_ellipsis_paren.setVisible(filter=='' or 'sp_sizeof_ellipsis_paren'.find(filter)!=-1)
        self.label_sp_ellipsis_parameter_pack.setVisible(filter=='' or 'sp_ellipsis_parameter_pack'.find(filter)!=-1)
        self.option_sp_ellipsis_parameter_pack.setVisible(filter=='' or 'sp_ellipsis_parameter_pack'.find(filter)!=-1)
        self.label_sp_parameter_pack_ellipsis.setVisible(filter=='' or 'sp_parameter_pack_ellipsis'.find(filter)!=-1)
        self.option_sp_parameter_pack_ellipsis.setVisible(filter=='' or 'sp_parameter_pack_ellipsis'.find(filter)!=-1)
        self.label_sp_decltype_paren.setVisible(filter=='' or 'sp_decltype_paren'.find(filter)!=-1)
        self.option_sp_decltype_paren.setVisible(filter=='' or 'sp_decltype_paren'.find(filter)!=-1)
        self.label_sp_after_tag.setVisible(filter=='' or 'sp_after_tag'.find(filter)!=-1)
        self.option_sp_after_tag.setVisible(filter=='' or 'sp_after_tag'.find(filter)!=-1)
        self.label_sp_inside_braces_enum.setVisible(filter=='' or 'sp_inside_braces_enum'.find(filter)!=-1)
        self.option_sp_inside_braces_enum.setVisible(filter=='' or 'sp_inside_braces_enum'.find(filter)!=-1)
        self.label_sp_inside_braces_struct.setVisible(filter=='' or 'sp_inside_braces_struct'.find(filter)!=-1)
        self.option_sp_inside_braces_struct.setVisible(filter=='' or 'sp_inside_braces_struct'.find(filter)!=-1)
        self.label_sp_inside_braces_oc_dict.setVisible(filter=='' or 'sp_inside_braces_oc_dict'.find(filter)!=-1)
        self.option_sp_inside_braces_oc_dict.setVisible(filter=='' or 'sp_inside_braces_oc_dict'.find(filter)!=-1)
        self.label_sp_after_type_brace_init_lst_open.setVisible(filter=='' or 'sp_after_type_brace_init_lst_open'.find(filter)!=-1)
        self.option_sp_after_type_brace_init_lst_open.setVisible(filter=='' or 'sp_after_type_brace_init_lst_open'.find(filter)!=-1)
        self.label_sp_before_type_brace_init_lst_close.setVisible(filter=='' or 'sp_before_type_brace_init_lst_close'.find(filter)!=-1)
        self.option_sp_before_type_brace_init_lst_close.setVisible(filter=='' or 'sp_before_type_brace_init_lst_close'.find(filter)!=-1)
        self.label_sp_inside_type_brace_init_lst.setVisible(filter=='' or 'sp_inside_type_brace_init_lst'.find(filter)!=-1)
        self.option_sp_inside_type_brace_init_lst.setVisible(filter=='' or 'sp_inside_type_brace_init_lst'.find(filter)!=-1)
        self.label_sp_inside_braces.setVisible(filter=='' or 'sp_inside_braces'.find(filter)!=-1)
        self.option_sp_inside_braces.setVisible(filter=='' or 'sp_inside_braces'.find(filter)!=-1)
        self.label_sp_inside_braces_empty.setVisible(filter=='' or 'sp_inside_braces_empty'.find(filter)!=-1)
        self.option_sp_inside_braces_empty.setVisible(filter=='' or 'sp_inside_braces_empty'.find(filter)!=-1)
        self.label_sp_trailing_return.setVisible(filter=='' or 'sp_trailing_return'.find(filter)!=-1)
        self.option_sp_trailing_return.setVisible(filter=='' or 'sp_trailing_return'.find(filter)!=-1)
        self.label_sp_type_func.setVisible(filter=='' or 'sp_type_func'.find(filter)!=-1)
        self.option_sp_type_func.setVisible(filter=='' or 'sp_type_func'.find(filter)!=-1)
        self.label_sp_type_brace_init_lst.setVisible(filter=='' or 'sp_type_brace_init_lst'.find(filter)!=-1)
        self.option_sp_type_brace_init_lst.setVisible(filter=='' or 'sp_type_brace_init_lst'.find(filter)!=-1)
        self.label_sp_func_proto_paren.setVisible(filter=='' or 'sp_func_proto_paren'.find(filter)!=-1)
        self.option_sp_func_proto_paren.setVisible(filter=='' or 'sp_func_proto_paren'.find(filter)!=-1)
        self.label_sp_func_proto_paren_empty.setVisible(filter=='' or 'sp_func_proto_paren_empty'.find(filter)!=-1)
        self.option_sp_func_proto_paren_empty.setVisible(filter=='' or 'sp_func_proto_paren_empty'.find(filter)!=-1)
        self.label_sp_func_type_paren.setVisible(filter=='' or 'sp_func_type_paren'.find(filter)!=-1)
        self.option_sp_func_type_paren.setVisible(filter=='' or 'sp_func_type_paren'.find(filter)!=-1)
        self.label_sp_func_def_paren.setVisible(filter=='' or 'sp_func_def_paren'.find(filter)!=-1)
        self.option_sp_func_def_paren.setVisible(filter=='' or 'sp_func_def_paren'.find(filter)!=-1)
        self.label_sp_func_def_paren_empty.setVisible(filter=='' or 'sp_func_def_paren_empty'.find(filter)!=-1)
        self.option_sp_func_def_paren_empty.setVisible(filter=='' or 'sp_func_def_paren_empty'.find(filter)!=-1)
        self.label_sp_inside_fparens.setVisible(filter=='' or 'sp_inside_fparens'.find(filter)!=-1)
        self.option_sp_inside_fparens.setVisible(filter=='' or 'sp_inside_fparens'.find(filter)!=-1)
        self.label_sp_inside_fparen.setVisible(filter=='' or 'sp_inside_fparen'.find(filter)!=-1)
        self.option_sp_inside_fparen.setVisible(filter=='' or 'sp_inside_fparen'.find(filter)!=-1)
        self.label_sp_func_call_user_inside_rparen.setVisible(filter=='' or 'sp_func_call_user_inside_rparen'.find(filter)!=-1)
        self.option_sp_func_call_user_inside_rparen.setVisible(filter=='' or 'sp_func_call_user_inside_rparen'.find(filter)!=-1)
        self.label_sp_inside_rparens.setVisible(filter=='' or 'sp_inside_rparens'.find(filter)!=-1)
        self.option_sp_inside_rparens.setVisible(filter=='' or 'sp_inside_rparens'.find(filter)!=-1)
        self.label_sp_inside_rparen.setVisible(filter=='' or 'sp_inside_rparen'.find(filter)!=-1)
        self.option_sp_inside_rparen.setVisible(filter=='' or 'sp_inside_rparen'.find(filter)!=-1)
        self.label_sp_inside_tparen.setVisible(filter=='' or 'sp_inside_tparen'.find(filter)!=-1)
        self.option_sp_inside_tparen.setVisible(filter=='' or 'sp_inside_tparen'.find(filter)!=-1)
        self.label_sp_after_tparen_close.setVisible(filter=='' or 'sp_after_tparen_close'.find(filter)!=-1)
        self.option_sp_after_tparen_close.setVisible(filter=='' or 'sp_after_tparen_close'.find(filter)!=-1)
        self.label_sp_square_fparen.setVisible(filter=='' or 'sp_square_fparen'.find(filter)!=-1)
        self.option_sp_square_fparen.setVisible(filter=='' or 'sp_square_fparen'.find(filter)!=-1)
        self.label_sp_fparen_brace.setVisible(filter=='' or 'sp_fparen_brace'.find(filter)!=-1)
        self.option_sp_fparen_brace.setVisible(filter=='' or 'sp_fparen_brace'.find(filter)!=-1)
        self.label_sp_fparen_brace_initializer.setVisible(filter=='' or 'sp_fparen_brace_initializer'.find(filter)!=-1)
        self.option_sp_fparen_brace_initializer.setVisible(filter=='' or 'sp_fparen_brace_initializer'.find(filter)!=-1)
        self.label_sp_fparen_dbrace.setVisible(filter=='' or 'sp_fparen_dbrace'.find(filter)!=-1)
        self.option_sp_fparen_dbrace.setVisible(filter=='' or 'sp_fparen_dbrace'.find(filter)!=-1)
        self.label_sp_func_call_paren.setVisible(filter=='' or 'sp_func_call_paren'.find(filter)!=-1)
        self.option_sp_func_call_paren.setVisible(filter=='' or 'sp_func_call_paren'.find(filter)!=-1)
        self.label_sp_func_call_paren_empty.setVisible(filter=='' or 'sp_func_call_paren_empty'.find(filter)!=-1)
        self.option_sp_func_call_paren_empty.setVisible(filter=='' or 'sp_func_call_paren_empty'.find(filter)!=-1)
        self.label_sp_func_call_user_paren.setVisible(filter=='' or 'sp_func_call_user_paren'.find(filter)!=-1)
        self.option_sp_func_call_user_paren.setVisible(filter=='' or 'sp_func_call_user_paren'.find(filter)!=-1)
        self.label_sp_func_call_user_inside_fparen.setVisible(filter=='' or 'sp_func_call_user_inside_fparen'.find(filter)!=-1)
        self.option_sp_func_call_user_inside_fparen.setVisible(filter=='' or 'sp_func_call_user_inside_fparen'.find(filter)!=-1)
        self.label_sp_func_call_user_paren_paren.setVisible(filter=='' or 'sp_func_call_user_paren_paren'.find(filter)!=-1)
        self.option_sp_func_call_user_paren_paren.setVisible(filter=='' or 'sp_func_call_user_paren_paren'.find(filter)!=-1)
        self.label_sp_func_class_paren.setVisible(filter=='' or 'sp_func_class_paren'.find(filter)!=-1)
        self.option_sp_func_class_paren.setVisible(filter=='' or 'sp_func_class_paren'.find(filter)!=-1)
        self.label_sp_func_class_paren_empty.setVisible(filter=='' or 'sp_func_class_paren_empty'.find(filter)!=-1)
        self.option_sp_func_class_paren_empty.setVisible(filter=='' or 'sp_func_class_paren_empty'.find(filter)!=-1)
        self.label_sp_return.setVisible(filter=='' or 'sp_return'.find(filter)!=-1)
        self.option_sp_return.setVisible(filter=='' or 'sp_return'.find(filter)!=-1)
        self.label_sp_return_paren.setVisible(filter=='' or 'sp_return_paren'.find(filter)!=-1)
        self.option_sp_return_paren.setVisible(filter=='' or 'sp_return_paren'.find(filter)!=-1)
        self.label_sp_return_brace.setVisible(filter=='' or 'sp_return_brace'.find(filter)!=-1)
        self.option_sp_return_brace.setVisible(filter=='' or 'sp_return_brace'.find(filter)!=-1)
        self.label_sp_attribute_paren.setVisible(filter=='' or 'sp_attribute_paren'.find(filter)!=-1)
        self.option_sp_attribute_paren.setVisible(filter=='' or 'sp_attribute_paren'.find(filter)!=-1)
        self.label_sp_defined_paren.setVisible(filter=='' or 'sp_defined_paren'.find(filter)!=-1)
        self.option_sp_defined_paren.setVisible(filter=='' or 'sp_defined_paren'.find(filter)!=-1)
        self.label_sp_throw_paren.setVisible(filter=='' or 'sp_throw_paren'.find(filter)!=-1)
        self.option_sp_throw_paren.setVisible(filter=='' or 'sp_throw_paren'.find(filter)!=-1)
        self.label_sp_after_throw.setVisible(filter=='' or 'sp_after_throw'.find(filter)!=-1)
        self.option_sp_after_throw.setVisible(filter=='' or 'sp_after_throw'.find(filter)!=-1)
        self.label_sp_catch_paren.setVisible(filter=='' or 'sp_catch_paren'.find(filter)!=-1)
        self.option_sp_catch_paren.setVisible(filter=='' or 'sp_catch_paren'.find(filter)!=-1)
        self.label_sp_oc_catch_paren.setVisible(filter=='' or 'sp_oc_catch_paren'.find(filter)!=-1)
        self.option_sp_oc_catch_paren.setVisible(filter=='' or 'sp_oc_catch_paren'.find(filter)!=-1)
        self.label_sp_before_oc_proto_list.setVisible(filter=='' or 'sp_before_oc_proto_list'.find(filter)!=-1)
        self.option_sp_before_oc_proto_list.setVisible(filter=='' or 'sp_before_oc_proto_list'.find(filter)!=-1)
        self.label_sp_oc_classname_paren.setVisible(filter=='' or 'sp_oc_classname_paren'.find(filter)!=-1)
        self.option_sp_oc_classname_paren.setVisible(filter=='' or 'sp_oc_classname_paren'.find(filter)!=-1)
        self.label_sp_version_paren.setVisible(filter=='' or 'sp_version_paren'.find(filter)!=-1)
        self.option_sp_version_paren.setVisible(filter=='' or 'sp_version_paren'.find(filter)!=-1)
        self.label_sp_scope_paren.setVisible(filter=='' or 'sp_scope_paren'.find(filter)!=-1)
        self.option_sp_scope_paren.setVisible(filter=='' or 'sp_scope_paren'.find(filter)!=-1)
        self.label_sp_super_paren.setVisible(filter=='' or 'sp_super_paren'.find(filter)!=-1)
        self.option_sp_super_paren.setVisible(filter=='' or 'sp_super_paren'.find(filter)!=-1)
        self.label_sp_this_paren.setVisible(filter=='' or 'sp_this_paren'.find(filter)!=-1)
        self.option_sp_this_paren.setVisible(filter=='' or 'sp_this_paren'.find(filter)!=-1)
        self.label_sp_macro.setVisible(filter=='' or 'sp_macro'.find(filter)!=-1)
        self.option_sp_macro.setVisible(filter=='' or 'sp_macro'.find(filter)!=-1)
        self.label_sp_macro_func.setVisible(filter=='' or 'sp_macro_func'.find(filter)!=-1)
        self.option_sp_macro_func.setVisible(filter=='' or 'sp_macro_func'.find(filter)!=-1)
        self.label_sp_else_brace.setVisible(filter=='' or 'sp_else_brace'.find(filter)!=-1)
        self.option_sp_else_brace.setVisible(filter=='' or 'sp_else_brace'.find(filter)!=-1)
        self.label_sp_brace_else.setVisible(filter=='' or 'sp_brace_else'.find(filter)!=-1)
        self.option_sp_brace_else.setVisible(filter=='' or 'sp_brace_else'.find(filter)!=-1)
        self.label_sp_brace_typedef.setVisible(filter=='' or 'sp_brace_typedef'.find(filter)!=-1)
        self.option_sp_brace_typedef.setVisible(filter=='' or 'sp_brace_typedef'.find(filter)!=-1)
        self.label_sp_catch_brace.setVisible(filter=='' or 'sp_catch_brace'.find(filter)!=-1)
        self.option_sp_catch_brace.setVisible(filter=='' or 'sp_catch_brace'.find(filter)!=-1)
        self.label_sp_oc_catch_brace.setVisible(filter=='' or 'sp_oc_catch_brace'.find(filter)!=-1)
        self.option_sp_oc_catch_brace.setVisible(filter=='' or 'sp_oc_catch_brace'.find(filter)!=-1)
        self.label_sp_brace_catch.setVisible(filter=='' or 'sp_brace_catch'.find(filter)!=-1)
        self.option_sp_brace_catch.setVisible(filter=='' or 'sp_brace_catch'.find(filter)!=-1)
        self.label_sp_oc_brace_catch.setVisible(filter=='' or 'sp_oc_brace_catch'.find(filter)!=-1)
        self.option_sp_oc_brace_catch.setVisible(filter=='' or 'sp_oc_brace_catch'.find(filter)!=-1)
        self.label_sp_finally_brace.setVisible(filter=='' or 'sp_finally_brace'.find(filter)!=-1)
        self.option_sp_finally_brace.setVisible(filter=='' or 'sp_finally_brace'.find(filter)!=-1)
        self.label_sp_brace_finally.setVisible(filter=='' or 'sp_brace_finally'.find(filter)!=-1)
        self.option_sp_brace_finally.setVisible(filter=='' or 'sp_brace_finally'.find(filter)!=-1)
        self.label_sp_try_brace.setVisible(filter=='' or 'sp_try_brace'.find(filter)!=-1)
        self.option_sp_try_brace.setVisible(filter=='' or 'sp_try_brace'.find(filter)!=-1)
        self.label_sp_getset_brace.setVisible(filter=='' or 'sp_getset_brace'.find(filter)!=-1)
        self.option_sp_getset_brace.setVisible(filter=='' or 'sp_getset_brace'.find(filter)!=-1)
        self.label_sp_word_brace_init_lst.setVisible(filter=='' or 'sp_word_brace_init_lst'.find(filter)!=-1)
        self.option_sp_word_brace_init_lst.setVisible(filter=='' or 'sp_word_brace_init_lst'.find(filter)!=-1)
        self.label_sp_word_brace_ns.setVisible(filter=='' or 'sp_word_brace_ns'.find(filter)!=-1)
        self.option_sp_word_brace_ns.setVisible(filter=='' or 'sp_word_brace_ns'.find(filter)!=-1)
        self.label_sp_before_dc.setVisible(filter=='' or 'sp_before_dc'.find(filter)!=-1)
        self.option_sp_before_dc.setVisible(filter=='' or 'sp_before_dc'.find(filter)!=-1)
        self.label_sp_after_dc.setVisible(filter=='' or 'sp_after_dc'.find(filter)!=-1)
        self.option_sp_after_dc.setVisible(filter=='' or 'sp_after_dc'.find(filter)!=-1)
        self.label_sp_d_array_colon.setVisible(filter=='' or 'sp_d_array_colon'.find(filter)!=-1)
        self.option_sp_d_array_colon.setVisible(filter=='' or 'sp_d_array_colon'.find(filter)!=-1)
        self.label_sp_not.setVisible(filter=='' or 'sp_not'.find(filter)!=-1)
        self.option_sp_not.setVisible(filter=='' or 'sp_not'.find(filter)!=-1)
        self.label_sp_not_not.setVisible(filter=='' or 'sp_not_not'.find(filter)!=-1)
        self.option_sp_not_not.setVisible(filter=='' or 'sp_not_not'.find(filter)!=-1)
        self.label_sp_inv.setVisible(filter=='' or 'sp_inv'.find(filter)!=-1)
        self.option_sp_inv.setVisible(filter=='' or 'sp_inv'.find(filter)!=-1)
        self.label_sp_addr.setVisible(filter=='' or 'sp_addr'.find(filter)!=-1)
        self.option_sp_addr.setVisible(filter=='' or 'sp_addr'.find(filter)!=-1)
        self.label_sp_member.setVisible(filter=='' or 'sp_member'.find(filter)!=-1)
        self.option_sp_member.setVisible(filter=='' or 'sp_member'.find(filter)!=-1)
        self.label_sp_deref.setVisible(filter=='' or 'sp_deref'.find(filter)!=-1)
        self.option_sp_deref.setVisible(filter=='' or 'sp_deref'.find(filter)!=-1)
        self.label_sp_sign.setVisible(filter=='' or 'sp_sign'.find(filter)!=-1)
        self.option_sp_sign.setVisible(filter=='' or 'sp_sign'.find(filter)!=-1)
        self.label_sp_incdec.setVisible(filter=='' or 'sp_incdec'.find(filter)!=-1)
        self.option_sp_incdec.setVisible(filter=='' or 'sp_incdec'.find(filter)!=-1)
        self.label_sp_before_nl_cont.setVisible(filter=='' or 'sp_before_nl_cont'.find(filter)!=-1)
        self.option_sp_before_nl_cont.setVisible(filter=='' or 'sp_before_nl_cont'.find(filter)!=-1)
        self.label_sp_after_oc_scope.setVisible(filter=='' or 'sp_after_oc_scope'.find(filter)!=-1)
        self.option_sp_after_oc_scope.setVisible(filter=='' or 'sp_after_oc_scope'.find(filter)!=-1)
        self.label_sp_after_oc_colon.setVisible(filter=='' or 'sp_after_oc_colon'.find(filter)!=-1)
        self.option_sp_after_oc_colon.setVisible(filter=='' or 'sp_after_oc_colon'.find(filter)!=-1)
        self.label_sp_before_oc_colon.setVisible(filter=='' or 'sp_before_oc_colon'.find(filter)!=-1)
        self.option_sp_before_oc_colon.setVisible(filter=='' or 'sp_before_oc_colon'.find(filter)!=-1)
        self.label_sp_after_oc_dict_colon.setVisible(filter=='' or 'sp_after_oc_dict_colon'.find(filter)!=-1)
        self.option_sp_after_oc_dict_colon.setVisible(filter=='' or 'sp_after_oc_dict_colon'.find(filter)!=-1)
        self.label_sp_before_oc_dict_colon.setVisible(filter=='' or 'sp_before_oc_dict_colon'.find(filter)!=-1)
        self.option_sp_before_oc_dict_colon.setVisible(filter=='' or 'sp_before_oc_dict_colon'.find(filter)!=-1)
        self.label_sp_after_send_oc_colon.setVisible(filter=='' or 'sp_after_send_oc_colon'.find(filter)!=-1)
        self.option_sp_after_send_oc_colon.setVisible(filter=='' or 'sp_after_send_oc_colon'.find(filter)!=-1)
        self.label_sp_before_send_oc_colon.setVisible(filter=='' or 'sp_before_send_oc_colon'.find(filter)!=-1)
        self.option_sp_before_send_oc_colon.setVisible(filter=='' or 'sp_before_send_oc_colon'.find(filter)!=-1)
        self.label_sp_after_oc_type.setVisible(filter=='' or 'sp_after_oc_type'.find(filter)!=-1)
        self.option_sp_after_oc_type.setVisible(filter=='' or 'sp_after_oc_type'.find(filter)!=-1)
        self.label_sp_after_oc_return_type.setVisible(filter=='' or 'sp_after_oc_return_type'.find(filter)!=-1)
        self.option_sp_after_oc_return_type.setVisible(filter=='' or 'sp_after_oc_return_type'.find(filter)!=-1)
        self.label_sp_after_oc_at_sel.setVisible(filter=='' or 'sp_after_oc_at_sel'.find(filter)!=-1)
        self.option_sp_after_oc_at_sel.setVisible(filter=='' or 'sp_after_oc_at_sel'.find(filter)!=-1)
        self.label_sp_after_oc_at_sel_parens.setVisible(filter=='' or 'sp_after_oc_at_sel_parens'.find(filter)!=-1)
        self.option_sp_after_oc_at_sel_parens.setVisible(filter=='' or 'sp_after_oc_at_sel_parens'.find(filter)!=-1)
        self.label_sp_inside_oc_at_sel_parens.setVisible(filter=='' or 'sp_inside_oc_at_sel_parens'.find(filter)!=-1)
        self.option_sp_inside_oc_at_sel_parens.setVisible(filter=='' or 'sp_inside_oc_at_sel_parens'.find(filter)!=-1)
        self.label_sp_before_oc_block_caret.setVisible(filter=='' or 'sp_before_oc_block_caret'.find(filter)!=-1)
        self.option_sp_before_oc_block_caret.setVisible(filter=='' or 'sp_before_oc_block_caret'.find(filter)!=-1)
        self.label_sp_after_oc_block_caret.setVisible(filter=='' or 'sp_after_oc_block_caret'.find(filter)!=-1)
        self.option_sp_after_oc_block_caret.setVisible(filter=='' or 'sp_after_oc_block_caret'.find(filter)!=-1)
        self.label_sp_after_oc_msg_receiver.setVisible(filter=='' or 'sp_after_oc_msg_receiver'.find(filter)!=-1)
        self.option_sp_after_oc_msg_receiver.setVisible(filter=='' or 'sp_after_oc_msg_receiver'.find(filter)!=-1)
        self.label_sp_after_oc_property.setVisible(filter=='' or 'sp_after_oc_property'.find(filter)!=-1)
        self.option_sp_after_oc_property.setVisible(filter=='' or 'sp_after_oc_property'.find(filter)!=-1)
        self.label_sp_after_oc_synchronized.setVisible(filter=='' or 'sp_after_oc_synchronized'.find(filter)!=-1)
        self.option_sp_after_oc_synchronized.setVisible(filter=='' or 'sp_after_oc_synchronized'.find(filter)!=-1)
        self.label_sp_cond_colon.setVisible(filter=='' or 'sp_cond_colon'.find(filter)!=-1)
        self.option_sp_cond_colon.setVisible(filter=='' or 'sp_cond_colon'.find(filter)!=-1)
        self.label_sp_cond_colon_before.setVisible(filter=='' or 'sp_cond_colon_before'.find(filter)!=-1)
        self.option_sp_cond_colon_before.setVisible(filter=='' or 'sp_cond_colon_before'.find(filter)!=-1)
        self.label_sp_cond_colon_after.setVisible(filter=='' or 'sp_cond_colon_after'.find(filter)!=-1)
        self.option_sp_cond_colon_after.setVisible(filter=='' or 'sp_cond_colon_after'.find(filter)!=-1)
        self.label_sp_cond_question.setVisible(filter=='' or 'sp_cond_question'.find(filter)!=-1)
        self.option_sp_cond_question.setVisible(filter=='' or 'sp_cond_question'.find(filter)!=-1)
        self.label_sp_cond_question_before.setVisible(filter=='' or 'sp_cond_question_before'.find(filter)!=-1)
        self.option_sp_cond_question_before.setVisible(filter=='' or 'sp_cond_question_before'.find(filter)!=-1)
        self.label_sp_cond_question_after.setVisible(filter=='' or 'sp_cond_question_after'.find(filter)!=-1)
        self.option_sp_cond_question_after.setVisible(filter=='' or 'sp_cond_question_after'.find(filter)!=-1)
        self.label_sp_cond_ternary_short.setVisible(filter=='' or 'sp_cond_ternary_short'.find(filter)!=-1)
        self.option_sp_cond_ternary_short.setVisible(filter=='' or 'sp_cond_ternary_short'.find(filter)!=-1)
        self.label_sp_case_label.setVisible(filter=='' or 'sp_case_label'.find(filter)!=-1)
        self.option_sp_case_label.setVisible(filter=='' or 'sp_case_label'.find(filter)!=-1)
        self.label_sp_range.setVisible(filter=='' or 'sp_range'.find(filter)!=-1)
        self.option_sp_range.setVisible(filter=='' or 'sp_range'.find(filter)!=-1)
        self.label_sp_after_for_colon.setVisible(filter=='' or 'sp_after_for_colon'.find(filter)!=-1)
        self.option_sp_after_for_colon.setVisible(filter=='' or 'sp_after_for_colon'.find(filter)!=-1)
        self.label_sp_before_for_colon.setVisible(filter=='' or 'sp_before_for_colon'.find(filter)!=-1)
        self.option_sp_before_for_colon.setVisible(filter=='' or 'sp_before_for_colon'.find(filter)!=-1)
        self.label_sp_extern_paren.setVisible(filter=='' or 'sp_extern_paren'.find(filter)!=-1)
        self.option_sp_extern_paren.setVisible(filter=='' or 'sp_extern_paren'.find(filter)!=-1)
        self.label_sp_cmt_cpp_start.setVisible(filter=='' or 'sp_cmt_cpp_start'.find(filter)!=-1)
        self.option_sp_cmt_cpp_start.setVisible(filter=='' or 'sp_cmt_cpp_start'.find(filter)!=-1)
        self.label_sp_cmt_cpp_pvs.setVisible(filter=='' or 'sp_cmt_cpp_pvs'.find(filter)!=-1)
        self.option_sp_cmt_cpp_pvs.setVisible(filter=='' or 'sp_cmt_cpp_pvs'.find(filter)!=-1)
        self.label_sp_cmt_cpp_lint.setVisible(filter=='' or 'sp_cmt_cpp_lint'.find(filter)!=-1)
        self.option_sp_cmt_cpp_lint.setVisible(filter=='' or 'sp_cmt_cpp_lint'.find(filter)!=-1)
        self.label_sp_cmt_cpp_region.setVisible(filter=='' or 'sp_cmt_cpp_region'.find(filter)!=-1)
        self.option_sp_cmt_cpp_region.setVisible(filter=='' or 'sp_cmt_cpp_region'.find(filter)!=-1)
        self.label_sp_cmt_cpp_doxygen.setVisible(filter=='' or 'sp_cmt_cpp_doxygen'.find(filter)!=-1)
        self.option_sp_cmt_cpp_doxygen.setVisible(filter=='' or 'sp_cmt_cpp_doxygen'.find(filter)!=-1)
        self.label_sp_cmt_cpp_qttr.setVisible(filter=='' or 'sp_cmt_cpp_qttr'.find(filter)!=-1)
        self.option_sp_cmt_cpp_qttr.setVisible(filter=='' or 'sp_cmt_cpp_qttr'.find(filter)!=-1)
        self.label_sp_endif_cmt.setVisible(filter=='' or 'sp_endif_cmt'.find(filter)!=-1)
        self.option_sp_endif_cmt.setVisible(filter=='' or 'sp_endif_cmt'.find(filter)!=-1)
        self.label_sp_after_new.setVisible(filter=='' or 'sp_after_new'.find(filter)!=-1)
        self.option_sp_after_new.setVisible(filter=='' or 'sp_after_new'.find(filter)!=-1)
        self.label_sp_between_new_paren.setVisible(filter=='' or 'sp_between_new_paren'.find(filter)!=-1)
        self.option_sp_between_new_paren.setVisible(filter=='' or 'sp_between_new_paren'.find(filter)!=-1)
        self.label_sp_after_newop_paren.setVisible(filter=='' or 'sp_after_newop_paren'.find(filter)!=-1)
        self.option_sp_after_newop_paren.setVisible(filter=='' or 'sp_after_newop_paren'.find(filter)!=-1)
        self.label_sp_inside_newop_paren.setVisible(filter=='' or 'sp_inside_newop_paren'.find(filter)!=-1)
        self.option_sp_inside_newop_paren.setVisible(filter=='' or 'sp_inside_newop_paren'.find(filter)!=-1)
        self.label_sp_inside_newop_paren_open.setVisible(filter=='' or 'sp_inside_newop_paren_open'.find(filter)!=-1)
        self.option_sp_inside_newop_paren_open.setVisible(filter=='' or 'sp_inside_newop_paren_open'.find(filter)!=-1)
        self.label_sp_inside_newop_paren_close.setVisible(filter=='' or 'sp_inside_newop_paren_close'.find(filter)!=-1)
        self.option_sp_inside_newop_paren_close.setVisible(filter=='' or 'sp_inside_newop_paren_close'.find(filter)!=-1)
        self.label_sp_before_tr_cmt.setVisible(filter=='' or 'sp_before_tr_cmt'.find(filter)!=-1)
        self.option_sp_before_tr_cmt.setVisible(filter=='' or 'sp_before_tr_cmt'.find(filter)!=-1)
        self.label_sp_num_before_tr_cmt.setVisible(filter=='' or 'sp_num_before_tr_cmt'.find(filter)!=-1)
        self.option_sp_num_before_tr_cmt.setVisible(filter=='' or 'sp_num_before_tr_cmt'.find(filter)!=-1)
        self.label_sp_before_emb_cmt.setVisible(filter=='' or 'sp_before_emb_cmt'.find(filter)!=-1)
        self.option_sp_before_emb_cmt.setVisible(filter=='' or 'sp_before_emb_cmt'.find(filter)!=-1)
        self.label_sp_num_before_emb_cmt.setVisible(filter=='' or 'sp_num_before_emb_cmt'.find(filter)!=-1)
        self.option_sp_num_before_emb_cmt.setVisible(filter=='' or 'sp_num_before_emb_cmt'.find(filter)!=-1)
        self.label_sp_after_emb_cmt.setVisible(filter=='' or 'sp_after_emb_cmt'.find(filter)!=-1)
        self.option_sp_after_emb_cmt.setVisible(filter=='' or 'sp_after_emb_cmt'.find(filter)!=-1)
        self.label_sp_num_after_emb_cmt.setVisible(filter=='' or 'sp_num_after_emb_cmt'.find(filter)!=-1)
        self.option_sp_num_after_emb_cmt.setVisible(filter=='' or 'sp_num_after_emb_cmt'.find(filter)!=-1)
        self.label_sp_emb_cmt_priority.setVisible(filter=='' or 'sp_emb_cmt_priority'.find(filter)!=-1)
        self.option_sp_emb_cmt_priority.setVisible(filter=='' or 'sp_emb_cmt_priority'.find(filter)!=-1)
        self.label_sp_annotation_paren.setVisible(filter=='' or 'sp_annotation_paren'.find(filter)!=-1)
        self.option_sp_annotation_paren.setVisible(filter=='' or 'sp_annotation_paren'.find(filter)!=-1)
        self.label_sp_skip_vbrace_tokens.setVisible(filter=='' or 'sp_skip_vbrace_tokens'.find(filter)!=-1)
        self.option_sp_skip_vbrace_tokens.setVisible(filter=='' or 'sp_skip_vbrace_tokens'.find(filter)!=-1)
        self.label_sp_after_noexcept.setVisible(filter=='' or 'sp_after_noexcept'.find(filter)!=-1)
        self.option_sp_after_noexcept.setVisible(filter=='' or 'sp_after_noexcept'.find(filter)!=-1)
        self.label_sp_vala_after_translation.setVisible(filter=='' or 'sp_vala_after_translation'.find(filter)!=-1)
        self.option_sp_vala_after_translation.setVisible(filter=='' or 'sp_vala_after_translation'.find(filter)!=-1)
        self.label_sp_before_bit_colon.setVisible(filter=='' or 'sp_before_bit_colon'.find(filter)!=-1)
        self.option_sp_before_bit_colon.setVisible(filter=='' or 'sp_before_bit_colon'.find(filter)!=-1)
        self.label_sp_after_bit_colon.setVisible(filter=='' or 'sp_after_bit_colon'.find(filter)!=-1)
        self.option_sp_after_bit_colon.setVisible(filter=='' or 'sp_after_bit_colon'.find(filter)!=-1)
        self.label_force_tab_after_define.setVisible(filter=='' or 'force_tab_after_define'.find(filter)!=-1)
        self.option_force_tab_after_define.setVisible(filter=='' or 'force_tab_after_define'.find(filter)!=-1)
        self.label_sp_string_string.setVisible(filter=='' or 'sp_string_string'.find(filter)!=-1)
        self.option_sp_string_string.setVisible(filter=='' or 'sp_string_string'.find(filter)!=-1)
        self.label_sp_struct_type.setVisible(filter=='' or 'sp_struct_type'.find(filter)!=-1)
        self.option_sp_struct_type.setVisible(filter=='' or 'sp_struct_type'.find(filter)!=-1)
        self.label_indent_columns.setVisible(filter=='' or 'indent_columns'.find(filter)!=-1)
        self.option_indent_columns.setVisible(filter=='' or 'indent_columns'.find(filter)!=-1)
        self.label_indent_ignore_first_continue.setVisible(filter=='' or 'indent_ignore_first_continue'.find(filter)!=-1)
        self.option_indent_ignore_first_continue.setVisible(filter=='' or 'indent_ignore_first_continue'.find(filter)!=-1)
        self.label_indent_continue.setVisible(filter=='' or 'indent_continue'.find(filter)!=-1)
        self.option_indent_continue.setVisible(filter=='' or 'indent_continue'.find(filter)!=-1)
        self.label_indent_continue_class_head.setVisible(filter=='' or 'indent_continue_class_head'.find(filter)!=-1)
        self.option_indent_continue_class_head.setVisible(filter=='' or 'indent_continue_class_head'.find(filter)!=-1)
        self.label_indent_single_newlines.setVisible(filter=='' or 'indent_single_newlines'.find(filter)!=-1)
        self.option_indent_single_newlines.setVisible(filter=='' or 'indent_single_newlines'.find(filter)!=-1)
        self.label_indent_param.setVisible(filter=='' or 'indent_param'.find(filter)!=-1)
        self.option_indent_param.setVisible(filter=='' or 'indent_param'.find(filter)!=-1)
        self.label_indent_with_tabs.setVisible(filter=='' or 'indent_with_tabs'.find(filter)!=-1)
        self.option_indent_with_tabs.setVisible(filter=='' or 'indent_with_tabs'.find(filter)!=-1)
        self.label_indent_cmt_with_tabs.setVisible(filter=='' or 'indent_cmt_with_tabs'.find(filter)!=-1)
        self.option_indent_cmt_with_tabs.setVisible(filter=='' or 'indent_cmt_with_tabs'.find(filter)!=-1)
        self.label_indent_align_string.setVisible(filter=='' or 'indent_align_string'.find(filter)!=-1)
        self.option_indent_align_string.setVisible(filter=='' or 'indent_align_string'.find(filter)!=-1)
        self.label_indent_xml_string.setVisible(filter=='' or 'indent_xml_string'.find(filter)!=-1)
        self.option_indent_xml_string.setVisible(filter=='' or 'indent_xml_string'.find(filter)!=-1)
        self.label_indent_brace.setVisible(filter=='' or 'indent_brace'.find(filter)!=-1)
        self.option_indent_brace.setVisible(filter=='' or 'indent_brace'.find(filter)!=-1)
        self.label_indent_braces.setVisible(filter=='' or 'indent_braces'.find(filter)!=-1)
        self.option_indent_braces.setVisible(filter=='' or 'indent_braces'.find(filter)!=-1)
        self.label_indent_braces_no_func.setVisible(filter=='' or 'indent_braces_no_func'.find(filter)!=-1)
        self.option_indent_braces_no_func.setVisible(filter=='' or 'indent_braces_no_func'.find(filter)!=-1)
        self.label_indent_braces_no_class.setVisible(filter=='' or 'indent_braces_no_class'.find(filter)!=-1)
        self.option_indent_braces_no_class.setVisible(filter=='' or 'indent_braces_no_class'.find(filter)!=-1)
        self.label_indent_braces_no_struct.setVisible(filter=='' or 'indent_braces_no_struct'.find(filter)!=-1)
        self.option_indent_braces_no_struct.setVisible(filter=='' or 'indent_braces_no_struct'.find(filter)!=-1)
        self.label_indent_brace_parent.setVisible(filter=='' or 'indent_brace_parent'.find(filter)!=-1)
        self.option_indent_brace_parent.setVisible(filter=='' or 'indent_brace_parent'.find(filter)!=-1)
        self.label_indent_paren_open_brace.setVisible(filter=='' or 'indent_paren_open_brace'.find(filter)!=-1)
        self.option_indent_paren_open_brace.setVisible(filter=='' or 'indent_paren_open_brace'.find(filter)!=-1)
        self.label_indent_cs_delegate_brace.setVisible(filter=='' or 'indent_cs_delegate_brace'.find(filter)!=-1)
        self.option_indent_cs_delegate_brace.setVisible(filter=='' or 'indent_cs_delegate_brace'.find(filter)!=-1)
        self.label_indent_cs_delegate_body.setVisible(filter=='' or 'indent_cs_delegate_body'.find(filter)!=-1)
        self.option_indent_cs_delegate_body.setVisible(filter=='' or 'indent_cs_delegate_body'.find(filter)!=-1)
        self.label_indent_namespace.setVisible(filter=='' or 'indent_namespace'.find(filter)!=-1)
        self.option_indent_namespace.setVisible(filter=='' or 'indent_namespace'.find(filter)!=-1)
        self.label_indent_namespace_single_indent.setVisible(filter=='' or 'indent_namespace_single_indent'.find(filter)!=-1)
        self.option_indent_namespace_single_indent.setVisible(filter=='' or 'indent_namespace_single_indent'.find(filter)!=-1)
        self.label_indent_namespace_level.setVisible(filter=='' or 'indent_namespace_level'.find(filter)!=-1)
        self.option_indent_namespace_level.setVisible(filter=='' or 'indent_namespace_level'.find(filter)!=-1)
        self.label_indent_namespace_limit.setVisible(filter=='' or 'indent_namespace_limit'.find(filter)!=-1)
        self.option_indent_namespace_limit.setVisible(filter=='' or 'indent_namespace_limit'.find(filter)!=-1)
        self.label_indent_namespace_inner_only.setVisible(filter=='' or 'indent_namespace_inner_only'.find(filter)!=-1)
        self.option_indent_namespace_inner_only.setVisible(filter=='' or 'indent_namespace_inner_only'.find(filter)!=-1)
        self.label_indent_extern.setVisible(filter=='' or 'indent_extern'.find(filter)!=-1)
        self.option_indent_extern.setVisible(filter=='' or 'indent_extern'.find(filter)!=-1)
        self.label_indent_class.setVisible(filter=='' or 'indent_class'.find(filter)!=-1)
        self.option_indent_class.setVisible(filter=='' or 'indent_class'.find(filter)!=-1)
        self.label_indent_ignore_before_class_colon.setVisible(filter=='' or 'indent_ignore_before_class_colon'.find(filter)!=-1)
        self.option_indent_ignore_before_class_colon.setVisible(filter=='' or 'indent_ignore_before_class_colon'.find(filter)!=-1)
        self.label_indent_before_class_colon.setVisible(filter=='' or 'indent_before_class_colon'.find(filter)!=-1)
        self.option_indent_before_class_colon.setVisible(filter=='' or 'indent_before_class_colon'.find(filter)!=-1)
        self.label_indent_class_colon.setVisible(filter=='' or 'indent_class_colon'.find(filter)!=-1)
        self.option_indent_class_colon.setVisible(filter=='' or 'indent_class_colon'.find(filter)!=-1)
        self.label_indent_class_on_colon.setVisible(filter=='' or 'indent_class_on_colon'.find(filter)!=-1)
        self.option_indent_class_on_colon.setVisible(filter=='' or 'indent_class_on_colon'.find(filter)!=-1)
        self.label_indent_ignore_before_constr_colon.setVisible(filter=='' or 'indent_ignore_before_constr_colon'.find(filter)!=-1)
        self.option_indent_ignore_before_constr_colon.setVisible(filter=='' or 'indent_ignore_before_constr_colon'.find(filter)!=-1)
        self.label_indent_constr_colon.setVisible(filter=='' or 'indent_constr_colon'.find(filter)!=-1)
        self.option_indent_constr_colon.setVisible(filter=='' or 'indent_constr_colon'.find(filter)!=-1)
        self.label_indent_ctor_init_leading.setVisible(filter=='' or 'indent_ctor_init_leading'.find(filter)!=-1)
        self.option_indent_ctor_init_leading.setVisible(filter=='' or 'indent_ctor_init_leading'.find(filter)!=-1)
        self.label_indent_ctor_init_following.setVisible(filter=='' or 'indent_ctor_init_following'.find(filter)!=-1)
        self.option_indent_ctor_init_following.setVisible(filter=='' or 'indent_ctor_init_following'.find(filter)!=-1)
        self.label_indent_ctor_init.setVisible(filter=='' or 'indent_ctor_init'.find(filter)!=-1)
        self.option_indent_ctor_init.setVisible(filter=='' or 'indent_ctor_init'.find(filter)!=-1)
        self.label_indent_else_if.setVisible(filter=='' or 'indent_else_if'.find(filter)!=-1)
        self.option_indent_else_if.setVisible(filter=='' or 'indent_else_if'.find(filter)!=-1)
        self.label_indent_var_def_blk.setVisible(filter=='' or 'indent_var_def_blk'.find(filter)!=-1)
        self.option_indent_var_def_blk.setVisible(filter=='' or 'indent_var_def_blk'.find(filter)!=-1)
        self.label_indent_var_def_cont.setVisible(filter=='' or 'indent_var_def_cont'.find(filter)!=-1)
        self.option_indent_var_def_cont.setVisible(filter=='' or 'indent_var_def_cont'.find(filter)!=-1)
        self.label_indent_shift.setVisible(filter=='' or 'indent_shift'.find(filter)!=-1)
        self.option_indent_shift.setVisible(filter=='' or 'indent_shift'.find(filter)!=-1)
        self.label_indent_func_def_force_col1.setVisible(filter=='' or 'indent_func_def_force_col1'.find(filter)!=-1)
        self.option_indent_func_def_force_col1.setVisible(filter=='' or 'indent_func_def_force_col1'.find(filter)!=-1)
        self.label_indent_func_call_param.setVisible(filter=='' or 'indent_func_call_param'.find(filter)!=-1)
        self.option_indent_func_call_param.setVisible(filter=='' or 'indent_func_call_param'.find(filter)!=-1)
        self.label_indent_func_def_param.setVisible(filter=='' or 'indent_func_def_param'.find(filter)!=-1)
        self.option_indent_func_def_param.setVisible(filter=='' or 'indent_func_def_param'.find(filter)!=-1)
        self.label_indent_func_def_param_paren_pos_threshold.setVisible(filter=='' or 'indent_func_def_param_paren_pos_threshold'.find(filter)!=-1)
        self.option_indent_func_def_param_paren_pos_threshold.setVisible(filter=='' or 'indent_func_def_param_paren_pos_threshold'.find(filter)!=-1)
        self.label_indent_func_proto_param.setVisible(filter=='' or 'indent_func_proto_param'.find(filter)!=-1)
        self.option_indent_func_proto_param.setVisible(filter=='' or 'indent_func_proto_param'.find(filter)!=-1)
        self.label_indent_func_class_param.setVisible(filter=='' or 'indent_func_class_param'.find(filter)!=-1)
        self.option_indent_func_class_param.setVisible(filter=='' or 'indent_func_class_param'.find(filter)!=-1)
        self.label_indent_func_ctor_var_param.setVisible(filter=='' or 'indent_func_ctor_var_param'.find(filter)!=-1)
        self.option_indent_func_ctor_var_param.setVisible(filter=='' or 'indent_func_ctor_var_param'.find(filter)!=-1)
        self.label_indent_template_param.setVisible(filter=='' or 'indent_template_param'.find(filter)!=-1)
        self.option_indent_template_param.setVisible(filter=='' or 'indent_template_param'.find(filter)!=-1)
        self.label_indent_func_param_double.setVisible(filter=='' or 'indent_func_param_double'.find(filter)!=-1)
        self.option_indent_func_param_double.setVisible(filter=='' or 'indent_func_param_double'.find(filter)!=-1)
        self.label_indent_func_const.setVisible(filter=='' or 'indent_func_const'.find(filter)!=-1)
        self.option_indent_func_const.setVisible(filter=='' or 'indent_func_const'.find(filter)!=-1)
        self.label_indent_func_throw.setVisible(filter=='' or 'indent_func_throw'.find(filter)!=-1)
        self.option_indent_func_throw.setVisible(filter=='' or 'indent_func_throw'.find(filter)!=-1)
        self.label_indent_macro_brace.setVisible(filter=='' or 'indent_macro_brace'.find(filter)!=-1)
        self.option_indent_macro_brace.setVisible(filter=='' or 'indent_macro_brace'.find(filter)!=-1)
        self.label_indent_member.setVisible(filter=='' or 'indent_member'.find(filter)!=-1)
        self.option_indent_member.setVisible(filter=='' or 'indent_member'.find(filter)!=-1)
        self.label_indent_member_single.setVisible(filter=='' or 'indent_member_single'.find(filter)!=-1)
        self.option_indent_member_single.setVisible(filter=='' or 'indent_member_single'.find(filter)!=-1)
        self.label_indent_single_line_comments_before.setVisible(filter=='' or 'indent_single_line_comments_before'.find(filter)!=-1)
        self.option_indent_single_line_comments_before.setVisible(filter=='' or 'indent_single_line_comments_before'.find(filter)!=-1)
        self.label_indent_single_line_comments_after.setVisible(filter=='' or 'indent_single_line_comments_after'.find(filter)!=-1)
        self.option_indent_single_line_comments_after.setVisible(filter=='' or 'indent_single_line_comments_after'.find(filter)!=-1)
        self.label_indent_sparen_extra.setVisible(filter=='' or 'indent_sparen_extra'.find(filter)!=-1)
        self.option_indent_sparen_extra.setVisible(filter=='' or 'indent_sparen_extra'.find(filter)!=-1)
        self.label_indent_relative_single_line_comments.setVisible(filter=='' or 'indent_relative_single_line_comments'.find(filter)!=-1)
        self.option_indent_relative_single_line_comments.setVisible(filter=='' or 'indent_relative_single_line_comments'.find(filter)!=-1)
        self.label_indent_switch_case.setVisible(filter=='' or 'indent_switch_case'.find(filter)!=-1)
        self.option_indent_switch_case.setVisible(filter=='' or 'indent_switch_case'.find(filter)!=-1)
        self.label_indent_switch_body.setVisible(filter=='' or 'indent_switch_body'.find(filter)!=-1)
        self.option_indent_switch_body.setVisible(filter=='' or 'indent_switch_body'.find(filter)!=-1)
        self.label_indent_ignore_case_brace.setVisible(filter=='' or 'indent_ignore_case_brace'.find(filter)!=-1)
        self.option_indent_ignore_case_brace.setVisible(filter=='' or 'indent_ignore_case_brace'.find(filter)!=-1)
        self.label_indent_case_brace.setVisible(filter=='' or 'indent_case_brace'.find(filter)!=-1)
        self.option_indent_case_brace.setVisible(filter=='' or 'indent_case_brace'.find(filter)!=-1)
        self.label_indent_switch_break_with_case.setVisible(filter=='' or 'indent_switch_break_with_case'.find(filter)!=-1)
        self.option_indent_switch_break_with_case.setVisible(filter=='' or 'indent_switch_break_with_case'.find(filter)!=-1)
        self.label_indent_switch_pp.setVisible(filter=='' or 'indent_switch_pp'.find(filter)!=-1)
        self.option_indent_switch_pp.setVisible(filter=='' or 'indent_switch_pp'.find(filter)!=-1)
        self.label_indent_case_shift.setVisible(filter=='' or 'indent_case_shift'.find(filter)!=-1)
        self.option_indent_case_shift.setVisible(filter=='' or 'indent_case_shift'.find(filter)!=-1)
        self.label_indent_case_comment.setVisible(filter=='' or 'indent_case_comment'.find(filter)!=-1)
        self.option_indent_case_comment.setVisible(filter=='' or 'indent_case_comment'.find(filter)!=-1)
        self.label_indent_comment.setVisible(filter=='' or 'indent_comment'.find(filter)!=-1)
        self.option_indent_comment.setVisible(filter=='' or 'indent_comment'.find(filter)!=-1)
        self.label_indent_col1_comment.setVisible(filter=='' or 'indent_col1_comment'.find(filter)!=-1)
        self.option_indent_col1_comment.setVisible(filter=='' or 'indent_col1_comment'.find(filter)!=-1)
        self.label_indent_col1_multi_string_literal.setVisible(filter=='' or 'indent_col1_multi_string_literal'.find(filter)!=-1)
        self.option_indent_col1_multi_string_literal.setVisible(filter=='' or 'indent_col1_multi_string_literal'.find(filter)!=-1)
        self.label_indent_comment_align_thresh.setVisible(filter=='' or 'indent_comment_align_thresh'.find(filter)!=-1)
        self.option_indent_comment_align_thresh.setVisible(filter=='' or 'indent_comment_align_thresh'.find(filter)!=-1)
        self.label_indent_ignore_label.setVisible(filter=='' or 'indent_ignore_label'.find(filter)!=-1)
        self.option_indent_ignore_label.setVisible(filter=='' or 'indent_ignore_label'.find(filter)!=-1)
        self.label_indent_label.setVisible(filter=='' or 'indent_label'.find(filter)!=-1)
        self.option_indent_label.setVisible(filter=='' or 'indent_label'.find(filter)!=-1)
        self.label_indent_access_spec.setVisible(filter=='' or 'indent_access_spec'.find(filter)!=-1)
        self.option_indent_access_spec.setVisible(filter=='' or 'indent_access_spec'.find(filter)!=-1)
        self.label_indent_access_spec_body.setVisible(filter=='' or 'indent_access_spec_body'.find(filter)!=-1)
        self.option_indent_access_spec_body.setVisible(filter=='' or 'indent_access_spec_body'.find(filter)!=-1)
        self.label_indent_paren_nl.setVisible(filter=='' or 'indent_paren_nl'.find(filter)!=-1)
        self.option_indent_paren_nl.setVisible(filter=='' or 'indent_paren_nl'.find(filter)!=-1)
        self.label_indent_paren_close.setVisible(filter=='' or 'indent_paren_close'.find(filter)!=-1)
        self.option_indent_paren_close.setVisible(filter=='' or 'indent_paren_close'.find(filter)!=-1)
        self.label_indent_paren_after_func_def.setVisible(filter=='' or 'indent_paren_after_func_def'.find(filter)!=-1)
        self.option_indent_paren_after_func_def.setVisible(filter=='' or 'indent_paren_after_func_def'.find(filter)!=-1)
        self.label_indent_paren_after_func_decl.setVisible(filter=='' or 'indent_paren_after_func_decl'.find(filter)!=-1)
        self.option_indent_paren_after_func_decl.setVisible(filter=='' or 'indent_paren_after_func_decl'.find(filter)!=-1)
        self.label_indent_paren_after_func_call.setVisible(filter=='' or 'indent_paren_after_func_call'.find(filter)!=-1)
        self.option_indent_paren_after_func_call.setVisible(filter=='' or 'indent_paren_after_func_call'.find(filter)!=-1)
        self.label_indent_comma_brace.setVisible(filter=='' or 'indent_comma_brace'.find(filter)!=-1)
        self.option_indent_comma_brace.setVisible(filter=='' or 'indent_comma_brace'.find(filter)!=-1)
        self.label_indent_comma_paren.setVisible(filter=='' or 'indent_comma_paren'.find(filter)!=-1)
        self.option_indent_comma_paren.setVisible(filter=='' or 'indent_comma_paren'.find(filter)!=-1)
        self.label_indent_bool_paren.setVisible(filter=='' or 'indent_bool_paren'.find(filter)!=-1)
        self.option_indent_bool_paren.setVisible(filter=='' or 'indent_bool_paren'.find(filter)!=-1)
        self.label_indent_ignore_bool.setVisible(filter=='' or 'indent_ignore_bool'.find(filter)!=-1)
        self.option_indent_ignore_bool.setVisible(filter=='' or 'indent_ignore_bool'.find(filter)!=-1)
        self.label_indent_ignore_arith.setVisible(filter=='' or 'indent_ignore_arith'.find(filter)!=-1)
        self.option_indent_ignore_arith.setVisible(filter=='' or 'indent_ignore_arith'.find(filter)!=-1)
        self.label_indent_semicolon_for_paren.setVisible(filter=='' or 'indent_semicolon_for_paren'.find(filter)!=-1)
        self.option_indent_semicolon_for_paren.setVisible(filter=='' or 'indent_semicolon_for_paren'.find(filter)!=-1)
        self.label_indent_ignore_semicolon.setVisible(filter=='' or 'indent_ignore_semicolon'.find(filter)!=-1)
        self.option_indent_ignore_semicolon.setVisible(filter=='' or 'indent_ignore_semicolon'.find(filter)!=-1)
        self.label_indent_first_bool_expr.setVisible(filter=='' or 'indent_first_bool_expr'.find(filter)!=-1)
        self.option_indent_first_bool_expr.setVisible(filter=='' or 'indent_first_bool_expr'.find(filter)!=-1)
        self.label_indent_first_for_expr.setVisible(filter=='' or 'indent_first_for_expr'.find(filter)!=-1)
        self.option_indent_first_for_expr.setVisible(filter=='' or 'indent_first_for_expr'.find(filter)!=-1)
        self.label_indent_square_nl.setVisible(filter=='' or 'indent_square_nl'.find(filter)!=-1)
        self.option_indent_square_nl.setVisible(filter=='' or 'indent_square_nl'.find(filter)!=-1)
        self.label_indent_preserve_sql.setVisible(filter=='' or 'indent_preserve_sql'.find(filter)!=-1)
        self.option_indent_preserve_sql.setVisible(filter=='' or 'indent_preserve_sql'.find(filter)!=-1)
        self.label_indent_ignore_assign.setVisible(filter=='' or 'indent_ignore_assign'.find(filter)!=-1)
        self.option_indent_ignore_assign.setVisible(filter=='' or 'indent_ignore_assign'.find(filter)!=-1)
        self.label_indent_align_assign.setVisible(filter=='' or 'indent_align_assign'.find(filter)!=-1)
        self.option_indent_align_assign.setVisible(filter=='' or 'indent_align_assign'.find(filter)!=-1)
        self.label_indent_off_after_assign.setVisible(filter=='' or 'indent_off_after_assign'.find(filter)!=-1)
        self.option_indent_off_after_assign.setVisible(filter=='' or 'indent_off_after_assign'.find(filter)!=-1)
        self.label_indent_align_paren.setVisible(filter=='' or 'indent_align_paren'.find(filter)!=-1)
        self.option_indent_align_paren.setVisible(filter=='' or 'indent_align_paren'.find(filter)!=-1)
        self.label_indent_oc_inside_msg_sel.setVisible(filter=='' or 'indent_oc_inside_msg_sel'.find(filter)!=-1)
        self.option_indent_oc_inside_msg_sel.setVisible(filter=='' or 'indent_oc_inside_msg_sel'.find(filter)!=-1)
        self.label_indent_oc_block.setVisible(filter=='' or 'indent_oc_block'.find(filter)!=-1)
        self.option_indent_oc_block.setVisible(filter=='' or 'indent_oc_block'.find(filter)!=-1)
        self.label_indent_oc_block_msg.setVisible(filter=='' or 'indent_oc_block_msg'.find(filter)!=-1)
        self.option_indent_oc_block_msg.setVisible(filter=='' or 'indent_oc_block_msg'.find(filter)!=-1)
        self.label_indent_oc_msg_colon.setVisible(filter=='' or 'indent_oc_msg_colon'.find(filter)!=-1)
        self.option_indent_oc_msg_colon.setVisible(filter=='' or 'indent_oc_msg_colon'.find(filter)!=-1)
        self.label_indent_oc_msg_prioritize_first_colon.setVisible(filter=='' or 'indent_oc_msg_prioritize_first_colon'.find(filter)!=-1)
        self.option_indent_oc_msg_prioritize_first_colon.setVisible(filter=='' or 'indent_oc_msg_prioritize_first_colon'.find(filter)!=-1)
        self.label_indent_oc_block_msg_xcode_style.setVisible(filter=='' or 'indent_oc_block_msg_xcode_style'.find(filter)!=-1)
        self.option_indent_oc_block_msg_xcode_style.setVisible(filter=='' or 'indent_oc_block_msg_xcode_style'.find(filter)!=-1)
        self.label_indent_oc_block_msg_from_keyword.setVisible(filter=='' or 'indent_oc_block_msg_from_keyword'.find(filter)!=-1)
        self.option_indent_oc_block_msg_from_keyword.setVisible(filter=='' or 'indent_oc_block_msg_from_keyword'.find(filter)!=-1)
        self.label_indent_oc_block_msg_from_colon.setVisible(filter=='' or 'indent_oc_block_msg_from_colon'.find(filter)!=-1)
        self.option_indent_oc_block_msg_from_colon.setVisible(filter=='' or 'indent_oc_block_msg_from_colon'.find(filter)!=-1)
        self.label_indent_oc_block_msg_from_caret.setVisible(filter=='' or 'indent_oc_block_msg_from_caret'.find(filter)!=-1)
        self.option_indent_oc_block_msg_from_caret.setVisible(filter=='' or 'indent_oc_block_msg_from_caret'.find(filter)!=-1)
        self.label_indent_oc_block_msg_from_brace.setVisible(filter=='' or 'indent_oc_block_msg_from_brace'.find(filter)!=-1)
        self.option_indent_oc_block_msg_from_brace.setVisible(filter=='' or 'indent_oc_block_msg_from_brace'.find(filter)!=-1)
        self.label_indent_min_vbrace_open.setVisible(filter=='' or 'indent_min_vbrace_open'.find(filter)!=-1)
        self.option_indent_min_vbrace_open.setVisible(filter=='' or 'indent_min_vbrace_open'.find(filter)!=-1)
        self.label_indent_vbrace_open_on_tabstop.setVisible(filter=='' or 'indent_vbrace_open_on_tabstop'.find(filter)!=-1)
        self.option_indent_vbrace_open_on_tabstop.setVisible(filter=='' or 'indent_vbrace_open_on_tabstop'.find(filter)!=-1)
        self.label_indent_token_after_brace.setVisible(filter=='' or 'indent_token_after_brace'.find(filter)!=-1)
        self.option_indent_token_after_brace.setVisible(filter=='' or 'indent_token_after_brace'.find(filter)!=-1)
        self.label_indent_cpp_lambda_body.setVisible(filter=='' or 'indent_cpp_lambda_body'.find(filter)!=-1)
        self.option_indent_cpp_lambda_body.setVisible(filter=='' or 'indent_cpp_lambda_body'.find(filter)!=-1)
        self.label_indent_compound_literal_return.setVisible(filter=='' or 'indent_compound_literal_return'.find(filter)!=-1)
        self.option_indent_compound_literal_return.setVisible(filter=='' or 'indent_compound_literal_return'.find(filter)!=-1)
        self.label_indent_using_block.setVisible(filter=='' or 'indent_using_block'.find(filter)!=-1)
        self.option_indent_using_block.setVisible(filter=='' or 'indent_using_block'.find(filter)!=-1)
        self.label_indent_ternary_operator.setVisible(filter=='' or 'indent_ternary_operator'.find(filter)!=-1)
        self.option_indent_ternary_operator.setVisible(filter=='' or 'indent_ternary_operator'.find(filter)!=-1)
        self.label_indent_inside_ternary_operator.setVisible(filter=='' or 'indent_inside_ternary_operator'.find(filter)!=-1)
        self.option_indent_inside_ternary_operator.setVisible(filter=='' or 'indent_inside_ternary_operator'.find(filter)!=-1)
        self.label_indent_off_after_return.setVisible(filter=='' or 'indent_off_after_return'.find(filter)!=-1)
        self.option_indent_off_after_return.setVisible(filter=='' or 'indent_off_after_return'.find(filter)!=-1)
        self.label_indent_off_after_return_new.setVisible(filter=='' or 'indent_off_after_return_new'.find(filter)!=-1)
        self.option_indent_off_after_return_new.setVisible(filter=='' or 'indent_off_after_return_new'.find(filter)!=-1)
        self.label_indent_single_after_return.setVisible(filter=='' or 'indent_single_after_return'.find(filter)!=-1)
        self.option_indent_single_after_return.setVisible(filter=='' or 'indent_single_after_return'.find(filter)!=-1)
        self.label_indent_ignore_asm_block.setVisible(filter=='' or 'indent_ignore_asm_block'.find(filter)!=-1)
        self.option_indent_ignore_asm_block.setVisible(filter=='' or 'indent_ignore_asm_block'.find(filter)!=-1)
        self.label_donot_indent_func_def_close_paren.setVisible(filter=='' or 'donot_indent_func_def_close_paren'.find(filter)!=-1)
        self.option_donot_indent_func_def_close_paren.setVisible(filter=='' or 'donot_indent_func_def_close_paren'.find(filter)!=-1)
        self.label_nl_collapse_empty_body.setVisible(filter=='' or 'nl_collapse_empty_body'.find(filter)!=-1)
        self.option_nl_collapse_empty_body.setVisible(filter=='' or 'nl_collapse_empty_body'.find(filter)!=-1)
        self.label_nl_collapse_empty_body_functions.setVisible(filter=='' or 'nl_collapse_empty_body_functions'.find(filter)!=-1)
        self.option_nl_collapse_empty_body_functions.setVisible(filter=='' or 'nl_collapse_empty_body_functions'.find(filter)!=-1)
        self.label_nl_assign_leave_one_liners.setVisible(filter=='' or 'nl_assign_leave_one_liners'.find(filter)!=-1)
        self.option_nl_assign_leave_one_liners.setVisible(filter=='' or 'nl_assign_leave_one_liners'.find(filter)!=-1)
        self.label_nl_class_leave_one_liners.setVisible(filter=='' or 'nl_class_leave_one_liners'.find(filter)!=-1)
        self.option_nl_class_leave_one_liners.setVisible(filter=='' or 'nl_class_leave_one_liners'.find(filter)!=-1)
        self.label_nl_enum_leave_one_liners.setVisible(filter=='' or 'nl_enum_leave_one_liners'.find(filter)!=-1)
        self.option_nl_enum_leave_one_liners.setVisible(filter=='' or 'nl_enum_leave_one_liners'.find(filter)!=-1)
        self.label_nl_getset_leave_one_liners.setVisible(filter=='' or 'nl_getset_leave_one_liners'.find(filter)!=-1)
        self.option_nl_getset_leave_one_liners.setVisible(filter=='' or 'nl_getset_leave_one_liners'.find(filter)!=-1)
        self.label_nl_cs_property_leave_one_liners.setVisible(filter=='' or 'nl_cs_property_leave_one_liners'.find(filter)!=-1)
        self.option_nl_cs_property_leave_one_liners.setVisible(filter=='' or 'nl_cs_property_leave_one_liners'.find(filter)!=-1)
        self.label_nl_func_leave_one_liners.setVisible(filter=='' or 'nl_func_leave_one_liners'.find(filter)!=-1)
        self.option_nl_func_leave_one_liners.setVisible(filter=='' or 'nl_func_leave_one_liners'.find(filter)!=-1)
        self.label_nl_cpp_lambda_leave_one_liners.setVisible(filter=='' or 'nl_cpp_lambda_leave_one_liners'.find(filter)!=-1)
        self.option_nl_cpp_lambda_leave_one_liners.setVisible(filter=='' or 'nl_cpp_lambda_leave_one_liners'.find(filter)!=-1)
        self.label_nl_if_leave_one_liners.setVisible(filter=='' or 'nl_if_leave_one_liners'.find(filter)!=-1)
        self.option_nl_if_leave_one_liners.setVisible(filter=='' or 'nl_if_leave_one_liners'.find(filter)!=-1)
        self.label_nl_while_leave_one_liners.setVisible(filter=='' or 'nl_while_leave_one_liners'.find(filter)!=-1)
        self.option_nl_while_leave_one_liners.setVisible(filter=='' or 'nl_while_leave_one_liners'.find(filter)!=-1)
        self.label_nl_do_leave_one_liners.setVisible(filter=='' or 'nl_do_leave_one_liners'.find(filter)!=-1)
        self.option_nl_do_leave_one_liners.setVisible(filter=='' or 'nl_do_leave_one_liners'.find(filter)!=-1)
        self.label_nl_for_leave_one_liners.setVisible(filter=='' or 'nl_for_leave_one_liners'.find(filter)!=-1)
        self.option_nl_for_leave_one_liners.setVisible(filter=='' or 'nl_for_leave_one_liners'.find(filter)!=-1)
        self.label_nl_oc_msg_leave_one_liner.setVisible(filter=='' or 'nl_oc_msg_leave_one_liner'.find(filter)!=-1)
        self.option_nl_oc_msg_leave_one_liner.setVisible(filter=='' or 'nl_oc_msg_leave_one_liner'.find(filter)!=-1)
        self.label_nl_oc_mdef_brace.setVisible(filter=='' or 'nl_oc_mdef_brace'.find(filter)!=-1)
        self.option_nl_oc_mdef_brace.setVisible(filter=='' or 'nl_oc_mdef_brace'.find(filter)!=-1)
        self.label_nl_oc_block_brace.setVisible(filter=='' or 'nl_oc_block_brace'.find(filter)!=-1)
        self.option_nl_oc_block_brace.setVisible(filter=='' or 'nl_oc_block_brace'.find(filter)!=-1)
        self.label_nl_oc_before_interface.setVisible(filter=='' or 'nl_oc_before_interface'.find(filter)!=-1)
        self.option_nl_oc_before_interface.setVisible(filter=='' or 'nl_oc_before_interface'.find(filter)!=-1)
        self.label_nl_oc_before_implementation.setVisible(filter=='' or 'nl_oc_before_implementation'.find(filter)!=-1)
        self.option_nl_oc_before_implementation.setVisible(filter=='' or 'nl_oc_before_implementation'.find(filter)!=-1)
        self.label_nl_oc_before_end.setVisible(filter=='' or 'nl_oc_before_end'.find(filter)!=-1)
        self.option_nl_oc_before_end.setVisible(filter=='' or 'nl_oc_before_end'.find(filter)!=-1)
        self.label_nl_oc_interface_brace.setVisible(filter=='' or 'nl_oc_interface_brace'.find(filter)!=-1)
        self.option_nl_oc_interface_brace.setVisible(filter=='' or 'nl_oc_interface_brace'.find(filter)!=-1)
        self.label_nl_oc_implementation_brace.setVisible(filter=='' or 'nl_oc_implementation_brace'.find(filter)!=-1)
        self.option_nl_oc_implementation_brace.setVisible(filter=='' or 'nl_oc_implementation_brace'.find(filter)!=-1)
        self.label_nl_start_of_file.setVisible(filter=='' or 'nl_start_of_file'.find(filter)!=-1)
        self.option_nl_start_of_file.setVisible(filter=='' or 'nl_start_of_file'.find(filter)!=-1)
        self.label_nl_start_of_file_min.setVisible(filter=='' or 'nl_start_of_file_min'.find(filter)!=-1)
        self.option_nl_start_of_file_min.setVisible(filter=='' or 'nl_start_of_file_min'.find(filter)!=-1)
        self.label_nl_end_of_file.setVisible(filter=='' or 'nl_end_of_file'.find(filter)!=-1)
        self.option_nl_end_of_file.setVisible(filter=='' or 'nl_end_of_file'.find(filter)!=-1)
        self.label_nl_end_of_file_min.setVisible(filter=='' or 'nl_end_of_file_min'.find(filter)!=-1)
        self.option_nl_end_of_file_min.setVisible(filter=='' or 'nl_end_of_file_min'.find(filter)!=-1)
        self.label_nl_assign_brace.setVisible(filter=='' or 'nl_assign_brace'.find(filter)!=-1)
        self.option_nl_assign_brace.setVisible(filter=='' or 'nl_assign_brace'.find(filter)!=-1)
        self.label_nl_assign_square.setVisible(filter=='' or 'nl_assign_square'.find(filter)!=-1)
        self.option_nl_assign_square.setVisible(filter=='' or 'nl_assign_square'.find(filter)!=-1)
        self.label_nl_tsquare_brace.setVisible(filter=='' or 'nl_tsquare_brace'.find(filter)!=-1)
        self.option_nl_tsquare_brace.setVisible(filter=='' or 'nl_tsquare_brace'.find(filter)!=-1)
        self.label_nl_after_square_assign.setVisible(filter=='' or 'nl_after_square_assign'.find(filter)!=-1)
        self.option_nl_after_square_assign.setVisible(filter=='' or 'nl_after_square_assign'.find(filter)!=-1)
        self.label_nl_fcall_brace.setVisible(filter=='' or 'nl_fcall_brace'.find(filter)!=-1)
        self.option_nl_fcall_brace.setVisible(filter=='' or 'nl_fcall_brace'.find(filter)!=-1)
        self.label_nl_enum_brace.setVisible(filter=='' or 'nl_enum_brace'.find(filter)!=-1)
        self.option_nl_enum_brace.setVisible(filter=='' or 'nl_enum_brace'.find(filter)!=-1)
        self.label_nl_enum_class.setVisible(filter=='' or 'nl_enum_class'.find(filter)!=-1)
        self.option_nl_enum_class.setVisible(filter=='' or 'nl_enum_class'.find(filter)!=-1)
        self.label_nl_enum_class_identifier.setVisible(filter=='' or 'nl_enum_class_identifier'.find(filter)!=-1)
        self.option_nl_enum_class_identifier.setVisible(filter=='' or 'nl_enum_class_identifier'.find(filter)!=-1)
        self.label_nl_enum_identifier_colon.setVisible(filter=='' or 'nl_enum_identifier_colon'.find(filter)!=-1)
        self.option_nl_enum_identifier_colon.setVisible(filter=='' or 'nl_enum_identifier_colon'.find(filter)!=-1)
        self.label_nl_enum_colon_type.setVisible(filter=='' or 'nl_enum_colon_type'.find(filter)!=-1)
        self.option_nl_enum_colon_type.setVisible(filter=='' or 'nl_enum_colon_type'.find(filter)!=-1)
        self.label_nl_struct_brace.setVisible(filter=='' or 'nl_struct_brace'.find(filter)!=-1)
        self.option_nl_struct_brace.setVisible(filter=='' or 'nl_struct_brace'.find(filter)!=-1)
        self.label_nl_union_brace.setVisible(filter=='' or 'nl_union_brace'.find(filter)!=-1)
        self.option_nl_union_brace.setVisible(filter=='' or 'nl_union_brace'.find(filter)!=-1)
        self.label_nl_if_brace.setVisible(filter=='' or 'nl_if_brace'.find(filter)!=-1)
        self.option_nl_if_brace.setVisible(filter=='' or 'nl_if_brace'.find(filter)!=-1)
        self.label_nl_brace_else.setVisible(filter=='' or 'nl_brace_else'.find(filter)!=-1)
        self.option_nl_brace_else.setVisible(filter=='' or 'nl_brace_else'.find(filter)!=-1)
        self.label_nl_elseif_brace.setVisible(filter=='' or 'nl_elseif_brace'.find(filter)!=-1)
        self.option_nl_elseif_brace.setVisible(filter=='' or 'nl_elseif_brace'.find(filter)!=-1)
        self.label_nl_else_brace.setVisible(filter=='' or 'nl_else_brace'.find(filter)!=-1)
        self.option_nl_else_brace.setVisible(filter=='' or 'nl_else_brace'.find(filter)!=-1)
        self.label_nl_else_if.setVisible(filter=='' or 'nl_else_if'.find(filter)!=-1)
        self.option_nl_else_if.setVisible(filter=='' or 'nl_else_if'.find(filter)!=-1)
        self.label_nl_before_opening_brace_func_class_def.setVisible(filter=='' or 'nl_before_opening_brace_func_class_def'.find(filter)!=-1)
        self.option_nl_before_opening_brace_func_class_def.setVisible(filter=='' or 'nl_before_opening_brace_func_class_def'.find(filter)!=-1)
        self.label_nl_before_if_closing_paren.setVisible(filter=='' or 'nl_before_if_closing_paren'.find(filter)!=-1)
        self.option_nl_before_if_closing_paren.setVisible(filter=='' or 'nl_before_if_closing_paren'.find(filter)!=-1)
        self.label_nl_brace_finally.setVisible(filter=='' or 'nl_brace_finally'.find(filter)!=-1)
        self.option_nl_brace_finally.setVisible(filter=='' or 'nl_brace_finally'.find(filter)!=-1)
        self.label_nl_finally_brace.setVisible(filter=='' or 'nl_finally_brace'.find(filter)!=-1)
        self.option_nl_finally_brace.setVisible(filter=='' or 'nl_finally_brace'.find(filter)!=-1)
        self.label_nl_try_brace.setVisible(filter=='' or 'nl_try_brace'.find(filter)!=-1)
        self.option_nl_try_brace.setVisible(filter=='' or 'nl_try_brace'.find(filter)!=-1)
        self.label_nl_getset_brace.setVisible(filter=='' or 'nl_getset_brace'.find(filter)!=-1)
        self.option_nl_getset_brace.setVisible(filter=='' or 'nl_getset_brace'.find(filter)!=-1)
        self.label_nl_for_brace.setVisible(filter=='' or 'nl_for_brace'.find(filter)!=-1)
        self.option_nl_for_brace.setVisible(filter=='' or 'nl_for_brace'.find(filter)!=-1)
        self.label_nl_catch_brace.setVisible(filter=='' or 'nl_catch_brace'.find(filter)!=-1)
        self.option_nl_catch_brace.setVisible(filter=='' or 'nl_catch_brace'.find(filter)!=-1)
        self.label_nl_oc_catch_brace.setVisible(filter=='' or 'nl_oc_catch_brace'.find(filter)!=-1)
        self.option_nl_oc_catch_brace.setVisible(filter=='' or 'nl_oc_catch_brace'.find(filter)!=-1)
        self.label_nl_brace_catch.setVisible(filter=='' or 'nl_brace_catch'.find(filter)!=-1)
        self.option_nl_brace_catch.setVisible(filter=='' or 'nl_brace_catch'.find(filter)!=-1)
        self.label_nl_oc_brace_catch.setVisible(filter=='' or 'nl_oc_brace_catch'.find(filter)!=-1)
        self.option_nl_oc_brace_catch.setVisible(filter=='' or 'nl_oc_brace_catch'.find(filter)!=-1)
        self.label_nl_brace_square.setVisible(filter=='' or 'nl_brace_square'.find(filter)!=-1)
        self.option_nl_brace_square.setVisible(filter=='' or 'nl_brace_square'.find(filter)!=-1)
        self.label_nl_brace_fparen.setVisible(filter=='' or 'nl_brace_fparen'.find(filter)!=-1)
        self.option_nl_brace_fparen.setVisible(filter=='' or 'nl_brace_fparen'.find(filter)!=-1)
        self.label_nl_while_brace.setVisible(filter=='' or 'nl_while_brace'.find(filter)!=-1)
        self.option_nl_while_brace.setVisible(filter=='' or 'nl_while_brace'.find(filter)!=-1)
        self.label_nl_scope_brace.setVisible(filter=='' or 'nl_scope_brace'.find(filter)!=-1)
        self.option_nl_scope_brace.setVisible(filter=='' or 'nl_scope_brace'.find(filter)!=-1)
        self.label_nl_unittest_brace.setVisible(filter=='' or 'nl_unittest_brace'.find(filter)!=-1)
        self.option_nl_unittest_brace.setVisible(filter=='' or 'nl_unittest_brace'.find(filter)!=-1)
        self.label_nl_version_brace.setVisible(filter=='' or 'nl_version_brace'.find(filter)!=-1)
        self.option_nl_version_brace.setVisible(filter=='' or 'nl_version_brace'.find(filter)!=-1)
        self.label_nl_using_brace.setVisible(filter=='' or 'nl_using_brace'.find(filter)!=-1)
        self.option_nl_using_brace.setVisible(filter=='' or 'nl_using_brace'.find(filter)!=-1)
        self.label_nl_brace_brace.setVisible(filter=='' or 'nl_brace_brace'.find(filter)!=-1)
        self.option_nl_brace_brace.setVisible(filter=='' or 'nl_brace_brace'.find(filter)!=-1)
        self.label_nl_do_brace.setVisible(filter=='' or 'nl_do_brace'.find(filter)!=-1)
        self.option_nl_do_brace.setVisible(filter=='' or 'nl_do_brace'.find(filter)!=-1)
        self.label_nl_brace_while.setVisible(filter=='' or 'nl_brace_while'.find(filter)!=-1)
        self.option_nl_brace_while.setVisible(filter=='' or 'nl_brace_while'.find(filter)!=-1)
        self.label_nl_switch_brace.setVisible(filter=='' or 'nl_switch_brace'.find(filter)!=-1)
        self.option_nl_switch_brace.setVisible(filter=='' or 'nl_switch_brace'.find(filter)!=-1)
        self.label_nl_synchronized_brace.setVisible(filter=='' or 'nl_synchronized_brace'.find(filter)!=-1)
        self.option_nl_synchronized_brace.setVisible(filter=='' or 'nl_synchronized_brace'.find(filter)!=-1)
        self.label_nl_multi_line_cond.setVisible(filter=='' or 'nl_multi_line_cond'.find(filter)!=-1)
        self.option_nl_multi_line_cond.setVisible(filter=='' or 'nl_multi_line_cond'.find(filter)!=-1)
        self.label_nl_multi_line_sparen_open.setVisible(filter=='' or 'nl_multi_line_sparen_open'.find(filter)!=-1)
        self.option_nl_multi_line_sparen_open.setVisible(filter=='' or 'nl_multi_line_sparen_open'.find(filter)!=-1)
        self.label_nl_multi_line_sparen_close.setVisible(filter=='' or 'nl_multi_line_sparen_close'.find(filter)!=-1)
        self.option_nl_multi_line_sparen_close.setVisible(filter=='' or 'nl_multi_line_sparen_close'.find(filter)!=-1)
        self.label_nl_multi_line_define.setVisible(filter=='' or 'nl_multi_line_define'.find(filter)!=-1)
        self.option_nl_multi_line_define.setVisible(filter=='' or 'nl_multi_line_define'.find(filter)!=-1)
        self.label_nl_before_case.setVisible(filter=='' or 'nl_before_case'.find(filter)!=-1)
        self.option_nl_before_case.setVisible(filter=='' or 'nl_before_case'.find(filter)!=-1)
        self.label_nl_after_case.setVisible(filter=='' or 'nl_after_case'.find(filter)!=-1)
        self.option_nl_after_case.setVisible(filter=='' or 'nl_after_case'.find(filter)!=-1)
        self.label_nl_case_colon_brace.setVisible(filter=='' or 'nl_case_colon_brace'.find(filter)!=-1)
        self.option_nl_case_colon_brace.setVisible(filter=='' or 'nl_case_colon_brace'.find(filter)!=-1)
        self.label_nl_before_throw.setVisible(filter=='' or 'nl_before_throw'.find(filter)!=-1)
        self.option_nl_before_throw.setVisible(filter=='' or 'nl_before_throw'.find(filter)!=-1)
        self.label_nl_namespace_brace.setVisible(filter=='' or 'nl_namespace_brace'.find(filter)!=-1)
        self.option_nl_namespace_brace.setVisible(filter=='' or 'nl_namespace_brace'.find(filter)!=-1)
        self.label_nl_template_class.setVisible(filter=='' or 'nl_template_class'.find(filter)!=-1)
        self.option_nl_template_class.setVisible(filter=='' or 'nl_template_class'.find(filter)!=-1)
        self.label_nl_template_class_decl.setVisible(filter=='' or 'nl_template_class_decl'.find(filter)!=-1)
        self.option_nl_template_class_decl.setVisible(filter=='' or 'nl_template_class_decl'.find(filter)!=-1)
        self.label_nl_template_class_decl_special.setVisible(filter=='' or 'nl_template_class_decl_special'.find(filter)!=-1)
        self.option_nl_template_class_decl_special.setVisible(filter=='' or 'nl_template_class_decl_special'.find(filter)!=-1)
        self.label_nl_template_class_def.setVisible(filter=='' or 'nl_template_class_def'.find(filter)!=-1)
        self.option_nl_template_class_def.setVisible(filter=='' or 'nl_template_class_def'.find(filter)!=-1)
        self.label_nl_template_class_def_special.setVisible(filter=='' or 'nl_template_class_def_special'.find(filter)!=-1)
        self.option_nl_template_class_def_special.setVisible(filter=='' or 'nl_template_class_def_special'.find(filter)!=-1)
        self.label_nl_template_func.setVisible(filter=='' or 'nl_template_func'.find(filter)!=-1)
        self.option_nl_template_func.setVisible(filter=='' or 'nl_template_func'.find(filter)!=-1)
        self.label_nl_template_func_decl.setVisible(filter=='' or 'nl_template_func_decl'.find(filter)!=-1)
        self.option_nl_template_func_decl.setVisible(filter=='' or 'nl_template_func_decl'.find(filter)!=-1)
        self.label_nl_template_func_decl_special.setVisible(filter=='' or 'nl_template_func_decl_special'.find(filter)!=-1)
        self.option_nl_template_func_decl_special.setVisible(filter=='' or 'nl_template_func_decl_special'.find(filter)!=-1)
        self.label_nl_template_func_def.setVisible(filter=='' or 'nl_template_func_def'.find(filter)!=-1)
        self.option_nl_template_func_def.setVisible(filter=='' or 'nl_template_func_def'.find(filter)!=-1)
        self.label_nl_template_func_def_special.setVisible(filter=='' or 'nl_template_func_def_special'.find(filter)!=-1)
        self.option_nl_template_func_def_special.setVisible(filter=='' or 'nl_template_func_def_special'.find(filter)!=-1)
        self.label_nl_template_var.setVisible(filter=='' or 'nl_template_var'.find(filter)!=-1)
        self.option_nl_template_var.setVisible(filter=='' or 'nl_template_var'.find(filter)!=-1)
        self.label_nl_template_using.setVisible(filter=='' or 'nl_template_using'.find(filter)!=-1)
        self.option_nl_template_using.setVisible(filter=='' or 'nl_template_using'.find(filter)!=-1)
        self.label_nl_class_brace.setVisible(filter=='' or 'nl_class_brace'.find(filter)!=-1)
        self.option_nl_class_brace.setVisible(filter=='' or 'nl_class_brace'.find(filter)!=-1)
        self.label_nl_class_init_args.setVisible(filter=='' or 'nl_class_init_args'.find(filter)!=-1)
        self.option_nl_class_init_args.setVisible(filter=='' or 'nl_class_init_args'.find(filter)!=-1)
        self.label_nl_constr_init_args.setVisible(filter=='' or 'nl_constr_init_args'.find(filter)!=-1)
        self.option_nl_constr_init_args.setVisible(filter=='' or 'nl_constr_init_args'.find(filter)!=-1)
        self.label_nl_enum_own_lines.setVisible(filter=='' or 'nl_enum_own_lines'.find(filter)!=-1)
        self.option_nl_enum_own_lines.setVisible(filter=='' or 'nl_enum_own_lines'.find(filter)!=-1)
        self.label_nl_func_type_name.setVisible(filter=='' or 'nl_func_type_name'.find(filter)!=-1)
        self.option_nl_func_type_name.setVisible(filter=='' or 'nl_func_type_name'.find(filter)!=-1)
        self.label_nl_func_type_name_class.setVisible(filter=='' or 'nl_func_type_name_class'.find(filter)!=-1)
        self.option_nl_func_type_name_class.setVisible(filter=='' or 'nl_func_type_name_class'.find(filter)!=-1)
        self.label_nl_func_class_scope.setVisible(filter=='' or 'nl_func_class_scope'.find(filter)!=-1)
        self.option_nl_func_class_scope.setVisible(filter=='' or 'nl_func_class_scope'.find(filter)!=-1)
        self.label_nl_func_scope_name.setVisible(filter=='' or 'nl_func_scope_name'.find(filter)!=-1)
        self.option_nl_func_scope_name.setVisible(filter=='' or 'nl_func_scope_name'.find(filter)!=-1)
        self.label_nl_func_proto_type_name.setVisible(filter=='' or 'nl_func_proto_type_name'.find(filter)!=-1)
        self.option_nl_func_proto_type_name.setVisible(filter=='' or 'nl_func_proto_type_name'.find(filter)!=-1)
        self.label_nl_func_paren.setVisible(filter=='' or 'nl_func_paren'.find(filter)!=-1)
        self.option_nl_func_paren.setVisible(filter=='' or 'nl_func_paren'.find(filter)!=-1)
        self.label_nl_func_paren_empty.setVisible(filter=='' or 'nl_func_paren_empty'.find(filter)!=-1)
        self.option_nl_func_paren_empty.setVisible(filter=='' or 'nl_func_paren_empty'.find(filter)!=-1)
        self.label_nl_func_def_paren.setVisible(filter=='' or 'nl_func_def_paren'.find(filter)!=-1)
        self.option_nl_func_def_paren.setVisible(filter=='' or 'nl_func_def_paren'.find(filter)!=-1)
        self.label_nl_func_def_paren_empty.setVisible(filter=='' or 'nl_func_def_paren_empty'.find(filter)!=-1)
        self.option_nl_func_def_paren_empty.setVisible(filter=='' or 'nl_func_def_paren_empty'.find(filter)!=-1)
        self.label_nl_func_call_paren.setVisible(filter=='' or 'nl_func_call_paren'.find(filter)!=-1)
        self.option_nl_func_call_paren.setVisible(filter=='' or 'nl_func_call_paren'.find(filter)!=-1)
        self.label_nl_func_call_paren_empty.setVisible(filter=='' or 'nl_func_call_paren_empty'.find(filter)!=-1)
        self.option_nl_func_call_paren_empty.setVisible(filter=='' or 'nl_func_call_paren_empty'.find(filter)!=-1)
        self.label_nl_func_decl_start.setVisible(filter=='' or 'nl_func_decl_start'.find(filter)!=-1)
        self.option_nl_func_decl_start.setVisible(filter=='' or 'nl_func_decl_start'.find(filter)!=-1)
        self.label_nl_func_def_start.setVisible(filter=='' or 'nl_func_def_start'.find(filter)!=-1)
        self.option_nl_func_def_start.setVisible(filter=='' or 'nl_func_def_start'.find(filter)!=-1)
        self.label_nl_func_decl_start_single.setVisible(filter=='' or 'nl_func_decl_start_single'.find(filter)!=-1)
        self.option_nl_func_decl_start_single.setVisible(filter=='' or 'nl_func_decl_start_single'.find(filter)!=-1)
        self.label_nl_func_def_start_single.setVisible(filter=='' or 'nl_func_def_start_single'.find(filter)!=-1)
        self.option_nl_func_def_start_single.setVisible(filter=='' or 'nl_func_def_start_single'.find(filter)!=-1)
        self.label_nl_func_decl_start_multi_line.setVisible(filter=='' or 'nl_func_decl_start_multi_line'.find(filter)!=-1)
        self.option_nl_func_decl_start_multi_line.setVisible(filter=='' or 'nl_func_decl_start_multi_line'.find(filter)!=-1)
        self.label_nl_func_def_start_multi_line.setVisible(filter=='' or 'nl_func_def_start_multi_line'.find(filter)!=-1)
        self.option_nl_func_def_start_multi_line.setVisible(filter=='' or 'nl_func_def_start_multi_line'.find(filter)!=-1)
        self.label_nl_func_decl_args.setVisible(filter=='' or 'nl_func_decl_args'.find(filter)!=-1)
        self.option_nl_func_decl_args.setVisible(filter=='' or 'nl_func_decl_args'.find(filter)!=-1)
        self.label_nl_func_def_args.setVisible(filter=='' or 'nl_func_def_args'.find(filter)!=-1)
        self.option_nl_func_def_args.setVisible(filter=='' or 'nl_func_def_args'.find(filter)!=-1)
        self.label_nl_func_call_args.setVisible(filter=='' or 'nl_func_call_args'.find(filter)!=-1)
        self.option_nl_func_call_args.setVisible(filter=='' or 'nl_func_call_args'.find(filter)!=-1)
        self.label_nl_func_decl_args_multi_line.setVisible(filter=='' or 'nl_func_decl_args_multi_line'.find(filter)!=-1)
        self.option_nl_func_decl_args_multi_line.setVisible(filter=='' or 'nl_func_decl_args_multi_line'.find(filter)!=-1)
        self.label_nl_func_def_args_multi_line.setVisible(filter=='' or 'nl_func_def_args_multi_line'.find(filter)!=-1)
        self.option_nl_func_def_args_multi_line.setVisible(filter=='' or 'nl_func_def_args_multi_line'.find(filter)!=-1)
        self.label_nl_func_decl_end.setVisible(filter=='' or 'nl_func_decl_end'.find(filter)!=-1)
        self.option_nl_func_decl_end.setVisible(filter=='' or 'nl_func_decl_end'.find(filter)!=-1)
        self.label_nl_func_def_end.setVisible(filter=='' or 'nl_func_def_end'.find(filter)!=-1)
        self.option_nl_func_def_end.setVisible(filter=='' or 'nl_func_def_end'.find(filter)!=-1)
        self.label_nl_func_decl_end_single.setVisible(filter=='' or 'nl_func_decl_end_single'.find(filter)!=-1)
        self.option_nl_func_decl_end_single.setVisible(filter=='' or 'nl_func_decl_end_single'.find(filter)!=-1)
        self.label_nl_func_def_end_single.setVisible(filter=='' or 'nl_func_def_end_single'.find(filter)!=-1)
        self.option_nl_func_def_end_single.setVisible(filter=='' or 'nl_func_def_end_single'.find(filter)!=-1)
        self.label_nl_func_decl_end_multi_line.setVisible(filter=='' or 'nl_func_decl_end_multi_line'.find(filter)!=-1)
        self.option_nl_func_decl_end_multi_line.setVisible(filter=='' or 'nl_func_decl_end_multi_line'.find(filter)!=-1)
        self.label_nl_func_def_end_multi_line.setVisible(filter=='' or 'nl_func_def_end_multi_line'.find(filter)!=-1)
        self.option_nl_func_def_end_multi_line.setVisible(filter=='' or 'nl_func_def_end_multi_line'.find(filter)!=-1)
        self.label_nl_func_decl_empty.setVisible(filter=='' or 'nl_func_decl_empty'.find(filter)!=-1)
        self.option_nl_func_decl_empty.setVisible(filter=='' or 'nl_func_decl_empty'.find(filter)!=-1)
        self.label_nl_func_def_empty.setVisible(filter=='' or 'nl_func_def_empty'.find(filter)!=-1)
        self.option_nl_func_def_empty.setVisible(filter=='' or 'nl_func_def_empty'.find(filter)!=-1)
        self.label_nl_func_call_empty.setVisible(filter=='' or 'nl_func_call_empty'.find(filter)!=-1)
        self.option_nl_func_call_empty.setVisible(filter=='' or 'nl_func_call_empty'.find(filter)!=-1)
        self.label_nl_func_call_start.setVisible(filter=='' or 'nl_func_call_start'.find(filter)!=-1)
        self.option_nl_func_call_start.setVisible(filter=='' or 'nl_func_call_start'.find(filter)!=-1)
        self.label_nl_func_call_end.setVisible(filter=='' or 'nl_func_call_end'.find(filter)!=-1)
        self.option_nl_func_call_end.setVisible(filter=='' or 'nl_func_call_end'.find(filter)!=-1)
        self.label_nl_func_call_start_multi_line.setVisible(filter=='' or 'nl_func_call_start_multi_line'.find(filter)!=-1)
        self.option_nl_func_call_start_multi_line.setVisible(filter=='' or 'nl_func_call_start_multi_line'.find(filter)!=-1)
        self.label_nl_func_call_args_multi_line.setVisible(filter=='' or 'nl_func_call_args_multi_line'.find(filter)!=-1)
        self.option_nl_func_call_args_multi_line.setVisible(filter=='' or 'nl_func_call_args_multi_line'.find(filter)!=-1)
        self.label_nl_func_call_end_multi_line.setVisible(filter=='' or 'nl_func_call_end_multi_line'.find(filter)!=-1)
        self.option_nl_func_call_end_multi_line.setVisible(filter=='' or 'nl_func_call_end_multi_line'.find(filter)!=-1)
        self.label_nl_func_call_args_multi_line_ignore_closures.setVisible(filter=='' or 'nl_func_call_args_multi_line_ignore_closures'.find(filter)!=-1)
        self.option_nl_func_call_args_multi_line_ignore_closures.setVisible(filter=='' or 'nl_func_call_args_multi_line_ignore_closures'.find(filter)!=-1)
        self.label_nl_template_start.setVisible(filter=='' or 'nl_template_start'.find(filter)!=-1)
        self.option_nl_template_start.setVisible(filter=='' or 'nl_template_start'.find(filter)!=-1)
        self.label_nl_template_args.setVisible(filter=='' or 'nl_template_args'.find(filter)!=-1)
        self.option_nl_template_args.setVisible(filter=='' or 'nl_template_args'.find(filter)!=-1)
        self.label_nl_template_end.setVisible(filter=='' or 'nl_template_end'.find(filter)!=-1)
        self.option_nl_template_end.setVisible(filter=='' or 'nl_template_end'.find(filter)!=-1)
        self.label_nl_oc_msg_args.setVisible(filter=='' or 'nl_oc_msg_args'.find(filter)!=-1)
        self.option_nl_oc_msg_args.setVisible(filter=='' or 'nl_oc_msg_args'.find(filter)!=-1)
        self.label_nl_oc_msg_args_min_params.setVisible(filter=='' or 'nl_oc_msg_args_min_params'.find(filter)!=-1)
        self.option_nl_oc_msg_args_min_params.setVisible(filter=='' or 'nl_oc_msg_args_min_params'.find(filter)!=-1)
        self.label_nl_oc_msg_args_max_code_width.setVisible(filter=='' or 'nl_oc_msg_args_max_code_width'.find(filter)!=-1)
        self.option_nl_oc_msg_args_max_code_width.setVisible(filter=='' or 'nl_oc_msg_args_max_code_width'.find(filter)!=-1)
        self.label_nl_oc_msg_args_finish_multi_line.setVisible(filter=='' or 'nl_oc_msg_args_finish_multi_line'.find(filter)!=-1)
        self.option_nl_oc_msg_args_finish_multi_line.setVisible(filter=='' or 'nl_oc_msg_args_finish_multi_line'.find(filter)!=-1)
        self.label_nl_fdef_brace.setVisible(filter=='' or 'nl_fdef_brace'.find(filter)!=-1)
        self.option_nl_fdef_brace.setVisible(filter=='' or 'nl_fdef_brace'.find(filter)!=-1)
        self.label_nl_fdef_brace_cond.setVisible(filter=='' or 'nl_fdef_brace_cond'.find(filter)!=-1)
        self.option_nl_fdef_brace_cond.setVisible(filter=='' or 'nl_fdef_brace_cond'.find(filter)!=-1)
        self.label_nl_cpp_ldef_brace.setVisible(filter=='' or 'nl_cpp_ldef_brace'.find(filter)!=-1)
        self.option_nl_cpp_ldef_brace.setVisible(filter=='' or 'nl_cpp_ldef_brace'.find(filter)!=-1)
        self.label_nl_return_expr.setVisible(filter=='' or 'nl_return_expr'.find(filter)!=-1)
        self.option_nl_return_expr.setVisible(filter=='' or 'nl_return_expr'.find(filter)!=-1)
        self.label_nl_throw_expr.setVisible(filter=='' or 'nl_throw_expr'.find(filter)!=-1)
        self.option_nl_throw_expr.setVisible(filter=='' or 'nl_throw_expr'.find(filter)!=-1)
        self.label_nl_after_semicolon.setVisible(filter=='' or 'nl_after_semicolon'.find(filter)!=-1)
        self.option_nl_after_semicolon.setVisible(filter=='' or 'nl_after_semicolon'.find(filter)!=-1)
        self.label_nl_paren_dbrace_open.setVisible(filter=='' or 'nl_paren_dbrace_open'.find(filter)!=-1)
        self.option_nl_paren_dbrace_open.setVisible(filter=='' or 'nl_paren_dbrace_open'.find(filter)!=-1)
        self.label_nl_type_brace_init_lst.setVisible(filter=='' or 'nl_type_brace_init_lst'.find(filter)!=-1)
        self.option_nl_type_brace_init_lst.setVisible(filter=='' or 'nl_type_brace_init_lst'.find(filter)!=-1)
        self.label_nl_type_brace_init_lst_open.setVisible(filter=='' or 'nl_type_brace_init_lst_open'.find(filter)!=-1)
        self.option_nl_type_brace_init_lst_open.setVisible(filter=='' or 'nl_type_brace_init_lst_open'.find(filter)!=-1)
        self.label_nl_type_brace_init_lst_close.setVisible(filter=='' or 'nl_type_brace_init_lst_close'.find(filter)!=-1)
        self.option_nl_type_brace_init_lst_close.setVisible(filter=='' or 'nl_type_brace_init_lst_close'.find(filter)!=-1)
        self.label_nl_before_brace_open.setVisible(filter=='' or 'nl_before_brace_open'.find(filter)!=-1)
        self.option_nl_before_brace_open.setVisible(filter=='' or 'nl_before_brace_open'.find(filter)!=-1)
        self.label_nl_after_brace_open.setVisible(filter=='' or 'nl_after_brace_open'.find(filter)!=-1)
        self.option_nl_after_brace_open.setVisible(filter=='' or 'nl_after_brace_open'.find(filter)!=-1)
        self.label_nl_after_brace_open_cmt.setVisible(filter=='' or 'nl_after_brace_open_cmt'.find(filter)!=-1)
        self.option_nl_after_brace_open_cmt.setVisible(filter=='' or 'nl_after_brace_open_cmt'.find(filter)!=-1)
        self.label_nl_after_vbrace_open.setVisible(filter=='' or 'nl_after_vbrace_open'.find(filter)!=-1)
        self.option_nl_after_vbrace_open.setVisible(filter=='' or 'nl_after_vbrace_open'.find(filter)!=-1)
        self.label_nl_after_vbrace_open_empty.setVisible(filter=='' or 'nl_after_vbrace_open_empty'.find(filter)!=-1)
        self.option_nl_after_vbrace_open_empty.setVisible(filter=='' or 'nl_after_vbrace_open_empty'.find(filter)!=-1)
        self.label_nl_after_brace_close.setVisible(filter=='' or 'nl_after_brace_close'.find(filter)!=-1)
        self.option_nl_after_brace_close.setVisible(filter=='' or 'nl_after_brace_close'.find(filter)!=-1)
        self.label_nl_after_vbrace_close.setVisible(filter=='' or 'nl_after_vbrace_close'.find(filter)!=-1)
        self.option_nl_after_vbrace_close.setVisible(filter=='' or 'nl_after_vbrace_close'.find(filter)!=-1)
        self.label_nl_brace_struct_var.setVisible(filter=='' or 'nl_brace_struct_var'.find(filter)!=-1)
        self.option_nl_brace_struct_var.setVisible(filter=='' or 'nl_brace_struct_var'.find(filter)!=-1)
        self.label_nl_define_macro.setVisible(filter=='' or 'nl_define_macro'.find(filter)!=-1)
        self.option_nl_define_macro.setVisible(filter=='' or 'nl_define_macro'.find(filter)!=-1)
        self.label_nl_squeeze_paren_close.setVisible(filter=='' or 'nl_squeeze_paren_close'.find(filter)!=-1)
        self.option_nl_squeeze_paren_close.setVisible(filter=='' or 'nl_squeeze_paren_close'.find(filter)!=-1)
        self.label_nl_squeeze_ifdef.setVisible(filter=='' or 'nl_squeeze_ifdef'.find(filter)!=-1)
        self.option_nl_squeeze_ifdef.setVisible(filter=='' or 'nl_squeeze_ifdef'.find(filter)!=-1)
        self.label_nl_squeeze_ifdef_top_level.setVisible(filter=='' or 'nl_squeeze_ifdef_top_level'.find(filter)!=-1)
        self.option_nl_squeeze_ifdef_top_level.setVisible(filter=='' or 'nl_squeeze_ifdef_top_level'.find(filter)!=-1)
        self.label_nl_before_if.setVisible(filter=='' or 'nl_before_if'.find(filter)!=-1)
        self.option_nl_before_if.setVisible(filter=='' or 'nl_before_if'.find(filter)!=-1)
        self.label_nl_after_if.setVisible(filter=='' or 'nl_after_if'.find(filter)!=-1)
        self.option_nl_after_if.setVisible(filter=='' or 'nl_after_if'.find(filter)!=-1)
        self.label_nl_before_for.setVisible(filter=='' or 'nl_before_for'.find(filter)!=-1)
        self.option_nl_before_for.setVisible(filter=='' or 'nl_before_for'.find(filter)!=-1)
        self.label_nl_after_for.setVisible(filter=='' or 'nl_after_for'.find(filter)!=-1)
        self.option_nl_after_for.setVisible(filter=='' or 'nl_after_for'.find(filter)!=-1)
        self.label_nl_before_while.setVisible(filter=='' or 'nl_before_while'.find(filter)!=-1)
        self.option_nl_before_while.setVisible(filter=='' or 'nl_before_while'.find(filter)!=-1)
        self.label_nl_after_while.setVisible(filter=='' or 'nl_after_while'.find(filter)!=-1)
        self.option_nl_after_while.setVisible(filter=='' or 'nl_after_while'.find(filter)!=-1)
        self.label_nl_before_switch.setVisible(filter=='' or 'nl_before_switch'.find(filter)!=-1)
        self.option_nl_before_switch.setVisible(filter=='' or 'nl_before_switch'.find(filter)!=-1)
        self.label_nl_after_switch.setVisible(filter=='' or 'nl_after_switch'.find(filter)!=-1)
        self.option_nl_after_switch.setVisible(filter=='' or 'nl_after_switch'.find(filter)!=-1)
        self.label_nl_before_synchronized.setVisible(filter=='' or 'nl_before_synchronized'.find(filter)!=-1)
        self.option_nl_before_synchronized.setVisible(filter=='' or 'nl_before_synchronized'.find(filter)!=-1)
        self.label_nl_after_synchronized.setVisible(filter=='' or 'nl_after_synchronized'.find(filter)!=-1)
        self.option_nl_after_synchronized.setVisible(filter=='' or 'nl_after_synchronized'.find(filter)!=-1)
        self.label_nl_before_do.setVisible(filter=='' or 'nl_before_do'.find(filter)!=-1)
        self.option_nl_before_do.setVisible(filter=='' or 'nl_before_do'.find(filter)!=-1)
        self.label_nl_after_do.setVisible(filter=='' or 'nl_after_do'.find(filter)!=-1)
        self.option_nl_after_do.setVisible(filter=='' or 'nl_after_do'.find(filter)!=-1)
        self.label_nl_before_ignore_after_case.setVisible(filter=='' or 'nl_before_ignore_after_case'.find(filter)!=-1)
        self.option_nl_before_ignore_after_case.setVisible(filter=='' or 'nl_before_ignore_after_case'.find(filter)!=-1)
        self.label_nl_before_return.setVisible(filter=='' or 'nl_before_return'.find(filter)!=-1)
        self.option_nl_before_return.setVisible(filter=='' or 'nl_before_return'.find(filter)!=-1)
        self.label_nl_after_return.setVisible(filter=='' or 'nl_after_return'.find(filter)!=-1)
        self.option_nl_after_return.setVisible(filter=='' or 'nl_after_return'.find(filter)!=-1)
        self.label_nl_before_member.setVisible(filter=='' or 'nl_before_member'.find(filter)!=-1)
        self.option_nl_before_member.setVisible(filter=='' or 'nl_before_member'.find(filter)!=-1)
        self.label_nl_after_member.setVisible(filter=='' or 'nl_after_member'.find(filter)!=-1)
        self.option_nl_after_member.setVisible(filter=='' or 'nl_after_member'.find(filter)!=-1)
        self.label_nl_ds_struct_enum_cmt.setVisible(filter=='' or 'nl_ds_struct_enum_cmt'.find(filter)!=-1)
        self.option_nl_ds_struct_enum_cmt.setVisible(filter=='' or 'nl_ds_struct_enum_cmt'.find(filter)!=-1)
        self.label_nl_ds_struct_enum_close_brace.setVisible(filter=='' or 'nl_ds_struct_enum_close_brace'.find(filter)!=-1)
        self.option_nl_ds_struct_enum_close_brace.setVisible(filter=='' or 'nl_ds_struct_enum_close_brace'.find(filter)!=-1)
        self.label_nl_class_colon.setVisible(filter=='' or 'nl_class_colon'.find(filter)!=-1)
        self.option_nl_class_colon.setVisible(filter=='' or 'nl_class_colon'.find(filter)!=-1)
        self.label_nl_constr_colon.setVisible(filter=='' or 'nl_constr_colon'.find(filter)!=-1)
        self.option_nl_constr_colon.setVisible(filter=='' or 'nl_constr_colon'.find(filter)!=-1)
        self.label_nl_namespace_two_to_one_liner.setVisible(filter=='' or 'nl_namespace_two_to_one_liner'.find(filter)!=-1)
        self.option_nl_namespace_two_to_one_liner.setVisible(filter=='' or 'nl_namespace_two_to_one_liner'.find(filter)!=-1)
        self.label_nl_create_if_one_liner.setVisible(filter=='' or 'nl_create_if_one_liner'.find(filter)!=-1)
        self.option_nl_create_if_one_liner.setVisible(filter=='' or 'nl_create_if_one_liner'.find(filter)!=-1)
        self.label_nl_create_for_one_liner.setVisible(filter=='' or 'nl_create_for_one_liner'.find(filter)!=-1)
        self.option_nl_create_for_one_liner.setVisible(filter=='' or 'nl_create_for_one_liner'.find(filter)!=-1)
        self.label_nl_create_while_one_liner.setVisible(filter=='' or 'nl_create_while_one_liner'.find(filter)!=-1)
        self.option_nl_create_while_one_liner.setVisible(filter=='' or 'nl_create_while_one_liner'.find(filter)!=-1)
        self.label_nl_create_func_def_one_liner.setVisible(filter=='' or 'nl_create_func_def_one_liner'.find(filter)!=-1)
        self.option_nl_create_func_def_one_liner.setVisible(filter=='' or 'nl_create_func_def_one_liner'.find(filter)!=-1)
        self.label_nl_create_list_one_liner.setVisible(filter=='' or 'nl_create_list_one_liner'.find(filter)!=-1)
        self.option_nl_create_list_one_liner.setVisible(filter=='' or 'nl_create_list_one_liner'.find(filter)!=-1)
        self.label_nl_split_if_one_liner.setVisible(filter=='' or 'nl_split_if_one_liner'.find(filter)!=-1)
        self.option_nl_split_if_one_liner.setVisible(filter=='' or 'nl_split_if_one_liner'.find(filter)!=-1)
        self.label_nl_split_for_one_liner.setVisible(filter=='' or 'nl_split_for_one_liner'.find(filter)!=-1)
        self.option_nl_split_for_one_liner.setVisible(filter=='' or 'nl_split_for_one_liner'.find(filter)!=-1)
        self.label_nl_split_while_one_liner.setVisible(filter=='' or 'nl_split_while_one_liner'.find(filter)!=-1)
        self.option_nl_split_while_one_liner.setVisible(filter=='' or 'nl_split_while_one_liner'.find(filter)!=-1)
        self.label_donot_add_nl_before_cpp_comment.setVisible(filter=='' or 'donot_add_nl_before_cpp_comment'.find(filter)!=-1)
        self.option_donot_add_nl_before_cpp_comment.setVisible(filter=='' or 'donot_add_nl_before_cpp_comment'.find(filter)!=-1)
        self.label_nl_max.setVisible(filter=='' or 'nl_max'.find(filter)!=-1)
        self.option_nl_max.setVisible(filter=='' or 'nl_max'.find(filter)!=-1)
        self.label_nl_max_blank_in_func.setVisible(filter=='' or 'nl_max_blank_in_func'.find(filter)!=-1)
        self.option_nl_max_blank_in_func.setVisible(filter=='' or 'nl_max_blank_in_func'.find(filter)!=-1)
        self.label_nl_inside_empty_func.setVisible(filter=='' or 'nl_inside_empty_func'.find(filter)!=-1)
        self.option_nl_inside_empty_func.setVisible(filter=='' or 'nl_inside_empty_func'.find(filter)!=-1)
        self.label_nl_before_func_body_proto.setVisible(filter=='' or 'nl_before_func_body_proto'.find(filter)!=-1)
        self.option_nl_before_func_body_proto.setVisible(filter=='' or 'nl_before_func_body_proto'.find(filter)!=-1)
        self.label_nl_before_func_body_def.setVisible(filter=='' or 'nl_before_func_body_def'.find(filter)!=-1)
        self.option_nl_before_func_body_def.setVisible(filter=='' or 'nl_before_func_body_def'.find(filter)!=-1)
        self.label_nl_before_func_class_proto.setVisible(filter=='' or 'nl_before_func_class_proto'.find(filter)!=-1)
        self.option_nl_before_func_class_proto.setVisible(filter=='' or 'nl_before_func_class_proto'.find(filter)!=-1)
        self.label_nl_before_func_class_def.setVisible(filter=='' or 'nl_before_func_class_def'.find(filter)!=-1)
        self.option_nl_before_func_class_def.setVisible(filter=='' or 'nl_before_func_class_def'.find(filter)!=-1)
        self.label_nl_after_func_proto.setVisible(filter=='' or 'nl_after_func_proto'.find(filter)!=-1)
        self.option_nl_after_func_proto.setVisible(filter=='' or 'nl_after_func_proto'.find(filter)!=-1)
        self.label_nl_after_func_proto_group.setVisible(filter=='' or 'nl_after_func_proto_group'.find(filter)!=-1)
        self.option_nl_after_func_proto_group.setVisible(filter=='' or 'nl_after_func_proto_group'.find(filter)!=-1)
        self.label_nl_after_func_class_proto.setVisible(filter=='' or 'nl_after_func_class_proto'.find(filter)!=-1)
        self.option_nl_after_func_class_proto.setVisible(filter=='' or 'nl_after_func_class_proto'.find(filter)!=-1)
        self.label_nl_after_func_class_proto_group.setVisible(filter=='' or 'nl_after_func_class_proto_group'.find(filter)!=-1)
        self.option_nl_after_func_class_proto_group.setVisible(filter=='' or 'nl_after_func_class_proto_group'.find(filter)!=-1)
        self.label_nl_class_leave_one_liner_groups.setVisible(filter=='' or 'nl_class_leave_one_liner_groups'.find(filter)!=-1)
        self.option_nl_class_leave_one_liner_groups.setVisible(filter=='' or 'nl_class_leave_one_liner_groups'.find(filter)!=-1)
        self.label_nl_after_func_body.setVisible(filter=='' or 'nl_after_func_body'.find(filter)!=-1)
        self.option_nl_after_func_body.setVisible(filter=='' or 'nl_after_func_body'.find(filter)!=-1)
        self.label_nl_min_after_func_body.setVisible(filter=='' or 'nl_min_after_func_body'.find(filter)!=-1)
        self.option_nl_min_after_func_body.setVisible(filter=='' or 'nl_min_after_func_body'.find(filter)!=-1)
        self.label_nl_max_after_func_body.setVisible(filter=='' or 'nl_max_after_func_body'.find(filter)!=-1)
        self.option_nl_max_after_func_body.setVisible(filter=='' or 'nl_max_after_func_body'.find(filter)!=-1)
        self.label_nl_after_func_body_class.setVisible(filter=='' or 'nl_after_func_body_class'.find(filter)!=-1)
        self.option_nl_after_func_body_class.setVisible(filter=='' or 'nl_after_func_body_class'.find(filter)!=-1)
        self.label_nl_after_func_body_one_liner.setVisible(filter=='' or 'nl_after_func_body_one_liner'.find(filter)!=-1)
        self.option_nl_after_func_body_one_liner.setVisible(filter=='' or 'nl_after_func_body_one_liner'.find(filter)!=-1)
        self.label_nl_typedef_blk_start.setVisible(filter=='' or 'nl_typedef_blk_start'.find(filter)!=-1)
        self.option_nl_typedef_blk_start.setVisible(filter=='' or 'nl_typedef_blk_start'.find(filter)!=-1)
        self.label_nl_typedef_blk_end.setVisible(filter=='' or 'nl_typedef_blk_end'.find(filter)!=-1)
        self.option_nl_typedef_blk_end.setVisible(filter=='' or 'nl_typedef_blk_end'.find(filter)!=-1)
        self.label_nl_typedef_blk_in.setVisible(filter=='' or 'nl_typedef_blk_in'.find(filter)!=-1)
        self.option_nl_typedef_blk_in.setVisible(filter=='' or 'nl_typedef_blk_in'.find(filter)!=-1)
        self.label_nl_var_def_blk_end_func_top.setVisible(filter=='' or 'nl_var_def_blk_end_func_top'.find(filter)!=-1)
        self.option_nl_var_def_blk_end_func_top.setVisible(filter=='' or 'nl_var_def_blk_end_func_top'.find(filter)!=-1)
        self.label_nl_var_def_blk_start.setVisible(filter=='' or 'nl_var_def_blk_start'.find(filter)!=-1)
        self.option_nl_var_def_blk_start.setVisible(filter=='' or 'nl_var_def_blk_start'.find(filter)!=-1)
        self.label_nl_var_def_blk_end.setVisible(filter=='' or 'nl_var_def_blk_end'.find(filter)!=-1)
        self.option_nl_var_def_blk_end.setVisible(filter=='' or 'nl_var_def_blk_end'.find(filter)!=-1)
        self.label_nl_var_def_blk_in.setVisible(filter=='' or 'nl_var_def_blk_in'.find(filter)!=-1)
        self.option_nl_var_def_blk_in.setVisible(filter=='' or 'nl_var_def_blk_in'.find(filter)!=-1)
        self.label_nl_before_block_comment.setVisible(filter=='' or 'nl_before_block_comment'.find(filter)!=-1)
        self.option_nl_before_block_comment.setVisible(filter=='' or 'nl_before_block_comment'.find(filter)!=-1)
        self.label_nl_before_c_comment.setVisible(filter=='' or 'nl_before_c_comment'.find(filter)!=-1)
        self.option_nl_before_c_comment.setVisible(filter=='' or 'nl_before_c_comment'.find(filter)!=-1)
        self.label_nl_before_cpp_comment.setVisible(filter=='' or 'nl_before_cpp_comment'.find(filter)!=-1)
        self.option_nl_before_cpp_comment.setVisible(filter=='' or 'nl_before_cpp_comment'.find(filter)!=-1)
        self.label_nl_after_multiline_comment.setVisible(filter=='' or 'nl_after_multiline_comment'.find(filter)!=-1)
        self.option_nl_after_multiline_comment.setVisible(filter=='' or 'nl_after_multiline_comment'.find(filter)!=-1)
        self.label_nl_after_label_colon.setVisible(filter=='' or 'nl_after_label_colon'.find(filter)!=-1)
        self.option_nl_after_label_colon.setVisible(filter=='' or 'nl_after_label_colon'.find(filter)!=-1)
        self.label_nl_before_struct.setVisible(filter=='' or 'nl_before_struct'.find(filter)!=-1)
        self.option_nl_before_struct.setVisible(filter=='' or 'nl_before_struct'.find(filter)!=-1)
        self.label_nl_after_struct.setVisible(filter=='' or 'nl_after_struct'.find(filter)!=-1)
        self.option_nl_after_struct.setVisible(filter=='' or 'nl_after_struct'.find(filter)!=-1)
        self.label_nl_before_class.setVisible(filter=='' or 'nl_before_class'.find(filter)!=-1)
        self.option_nl_before_class.setVisible(filter=='' or 'nl_before_class'.find(filter)!=-1)
        self.label_nl_after_class.setVisible(filter=='' or 'nl_after_class'.find(filter)!=-1)
        self.option_nl_after_class.setVisible(filter=='' or 'nl_after_class'.find(filter)!=-1)
        self.label_nl_before_namespace.setVisible(filter=='' or 'nl_before_namespace'.find(filter)!=-1)
        self.option_nl_before_namespace.setVisible(filter=='' or 'nl_before_namespace'.find(filter)!=-1)
        self.label_nl_inside_namespace.setVisible(filter=='' or 'nl_inside_namespace'.find(filter)!=-1)
        self.option_nl_inside_namespace.setVisible(filter=='' or 'nl_inside_namespace'.find(filter)!=-1)
        self.label_nl_after_namespace.setVisible(filter=='' or 'nl_after_namespace'.find(filter)!=-1)
        self.option_nl_after_namespace.setVisible(filter=='' or 'nl_after_namespace'.find(filter)!=-1)
        self.label_nl_before_access_spec.setVisible(filter=='' or 'nl_before_access_spec'.find(filter)!=-1)
        self.option_nl_before_access_spec.setVisible(filter=='' or 'nl_before_access_spec'.find(filter)!=-1)
        self.label_nl_after_access_spec.setVisible(filter=='' or 'nl_after_access_spec'.find(filter)!=-1)
        self.option_nl_after_access_spec.setVisible(filter=='' or 'nl_after_access_spec'.find(filter)!=-1)
        self.label_nl_comment_func_def.setVisible(filter=='' or 'nl_comment_func_def'.find(filter)!=-1)
        self.option_nl_comment_func_def.setVisible(filter=='' or 'nl_comment_func_def'.find(filter)!=-1)
        self.label_nl_after_try_catch_finally.setVisible(filter=='' or 'nl_after_try_catch_finally'.find(filter)!=-1)
        self.option_nl_after_try_catch_finally.setVisible(filter=='' or 'nl_after_try_catch_finally'.find(filter)!=-1)
        self.label_nl_around_cs_property.setVisible(filter=='' or 'nl_around_cs_property'.find(filter)!=-1)
        self.option_nl_around_cs_property.setVisible(filter=='' or 'nl_around_cs_property'.find(filter)!=-1)
        self.label_nl_between_get_set.setVisible(filter=='' or 'nl_between_get_set'.find(filter)!=-1)
        self.option_nl_between_get_set.setVisible(filter=='' or 'nl_between_get_set'.find(filter)!=-1)
        self.label_nl_property_brace.setVisible(filter=='' or 'nl_property_brace'.find(filter)!=-1)
        self.option_nl_property_brace.setVisible(filter=='' or 'nl_property_brace'.find(filter)!=-1)
        self.label_eat_blanks_after_open_brace.setVisible(filter=='' or 'eat_blanks_after_open_brace'.find(filter)!=-1)
        self.option_eat_blanks_after_open_brace.setVisible(filter=='' or 'eat_blanks_after_open_brace'.find(filter)!=-1)
        self.label_eat_blanks_before_close_brace.setVisible(filter=='' or 'eat_blanks_before_close_brace'.find(filter)!=-1)
        self.option_eat_blanks_before_close_brace.setVisible(filter=='' or 'eat_blanks_before_close_brace'.find(filter)!=-1)
        self.label_nl_remove_extra_newlines.setVisible(filter=='' or 'nl_remove_extra_newlines'.find(filter)!=-1)
        self.option_nl_remove_extra_newlines.setVisible(filter=='' or 'nl_remove_extra_newlines'.find(filter)!=-1)
        self.label_nl_after_annotation.setVisible(filter=='' or 'nl_after_annotation'.find(filter)!=-1)
        self.option_nl_after_annotation.setVisible(filter=='' or 'nl_after_annotation'.find(filter)!=-1)
        self.label_nl_between_annotation.setVisible(filter=='' or 'nl_between_annotation'.find(filter)!=-1)
        self.option_nl_between_annotation.setVisible(filter=='' or 'nl_between_annotation'.find(filter)!=-1)
        self.label_nl_before_whole_file_ifdef.setVisible(filter=='' or 'nl_before_whole_file_ifdef'.find(filter)!=-1)
        self.option_nl_before_whole_file_ifdef.setVisible(filter=='' or 'nl_before_whole_file_ifdef'.find(filter)!=-1)
        self.label_nl_after_whole_file_ifdef.setVisible(filter=='' or 'nl_after_whole_file_ifdef'.find(filter)!=-1)
        self.option_nl_after_whole_file_ifdef.setVisible(filter=='' or 'nl_after_whole_file_ifdef'.find(filter)!=-1)
        self.label_nl_before_whole_file_endif.setVisible(filter=='' or 'nl_before_whole_file_endif'.find(filter)!=-1)
        self.option_nl_before_whole_file_endif.setVisible(filter=='' or 'nl_before_whole_file_endif'.find(filter)!=-1)
        self.label_nl_after_whole_file_endif.setVisible(filter=='' or 'nl_after_whole_file_endif'.find(filter)!=-1)
        self.option_nl_after_whole_file_endif.setVisible(filter=='' or 'nl_after_whole_file_endif'.find(filter)!=-1)
        self.label_pos_arith.setVisible(filter=='' or 'pos_arith'.find(filter)!=-1)
        self.option_pos_arith.setVisible(filter=='' or 'pos_arith'.find(filter)!=-1)
        self.label_pos_assign.setVisible(filter=='' or 'pos_assign'.find(filter)!=-1)
        self.option_pos_assign.setVisible(filter=='' or 'pos_assign'.find(filter)!=-1)
        self.label_pos_bool.setVisible(filter=='' or 'pos_bool'.find(filter)!=-1)
        self.option_pos_bool.setVisible(filter=='' or 'pos_bool'.find(filter)!=-1)
        self.label_pos_compare.setVisible(filter=='' or 'pos_compare'.find(filter)!=-1)
        self.option_pos_compare.setVisible(filter=='' or 'pos_compare'.find(filter)!=-1)
        self.label_pos_conditional.setVisible(filter=='' or 'pos_conditional'.find(filter)!=-1)
        self.option_pos_conditional.setVisible(filter=='' or 'pos_conditional'.find(filter)!=-1)
        self.label_pos_comma.setVisible(filter=='' or 'pos_comma'.find(filter)!=-1)
        self.option_pos_comma.setVisible(filter=='' or 'pos_comma'.find(filter)!=-1)
        self.label_pos_enum_comma.setVisible(filter=='' or 'pos_enum_comma'.find(filter)!=-1)
        self.option_pos_enum_comma.setVisible(filter=='' or 'pos_enum_comma'.find(filter)!=-1)
        self.label_pos_class_comma.setVisible(filter=='' or 'pos_class_comma'.find(filter)!=-1)
        self.option_pos_class_comma.setVisible(filter=='' or 'pos_class_comma'.find(filter)!=-1)
        self.label_pos_constr_comma.setVisible(filter=='' or 'pos_constr_comma'.find(filter)!=-1)
        self.option_pos_constr_comma.setVisible(filter=='' or 'pos_constr_comma'.find(filter)!=-1)
        self.label_pos_class_colon.setVisible(filter=='' or 'pos_class_colon'.find(filter)!=-1)
        self.option_pos_class_colon.setVisible(filter=='' or 'pos_class_colon'.find(filter)!=-1)
        self.label_pos_constr_colon.setVisible(filter=='' or 'pos_constr_colon'.find(filter)!=-1)
        self.option_pos_constr_colon.setVisible(filter=='' or 'pos_constr_colon'.find(filter)!=-1)
        self.label_pos_shift.setVisible(filter=='' or 'pos_shift'.find(filter)!=-1)
        self.option_pos_shift.setVisible(filter=='' or 'pos_shift'.find(filter)!=-1)
        self.label_code_width.setVisible(filter=='' or 'code_width'.find(filter)!=-1)
        self.option_code_width.setVisible(filter=='' or 'code_width'.find(filter)!=-1)
        self.label_ls_for_split_full.setVisible(filter=='' or 'ls_for_split_full'.find(filter)!=-1)
        self.option_ls_for_split_full.setVisible(filter=='' or 'ls_for_split_full'.find(filter)!=-1)
        self.label_ls_func_split_full.setVisible(filter=='' or 'ls_func_split_full'.find(filter)!=-1)
        self.option_ls_func_split_full.setVisible(filter=='' or 'ls_func_split_full'.find(filter)!=-1)
        self.label_ls_code_width.setVisible(filter=='' or 'ls_code_width'.find(filter)!=-1)
        self.option_ls_code_width.setVisible(filter=='' or 'ls_code_width'.find(filter)!=-1)
        self.label_align_keep_tabs.setVisible(filter=='' or 'align_keep_tabs'.find(filter)!=-1)
        self.option_align_keep_tabs.setVisible(filter=='' or 'align_keep_tabs'.find(filter)!=-1)
        self.label_align_with_tabs.setVisible(filter=='' or 'align_with_tabs'.find(filter)!=-1)
        self.option_align_with_tabs.setVisible(filter=='' or 'align_with_tabs'.find(filter)!=-1)
        self.label_align_on_tabstop.setVisible(filter=='' or 'align_on_tabstop'.find(filter)!=-1)
        self.option_align_on_tabstop.setVisible(filter=='' or 'align_on_tabstop'.find(filter)!=-1)
        self.label_align_number_right.setVisible(filter=='' or 'align_number_right'.find(filter)!=-1)
        self.option_align_number_right.setVisible(filter=='' or 'align_number_right'.find(filter)!=-1)
        self.label_align_keep_extra_space.setVisible(filter=='' or 'align_keep_extra_space'.find(filter)!=-1)
        self.option_align_keep_extra_space.setVisible(filter=='' or 'align_keep_extra_space'.find(filter)!=-1)
        self.label_align_func_params.setVisible(filter=='' or 'align_func_params'.find(filter)!=-1)
        self.option_align_func_params.setVisible(filter=='' or 'align_func_params'.find(filter)!=-1)
        self.label_align_func_params_span.setVisible(filter=='' or 'align_func_params_span'.find(filter)!=-1)
        self.option_align_func_params_span.setVisible(filter=='' or 'align_func_params_span'.find(filter)!=-1)
        self.label_align_func_params_thresh.setVisible(filter=='' or 'align_func_params_thresh'.find(filter)!=-1)
        self.option_align_func_params_thresh.setVisible(filter=='' or 'align_func_params_thresh'.find(filter)!=-1)
        self.label_align_func_params_gap.setVisible(filter=='' or 'align_func_params_gap'.find(filter)!=-1)
        self.option_align_func_params_gap.setVisible(filter=='' or 'align_func_params_gap'.find(filter)!=-1)
        self.label_align_constr_value_span.setVisible(filter=='' or 'align_constr_value_span'.find(filter)!=-1)
        self.option_align_constr_value_span.setVisible(filter=='' or 'align_constr_value_span'.find(filter)!=-1)
        self.label_align_constr_value_thresh.setVisible(filter=='' or 'align_constr_value_thresh'.find(filter)!=-1)
        self.option_align_constr_value_thresh.setVisible(filter=='' or 'align_constr_value_thresh'.find(filter)!=-1)
        self.label_align_constr_value_gap.setVisible(filter=='' or 'align_constr_value_gap'.find(filter)!=-1)
        self.option_align_constr_value_gap.setVisible(filter=='' or 'align_constr_value_gap'.find(filter)!=-1)
        self.label_align_same_func_call_params.setVisible(filter=='' or 'align_same_func_call_params'.find(filter)!=-1)
        self.option_align_same_func_call_params.setVisible(filter=='' or 'align_same_func_call_params'.find(filter)!=-1)
        self.label_align_same_func_call_params_span.setVisible(filter=='' or 'align_same_func_call_params_span'.find(filter)!=-1)
        self.option_align_same_func_call_params_span.setVisible(filter=='' or 'align_same_func_call_params_span'.find(filter)!=-1)
        self.label_align_same_func_call_params_thresh.setVisible(filter=='' or 'align_same_func_call_params_thresh'.find(filter)!=-1)
        self.option_align_same_func_call_params_thresh.setVisible(filter=='' or 'align_same_func_call_params_thresh'.find(filter)!=-1)
        self.label_align_var_def_span.setVisible(filter=='' or 'align_var_def_span'.find(filter)!=-1)
        self.option_align_var_def_span.setVisible(filter=='' or 'align_var_def_span'.find(filter)!=-1)
        self.label_align_var_def_star_style.setVisible(filter=='' or 'align_var_def_star_style'.find(filter)!=-1)
        self.option_align_var_def_star_style.setVisible(filter=='' or 'align_var_def_star_style'.find(filter)!=-1)
        self.label_align_var_def_amp_style.setVisible(filter=='' or 'align_var_def_amp_style'.find(filter)!=-1)
        self.option_align_var_def_amp_style.setVisible(filter=='' or 'align_var_def_amp_style'.find(filter)!=-1)
        self.label_align_var_def_thresh.setVisible(filter=='' or 'align_var_def_thresh'.find(filter)!=-1)
        self.option_align_var_def_thresh.setVisible(filter=='' or 'align_var_def_thresh'.find(filter)!=-1)
        self.label_align_var_def_gap.setVisible(filter=='' or 'align_var_def_gap'.find(filter)!=-1)
        self.option_align_var_def_gap.setVisible(filter=='' or 'align_var_def_gap'.find(filter)!=-1)
        self.label_align_var_def_colon.setVisible(filter=='' or 'align_var_def_colon'.find(filter)!=-1)
        self.option_align_var_def_colon.setVisible(filter=='' or 'align_var_def_colon'.find(filter)!=-1)
        self.label_align_var_def_colon_gap.setVisible(filter=='' or 'align_var_def_colon_gap'.find(filter)!=-1)
        self.option_align_var_def_colon_gap.setVisible(filter=='' or 'align_var_def_colon_gap'.find(filter)!=-1)
        self.label_align_var_def_attribute.setVisible(filter=='' or 'align_var_def_attribute'.find(filter)!=-1)
        self.option_align_var_def_attribute.setVisible(filter=='' or 'align_var_def_attribute'.find(filter)!=-1)
        self.label_align_var_def_inline.setVisible(filter=='' or 'align_var_def_inline'.find(filter)!=-1)
        self.option_align_var_def_inline.setVisible(filter=='' or 'align_var_def_inline'.find(filter)!=-1)
        self.label_align_assign_span.setVisible(filter=='' or 'align_assign_span'.find(filter)!=-1)
        self.option_align_assign_span.setVisible(filter=='' or 'align_assign_span'.find(filter)!=-1)
        self.label_align_assign_func_proto_span.setVisible(filter=='' or 'align_assign_func_proto_span'.find(filter)!=-1)
        self.option_align_assign_func_proto_span.setVisible(filter=='' or 'align_assign_func_proto_span'.find(filter)!=-1)
        self.label_align_assign_thresh.setVisible(filter=='' or 'align_assign_thresh'.find(filter)!=-1)
        self.option_align_assign_thresh.setVisible(filter=='' or 'align_assign_thresh'.find(filter)!=-1)
        self.label_align_assign_on_multi_var_defs.setVisible(filter=='' or 'align_assign_on_multi_var_defs'.find(filter)!=-1)
        self.option_align_assign_on_multi_var_defs.setVisible(filter=='' or 'align_assign_on_multi_var_defs'.find(filter)!=-1)
        self.label_align_braced_init_list_span.setVisible(filter=='' or 'align_braced_init_list_span'.find(filter)!=-1)
        self.option_align_braced_init_list_span.setVisible(filter=='' or 'align_braced_init_list_span'.find(filter)!=-1)
        self.label_align_braced_init_list_thresh.setVisible(filter=='' or 'align_braced_init_list_thresh'.find(filter)!=-1)
        self.option_align_braced_init_list_thresh.setVisible(filter=='' or 'align_braced_init_list_thresh'.find(filter)!=-1)
        self.label_align_assign_decl_func.setVisible(filter=='' or 'align_assign_decl_func'.find(filter)!=-1)
        self.option_align_assign_decl_func.setVisible(filter=='' or 'align_assign_decl_func'.find(filter)!=-1)
        self.label_align_enum_equ_span.setVisible(filter=='' or 'align_enum_equ_span'.find(filter)!=-1)
        self.option_align_enum_equ_span.setVisible(filter=='' or 'align_enum_equ_span'.find(filter)!=-1)
        self.label_align_enum_equ_thresh.setVisible(filter=='' or 'align_enum_equ_thresh'.find(filter)!=-1)
        self.option_align_enum_equ_thresh.setVisible(filter=='' or 'align_enum_equ_thresh'.find(filter)!=-1)
        self.label_align_var_class_span.setVisible(filter=='' or 'align_var_class_span'.find(filter)!=-1)
        self.option_align_var_class_span.setVisible(filter=='' or 'align_var_class_span'.find(filter)!=-1)
        self.label_align_var_class_thresh.setVisible(filter=='' or 'align_var_class_thresh'.find(filter)!=-1)
        self.option_align_var_class_thresh.setVisible(filter=='' or 'align_var_class_thresh'.find(filter)!=-1)
        self.label_align_var_class_gap.setVisible(filter=='' or 'align_var_class_gap'.find(filter)!=-1)
        self.option_align_var_class_gap.setVisible(filter=='' or 'align_var_class_gap'.find(filter)!=-1)
        self.label_align_var_struct_span.setVisible(filter=='' or 'align_var_struct_span'.find(filter)!=-1)
        self.option_align_var_struct_span.setVisible(filter=='' or 'align_var_struct_span'.find(filter)!=-1)
        self.label_align_var_struct_thresh.setVisible(filter=='' or 'align_var_struct_thresh'.find(filter)!=-1)
        self.option_align_var_struct_thresh.setVisible(filter=='' or 'align_var_struct_thresh'.find(filter)!=-1)
        self.label_align_var_struct_gap.setVisible(filter=='' or 'align_var_struct_gap'.find(filter)!=-1)
        self.option_align_var_struct_gap.setVisible(filter=='' or 'align_var_struct_gap'.find(filter)!=-1)
        self.label_align_struct_init_span.setVisible(filter=='' or 'align_struct_init_span'.find(filter)!=-1)
        self.option_align_struct_init_span.setVisible(filter=='' or 'align_struct_init_span'.find(filter)!=-1)
        self.label_align_typedef_span.setVisible(filter=='' or 'align_typedef_span'.find(filter)!=-1)
        self.option_align_typedef_span.setVisible(filter=='' or 'align_typedef_span'.find(filter)!=-1)
        self.label_align_typedef_gap.setVisible(filter=='' or 'align_typedef_gap'.find(filter)!=-1)
        self.option_align_typedef_gap.setVisible(filter=='' or 'align_typedef_gap'.find(filter)!=-1)
        self.label_align_typedef_func.setVisible(filter=='' or 'align_typedef_func'.find(filter)!=-1)
        self.option_align_typedef_func.setVisible(filter=='' or 'align_typedef_func'.find(filter)!=-1)
        self.label_align_typedef_star_style.setVisible(filter=='' or 'align_typedef_star_style'.find(filter)!=-1)
        self.option_align_typedef_star_style.setVisible(filter=='' or 'align_typedef_star_style'.find(filter)!=-1)
        self.label_align_typedef_amp_style.setVisible(filter=='' or 'align_typedef_amp_style'.find(filter)!=-1)
        self.option_align_typedef_amp_style.setVisible(filter=='' or 'align_typedef_amp_style'.find(filter)!=-1)
        self.label_align_right_cmt_span.setVisible(filter=='' or 'align_right_cmt_span'.find(filter)!=-1)
        self.option_align_right_cmt_span.setVisible(filter=='' or 'align_right_cmt_span'.find(filter)!=-1)
        self.label_align_right_cmt_gap.setVisible(filter=='' or 'align_right_cmt_gap'.find(filter)!=-1)
        self.option_align_right_cmt_gap.setVisible(filter=='' or 'align_right_cmt_gap'.find(filter)!=-1)
        self.label_align_right_cmt_mix.setVisible(filter=='' or 'align_right_cmt_mix'.find(filter)!=-1)
        self.option_align_right_cmt_mix.setVisible(filter=='' or 'align_right_cmt_mix'.find(filter)!=-1)
        self.label_align_right_cmt_same_level.setVisible(filter=='' or 'align_right_cmt_same_level'.find(filter)!=-1)
        self.option_align_right_cmt_same_level.setVisible(filter=='' or 'align_right_cmt_same_level'.find(filter)!=-1)
        self.label_align_right_cmt_at_col.setVisible(filter=='' or 'align_right_cmt_at_col'.find(filter)!=-1)
        self.option_align_right_cmt_at_col.setVisible(filter=='' or 'align_right_cmt_at_col'.find(filter)!=-1)
        self.label_align_func_proto_span.setVisible(filter=='' or 'align_func_proto_span'.find(filter)!=-1)
        self.option_align_func_proto_span.setVisible(filter=='' or 'align_func_proto_span'.find(filter)!=-1)
        self.label_align_func_proto_span_ignore_cont_lines.setVisible(filter=='' or 'align_func_proto_span_ignore_cont_lines'.find(filter)!=-1)
        self.option_align_func_proto_span_ignore_cont_lines.setVisible(filter=='' or 'align_func_proto_span_ignore_cont_lines'.find(filter)!=-1)
        self.label_align_func_proto_star_style.setVisible(filter=='' or 'align_func_proto_star_style'.find(filter)!=-1)
        self.option_align_func_proto_star_style.setVisible(filter=='' or 'align_func_proto_star_style'.find(filter)!=-1)
        self.label_align_func_proto_amp_style.setVisible(filter=='' or 'align_func_proto_amp_style'.find(filter)!=-1)
        self.option_align_func_proto_amp_style.setVisible(filter=='' or 'align_func_proto_amp_style'.find(filter)!=-1)
        self.label_align_func_proto_thresh.setVisible(filter=='' or 'align_func_proto_thresh'.find(filter)!=-1)
        self.option_align_func_proto_thresh.setVisible(filter=='' or 'align_func_proto_thresh'.find(filter)!=-1)
        self.label_align_func_proto_gap.setVisible(filter=='' or 'align_func_proto_gap'.find(filter)!=-1)
        self.option_align_func_proto_gap.setVisible(filter=='' or 'align_func_proto_gap'.find(filter)!=-1)
        self.label_align_on_operator.setVisible(filter=='' or 'align_on_operator'.find(filter)!=-1)
        self.option_align_on_operator.setVisible(filter=='' or 'align_on_operator'.find(filter)!=-1)
        self.label_align_mix_var_proto.setVisible(filter=='' or 'align_mix_var_proto'.find(filter)!=-1)
        self.option_align_mix_var_proto.setVisible(filter=='' or 'align_mix_var_proto'.find(filter)!=-1)
        self.label_align_single_line_func.setVisible(filter=='' or 'align_single_line_func'.find(filter)!=-1)
        self.option_align_single_line_func.setVisible(filter=='' or 'align_single_line_func'.find(filter)!=-1)
        self.label_align_single_line_brace.setVisible(filter=='' or 'align_single_line_brace'.find(filter)!=-1)
        self.option_align_single_line_brace.setVisible(filter=='' or 'align_single_line_brace'.find(filter)!=-1)
        self.label_align_single_line_brace_gap.setVisible(filter=='' or 'align_single_line_brace_gap'.find(filter)!=-1)
        self.option_align_single_line_brace_gap.setVisible(filter=='' or 'align_single_line_brace_gap'.find(filter)!=-1)
        self.label_align_oc_msg_spec_span.setVisible(filter=='' or 'align_oc_msg_spec_span'.find(filter)!=-1)
        self.option_align_oc_msg_spec_span.setVisible(filter=='' or 'align_oc_msg_spec_span'.find(filter)!=-1)
        self.label_align_nl_cont.setVisible(filter=='' or 'align_nl_cont'.find(filter)!=-1)
        self.option_align_nl_cont.setVisible(filter=='' or 'align_nl_cont'.find(filter)!=-1)
        self.label_align_nl_cont_spaces.setVisible(filter=='' or 'align_nl_cont_spaces'.find(filter)!=-1)
        self.option_align_nl_cont_spaces.setVisible(filter=='' or 'align_nl_cont_spaces'.find(filter)!=-1)
        self.label_align_pp_define_together.setVisible(filter=='' or 'align_pp_define_together'.find(filter)!=-1)
        self.option_align_pp_define_together.setVisible(filter=='' or 'align_pp_define_together'.find(filter)!=-1)
        self.label_align_pp_define_span.setVisible(filter=='' or 'align_pp_define_span'.find(filter)!=-1)
        self.option_align_pp_define_span.setVisible(filter=='' or 'align_pp_define_span'.find(filter)!=-1)
        self.label_align_pp_define_gap.setVisible(filter=='' or 'align_pp_define_gap'.find(filter)!=-1)
        self.option_align_pp_define_gap.setVisible(filter=='' or 'align_pp_define_gap'.find(filter)!=-1)
        self.label_align_left_shift.setVisible(filter=='' or 'align_left_shift'.find(filter)!=-1)
        self.option_align_left_shift.setVisible(filter=='' or 'align_left_shift'.find(filter)!=-1)
        self.label_align_eigen_comma_init.setVisible(filter=='' or 'align_eigen_comma_init'.find(filter)!=-1)
        self.option_align_eigen_comma_init.setVisible(filter=='' or 'align_eigen_comma_init'.find(filter)!=-1)
        self.label_align_asm_colon.setVisible(filter=='' or 'align_asm_colon'.find(filter)!=-1)
        self.option_align_asm_colon.setVisible(filter=='' or 'align_asm_colon'.find(filter)!=-1)
        self.label_align_oc_msg_colon_span.setVisible(filter=='' or 'align_oc_msg_colon_span'.find(filter)!=-1)
        self.option_align_oc_msg_colon_span.setVisible(filter=='' or 'align_oc_msg_colon_span'.find(filter)!=-1)
        self.label_align_oc_msg_colon_first.setVisible(filter=='' or 'align_oc_msg_colon_first'.find(filter)!=-1)
        self.option_align_oc_msg_colon_first.setVisible(filter=='' or 'align_oc_msg_colon_first'.find(filter)!=-1)
        self.label_align_oc_decl_colon.setVisible(filter=='' or 'align_oc_decl_colon'.find(filter)!=-1)
        self.option_align_oc_decl_colon.setVisible(filter=='' or 'align_oc_decl_colon'.find(filter)!=-1)
        self.label_align_oc_msg_colon_xcode_like.setVisible(filter=='' or 'align_oc_msg_colon_xcode_like'.find(filter)!=-1)
        self.option_align_oc_msg_colon_xcode_like.setVisible(filter=='' or 'align_oc_msg_colon_xcode_like'.find(filter)!=-1)
        self.label_cmt_width.setVisible(filter=='' or 'cmt_width'.find(filter)!=-1)
        self.option_cmt_width.setVisible(filter=='' or 'cmt_width'.find(filter)!=-1)
        self.label_cmt_reflow_mode.setVisible(filter=='' or 'cmt_reflow_mode'.find(filter)!=-1)
        self.option_cmt_reflow_mode.setVisible(filter=='' or 'cmt_reflow_mode'.find(filter)!=-1)
        self.label_cmt_reflow_fold_regex_file.setVisible(filter=='' or 'cmt_reflow_fold_regex_file'.find(filter)!=-1)
        self.option_cmt_reflow_fold_regex_file.setVisible(filter=='' or 'cmt_reflow_fold_regex_file'.find(filter)!=-1)
        self.label_cmt_reflow_indent_to_paragraph_start.setVisible(filter=='' or 'cmt_reflow_indent_to_paragraph_start'.find(filter)!=-1)
        self.option_cmt_reflow_indent_to_paragraph_start.setVisible(filter=='' or 'cmt_reflow_indent_to_paragraph_start'.find(filter)!=-1)
        self.label_cmt_convert_tab_to_spaces.setVisible(filter=='' or 'cmt_convert_tab_to_spaces'.find(filter)!=-1)
        self.option_cmt_convert_tab_to_spaces.setVisible(filter=='' or 'cmt_convert_tab_to_spaces'.find(filter)!=-1)
        self.label_cmt_indent_multi.setVisible(filter=='' or 'cmt_indent_multi'.find(filter)!=-1)
        self.option_cmt_indent_multi.setVisible(filter=='' or 'cmt_indent_multi'.find(filter)!=-1)
        self.label_cmt_align_doxygen_javadoc_tags.setVisible(filter=='' or 'cmt_align_doxygen_javadoc_tags'.find(filter)!=-1)
        self.option_cmt_align_doxygen_javadoc_tags.setVisible(filter=='' or 'cmt_align_doxygen_javadoc_tags'.find(filter)!=-1)
        self.label_cmt_sp_before_doxygen_javadoc_tags.setVisible(filter=='' or 'cmt_sp_before_doxygen_javadoc_tags'.find(filter)!=-1)
        self.option_cmt_sp_before_doxygen_javadoc_tags.setVisible(filter=='' or 'cmt_sp_before_doxygen_javadoc_tags'.find(filter)!=-1)
        self.label_cmt_trailing_single_line_c_to_cpp.setVisible(filter=='' or 'cmt_trailing_single_line_c_to_cpp'.find(filter)!=-1)
        self.option_cmt_trailing_single_line_c_to_cpp.setVisible(filter=='' or 'cmt_trailing_single_line_c_to_cpp'.find(filter)!=-1)
        self.label_cmt_c_group.setVisible(filter=='' or 'cmt_c_group'.find(filter)!=-1)
        self.option_cmt_c_group.setVisible(filter=='' or 'cmt_c_group'.find(filter)!=-1)
        self.label_cmt_c_nl_start.setVisible(filter=='' or 'cmt_c_nl_start'.find(filter)!=-1)
        self.option_cmt_c_nl_start.setVisible(filter=='' or 'cmt_c_nl_start'.find(filter)!=-1)
        self.label_cmt_c_nl_end.setVisible(filter=='' or 'cmt_c_nl_end'.find(filter)!=-1)
        self.option_cmt_c_nl_end.setVisible(filter=='' or 'cmt_c_nl_end'.find(filter)!=-1)
        self.label_cmt_cpp_to_c.setVisible(filter=='' or 'cmt_cpp_to_c'.find(filter)!=-1)
        self.option_cmt_cpp_to_c.setVisible(filter=='' or 'cmt_cpp_to_c'.find(filter)!=-1)
        self.label_cmt_cpp_group.setVisible(filter=='' or 'cmt_cpp_group'.find(filter)!=-1)
        self.option_cmt_cpp_group.setVisible(filter=='' or 'cmt_cpp_group'.find(filter)!=-1)
        self.label_cmt_cpp_nl_start.setVisible(filter=='' or 'cmt_cpp_nl_start'.find(filter)!=-1)
        self.option_cmt_cpp_nl_start.setVisible(filter=='' or 'cmt_cpp_nl_start'.find(filter)!=-1)
        self.label_cmt_cpp_nl_end.setVisible(filter=='' or 'cmt_cpp_nl_end'.find(filter)!=-1)
        self.option_cmt_cpp_nl_end.setVisible(filter=='' or 'cmt_cpp_nl_end'.find(filter)!=-1)
        self.label_cmt_star_cont.setVisible(filter=='' or 'cmt_star_cont'.find(filter)!=-1)
        self.option_cmt_star_cont.setVisible(filter=='' or 'cmt_star_cont'.find(filter)!=-1)
        self.label_cmt_sp_before_star_cont.setVisible(filter=='' or 'cmt_sp_before_star_cont'.find(filter)!=-1)
        self.option_cmt_sp_before_star_cont.setVisible(filter=='' or 'cmt_sp_before_star_cont'.find(filter)!=-1)
        self.label_cmt_sp_after_star_cont.setVisible(filter=='' or 'cmt_sp_after_star_cont'.find(filter)!=-1)
        self.option_cmt_sp_after_star_cont.setVisible(filter=='' or 'cmt_sp_after_star_cont'.find(filter)!=-1)
        self.label_cmt_multi_check_last.setVisible(filter=='' or 'cmt_multi_check_last'.find(filter)!=-1)
        self.option_cmt_multi_check_last.setVisible(filter=='' or 'cmt_multi_check_last'.find(filter)!=-1)
        self.label_cmt_multi_first_len_minimum.setVisible(filter=='' or 'cmt_multi_first_len_minimum'.find(filter)!=-1)
        self.option_cmt_multi_first_len_minimum.setVisible(filter=='' or 'cmt_multi_first_len_minimum'.find(filter)!=-1)
        self.label_cmt_insert_file_header.setVisible(filter=='' or 'cmt_insert_file_header'.find(filter)!=-1)
        self.option_cmt_insert_file_header.setVisible(filter=='' or 'cmt_insert_file_header'.find(filter)!=-1)
        self.label_cmt_insert_file_footer.setVisible(filter=='' or 'cmt_insert_file_footer'.find(filter)!=-1)
        self.option_cmt_insert_file_footer.setVisible(filter=='' or 'cmt_insert_file_footer'.find(filter)!=-1)
        self.label_cmt_insert_func_header.setVisible(filter=='' or 'cmt_insert_func_header'.find(filter)!=-1)
        self.option_cmt_insert_func_header.setVisible(filter=='' or 'cmt_insert_func_header'.find(filter)!=-1)
        self.label_cmt_insert_class_header.setVisible(filter=='' or 'cmt_insert_class_header'.find(filter)!=-1)
        self.option_cmt_insert_class_header.setVisible(filter=='' or 'cmt_insert_class_header'.find(filter)!=-1)
        self.label_cmt_insert_oc_msg_header.setVisible(filter=='' or 'cmt_insert_oc_msg_header'.find(filter)!=-1)
        self.option_cmt_insert_oc_msg_header.setVisible(filter=='' or 'cmt_insert_oc_msg_header'.find(filter)!=-1)
        self.label_cmt_insert_before_preproc.setVisible(filter=='' or 'cmt_insert_before_preproc'.find(filter)!=-1)
        self.option_cmt_insert_before_preproc.setVisible(filter=='' or 'cmt_insert_before_preproc'.find(filter)!=-1)
        self.label_cmt_insert_before_inlines.setVisible(filter=='' or 'cmt_insert_before_inlines'.find(filter)!=-1)
        self.option_cmt_insert_before_inlines.setVisible(filter=='' or 'cmt_insert_before_inlines'.find(filter)!=-1)
        self.label_cmt_insert_before_ctor_dtor.setVisible(filter=='' or 'cmt_insert_before_ctor_dtor'.find(filter)!=-1)
        self.option_cmt_insert_before_ctor_dtor.setVisible(filter=='' or 'cmt_insert_before_ctor_dtor'.find(filter)!=-1)
        self.label_mod_full_brace_do.setVisible(filter=='' or 'mod_full_brace_do'.find(filter)!=-1)
        self.option_mod_full_brace_do.setVisible(filter=='' or 'mod_full_brace_do'.find(filter)!=-1)
        self.label_mod_full_brace_for.setVisible(filter=='' or 'mod_full_brace_for'.find(filter)!=-1)
        self.option_mod_full_brace_for.setVisible(filter=='' or 'mod_full_brace_for'.find(filter)!=-1)
        self.label_mod_full_brace_function.setVisible(filter=='' or 'mod_full_brace_function'.find(filter)!=-1)
        self.option_mod_full_brace_function.setVisible(filter=='' or 'mod_full_brace_function'.find(filter)!=-1)
        self.label_mod_full_brace_if.setVisible(filter=='' or 'mod_full_brace_if'.find(filter)!=-1)
        self.option_mod_full_brace_if.setVisible(filter=='' or 'mod_full_brace_if'.find(filter)!=-1)
        self.label_mod_full_brace_if_chain.setVisible(filter=='' or 'mod_full_brace_if_chain'.find(filter)!=-1)
        self.option_mod_full_brace_if_chain.setVisible(filter=='' or 'mod_full_brace_if_chain'.find(filter)!=-1)
        self.label_mod_full_brace_if_chain_only.setVisible(filter=='' or 'mod_full_brace_if_chain_only'.find(filter)!=-1)
        self.option_mod_full_brace_if_chain_only.setVisible(filter=='' or 'mod_full_brace_if_chain_only'.find(filter)!=-1)
        self.label_mod_full_brace_while.setVisible(filter=='' or 'mod_full_brace_while'.find(filter)!=-1)
        self.option_mod_full_brace_while.setVisible(filter=='' or 'mod_full_brace_while'.find(filter)!=-1)
        self.label_mod_full_brace_using.setVisible(filter=='' or 'mod_full_brace_using'.find(filter)!=-1)
        self.option_mod_full_brace_using.setVisible(filter=='' or 'mod_full_brace_using'.find(filter)!=-1)
        self.label_mod_full_brace_nl.setVisible(filter=='' or 'mod_full_brace_nl'.find(filter)!=-1)
        self.option_mod_full_brace_nl.setVisible(filter=='' or 'mod_full_brace_nl'.find(filter)!=-1)
        self.label_mod_full_brace_nl_block_rem_mlcond.setVisible(filter=='' or 'mod_full_brace_nl_block_rem_mlcond'.find(filter)!=-1)
        self.option_mod_full_brace_nl_block_rem_mlcond.setVisible(filter=='' or 'mod_full_brace_nl_block_rem_mlcond'.find(filter)!=-1)
        self.label_mod_paren_on_return.setVisible(filter=='' or 'mod_paren_on_return'.find(filter)!=-1)
        self.option_mod_paren_on_return.setVisible(filter=='' or 'mod_paren_on_return'.find(filter)!=-1)
        self.label_mod_paren_on_throw.setVisible(filter=='' or 'mod_paren_on_throw'.find(filter)!=-1)
        self.option_mod_paren_on_throw.setVisible(filter=='' or 'mod_paren_on_throw'.find(filter)!=-1)
        self.label_mod_pawn_semicolon.setVisible(filter=='' or 'mod_pawn_semicolon'.find(filter)!=-1)
        self.option_mod_pawn_semicolon.setVisible(filter=='' or 'mod_pawn_semicolon'.find(filter)!=-1)
        self.label_mod_full_paren_if_bool.setVisible(filter=='' or 'mod_full_paren_if_bool'.find(filter)!=-1)
        self.option_mod_full_paren_if_bool.setVisible(filter=='' or 'mod_full_paren_if_bool'.find(filter)!=-1)
        self.label_mod_full_paren_assign_bool.setVisible(filter=='' or 'mod_full_paren_assign_bool'.find(filter)!=-1)
        self.option_mod_full_paren_assign_bool.setVisible(filter=='' or 'mod_full_paren_assign_bool'.find(filter)!=-1)
        self.label_mod_full_paren_return_bool.setVisible(filter=='' or 'mod_full_paren_return_bool'.find(filter)!=-1)
        self.option_mod_full_paren_return_bool.setVisible(filter=='' or 'mod_full_paren_return_bool'.find(filter)!=-1)
        self.label_mod_remove_extra_semicolon.setVisible(filter=='' or 'mod_remove_extra_semicolon'.find(filter)!=-1)
        self.option_mod_remove_extra_semicolon.setVisible(filter=='' or 'mod_remove_extra_semicolon'.find(filter)!=-1)
        self.label_mod_remove_duplicate_include.setVisible(filter=='' or 'mod_remove_duplicate_include'.find(filter)!=-1)
        self.option_mod_remove_duplicate_include.setVisible(filter=='' or 'mod_remove_duplicate_include'.find(filter)!=-1)
        self.label_mod_add_force_c_closebrace_comment.setVisible(filter=='' or 'mod_add_force_c_closebrace_comment'.find(filter)!=-1)
        self.option_mod_add_force_c_closebrace_comment.setVisible(filter=='' or 'mod_add_force_c_closebrace_comment'.find(filter)!=-1)
        self.label_mod_add_long_function_closebrace_comment.setVisible(filter=='' or 'mod_add_long_function_closebrace_comment'.find(filter)!=-1)
        self.option_mod_add_long_function_closebrace_comment.setVisible(filter=='' or 'mod_add_long_function_closebrace_comment'.find(filter)!=-1)
        self.label_mod_add_long_namespace_closebrace_comment.setVisible(filter=='' or 'mod_add_long_namespace_closebrace_comment'.find(filter)!=-1)
        self.option_mod_add_long_namespace_closebrace_comment.setVisible(filter=='' or 'mod_add_long_namespace_closebrace_comment'.find(filter)!=-1)
        self.label_mod_add_long_class_closebrace_comment.setVisible(filter=='' or 'mod_add_long_class_closebrace_comment'.find(filter)!=-1)
        self.option_mod_add_long_class_closebrace_comment.setVisible(filter=='' or 'mod_add_long_class_closebrace_comment'.find(filter)!=-1)
        self.label_mod_add_long_switch_closebrace_comment.setVisible(filter=='' or 'mod_add_long_switch_closebrace_comment'.find(filter)!=-1)
        self.option_mod_add_long_switch_closebrace_comment.setVisible(filter=='' or 'mod_add_long_switch_closebrace_comment'.find(filter)!=-1)
        self.label_mod_add_long_ifdef_endif_comment.setVisible(filter=='' or 'mod_add_long_ifdef_endif_comment'.find(filter)!=-1)
        self.option_mod_add_long_ifdef_endif_comment.setVisible(filter=='' or 'mod_add_long_ifdef_endif_comment'.find(filter)!=-1)
        self.label_mod_add_long_ifdef_else_comment.setVisible(filter=='' or 'mod_add_long_ifdef_else_comment'.find(filter)!=-1)
        self.option_mod_add_long_ifdef_else_comment.setVisible(filter=='' or 'mod_add_long_ifdef_else_comment'.find(filter)!=-1)
        self.label_mod_sort_case_sensitive.setVisible(filter=='' or 'mod_sort_case_sensitive'.find(filter)!=-1)
        self.option_mod_sort_case_sensitive.setVisible(filter=='' or 'mod_sort_case_sensitive'.find(filter)!=-1)
        self.label_mod_sort_import.setVisible(filter=='' or 'mod_sort_import'.find(filter)!=-1)
        self.option_mod_sort_import.setVisible(filter=='' or 'mod_sort_import'.find(filter)!=-1)
        self.label_mod_sort_using.setVisible(filter=='' or 'mod_sort_using'.find(filter)!=-1)
        self.option_mod_sort_using.setVisible(filter=='' or 'mod_sort_using'.find(filter)!=-1)
        self.label_mod_sort_include.setVisible(filter=='' or 'mod_sort_include'.find(filter)!=-1)
        self.option_mod_sort_include.setVisible(filter=='' or 'mod_sort_include'.find(filter)!=-1)
        self.label_mod_sort_incl_import_prioritize_filename.setVisible(filter=='' or 'mod_sort_incl_import_prioritize_filename'.find(filter)!=-1)
        self.option_mod_sort_incl_import_prioritize_filename.setVisible(filter=='' or 'mod_sort_incl_import_prioritize_filename'.find(filter)!=-1)
        self.label_mod_sort_incl_import_prioritize_extensionless.setVisible(filter=='' or 'mod_sort_incl_import_prioritize_extensionless'.find(filter)!=-1)
        self.option_mod_sort_incl_import_prioritize_extensionless.setVisible(filter=='' or 'mod_sort_incl_import_prioritize_extensionless'.find(filter)!=-1)
        self.label_mod_sort_incl_import_prioritize_angle_over_quotes.setVisible(filter=='' or 'mod_sort_incl_import_prioritize_angle_over_quotes'.find(filter)!=-1)
        self.option_mod_sort_incl_import_prioritize_angle_over_quotes.setVisible(filter=='' or 'mod_sort_incl_import_prioritize_angle_over_quotes'.find(filter)!=-1)
        self.label_mod_sort_incl_import_ignore_extension.setVisible(filter=='' or 'mod_sort_incl_import_ignore_extension'.find(filter)!=-1)
        self.option_mod_sort_incl_import_ignore_extension.setVisible(filter=='' or 'mod_sort_incl_import_ignore_extension'.find(filter)!=-1)
        self.label_mod_sort_incl_import_grouping_enabled.setVisible(filter=='' or 'mod_sort_incl_import_grouping_enabled'.find(filter)!=-1)
        self.option_mod_sort_incl_import_grouping_enabled.setVisible(filter=='' or 'mod_sort_incl_import_grouping_enabled'.find(filter)!=-1)
        self.label_mod_move_case_break.setVisible(filter=='' or 'mod_move_case_break'.find(filter)!=-1)
        self.option_mod_move_case_break.setVisible(filter=='' or 'mod_move_case_break'.find(filter)!=-1)
        self.label_mod_move_case_return.setVisible(filter=='' or 'mod_move_case_return'.find(filter)!=-1)
        self.option_mod_move_case_return.setVisible(filter=='' or 'mod_move_case_return'.find(filter)!=-1)
        self.label_mod_case_brace.setVisible(filter=='' or 'mod_case_brace'.find(filter)!=-1)
        self.option_mod_case_brace.setVisible(filter=='' or 'mod_case_brace'.find(filter)!=-1)
        self.label_mod_remove_empty_return.setVisible(filter=='' or 'mod_remove_empty_return'.find(filter)!=-1)
        self.option_mod_remove_empty_return.setVisible(filter=='' or 'mod_remove_empty_return'.find(filter)!=-1)
        self.label_mod_enum_last_comma.setVisible(filter=='' or 'mod_enum_last_comma'.find(filter)!=-1)
        self.option_mod_enum_last_comma.setVisible(filter=='' or 'mod_enum_last_comma'.find(filter)!=-1)
        self.label_mod_infinite_loop.setVisible(filter=='' or 'mod_infinite_loop'.find(filter)!=-1)
        self.option_mod_infinite_loop.setVisible(filter=='' or 'mod_infinite_loop'.find(filter)!=-1)
        self.label_mod_int_short.setVisible(filter=='' or 'mod_int_short'.find(filter)!=-1)
        self.option_mod_int_short.setVisible(filter=='' or 'mod_int_short'.find(filter)!=-1)
        self.label_mod_short_int.setVisible(filter=='' or 'mod_short_int'.find(filter)!=-1)
        self.option_mod_short_int.setVisible(filter=='' or 'mod_short_int'.find(filter)!=-1)
        self.label_mod_int_long.setVisible(filter=='' or 'mod_int_long'.find(filter)!=-1)
        self.option_mod_int_long.setVisible(filter=='' or 'mod_int_long'.find(filter)!=-1)
        self.label_mod_long_int.setVisible(filter=='' or 'mod_long_int'.find(filter)!=-1)
        self.option_mod_long_int.setVisible(filter=='' or 'mod_long_int'.find(filter)!=-1)
        self.label_mod_int_signed.setVisible(filter=='' or 'mod_int_signed'.find(filter)!=-1)
        self.option_mod_int_signed.setVisible(filter=='' or 'mod_int_signed'.find(filter)!=-1)
        self.label_mod_signed_int.setVisible(filter=='' or 'mod_signed_int'.find(filter)!=-1)
        self.option_mod_signed_int.setVisible(filter=='' or 'mod_signed_int'.find(filter)!=-1)
        self.label_mod_int_unsigned.setVisible(filter=='' or 'mod_int_unsigned'.find(filter)!=-1)
        self.option_mod_int_unsigned.setVisible(filter=='' or 'mod_int_unsigned'.find(filter)!=-1)
        self.label_mod_unsigned_int.setVisible(filter=='' or 'mod_unsigned_int'.find(filter)!=-1)
        self.option_mod_unsigned_int.setVisible(filter=='' or 'mod_unsigned_int'.find(filter)!=-1)
        self.label_mod_int_prefer_int_on_left.setVisible(filter=='' or 'mod_int_prefer_int_on_left'.find(filter)!=-1)
        self.option_mod_int_prefer_int_on_left.setVisible(filter=='' or 'mod_int_prefer_int_on_left'.find(filter)!=-1)
        self.label_mod_sort_oc_properties.setVisible(filter=='' or 'mod_sort_oc_properties'.find(filter)!=-1)
        self.option_mod_sort_oc_properties.setVisible(filter=='' or 'mod_sort_oc_properties'.find(filter)!=-1)
        self.label_mod_sort_oc_property_class_weight.setVisible(filter=='' or 'mod_sort_oc_property_class_weight'.find(filter)!=-1)
        self.option_mod_sort_oc_property_class_weight.setVisible(filter=='' or 'mod_sort_oc_property_class_weight'.find(filter)!=-1)
        self.label_mod_sort_oc_property_thread_safe_weight.setVisible(filter=='' or 'mod_sort_oc_property_thread_safe_weight'.find(filter)!=-1)
        self.option_mod_sort_oc_property_thread_safe_weight.setVisible(filter=='' or 'mod_sort_oc_property_thread_safe_weight'.find(filter)!=-1)
        self.label_mod_sort_oc_property_readwrite_weight.setVisible(filter=='' or 'mod_sort_oc_property_readwrite_weight'.find(filter)!=-1)
        self.option_mod_sort_oc_property_readwrite_weight.setVisible(filter=='' or 'mod_sort_oc_property_readwrite_weight'.find(filter)!=-1)
        self.label_mod_sort_oc_property_reference_weight.setVisible(filter=='' or 'mod_sort_oc_property_reference_weight'.find(filter)!=-1)
        self.option_mod_sort_oc_property_reference_weight.setVisible(filter=='' or 'mod_sort_oc_property_reference_weight'.find(filter)!=-1)
        self.label_mod_sort_oc_property_getter_weight.setVisible(filter=='' or 'mod_sort_oc_property_getter_weight'.find(filter)!=-1)
        self.option_mod_sort_oc_property_getter_weight.setVisible(filter=='' or 'mod_sort_oc_property_getter_weight'.find(filter)!=-1)
        self.label_mod_sort_oc_property_setter_weight.setVisible(filter=='' or 'mod_sort_oc_property_setter_weight'.find(filter)!=-1)
        self.option_mod_sort_oc_property_setter_weight.setVisible(filter=='' or 'mod_sort_oc_property_setter_weight'.find(filter)!=-1)
        self.label_mod_sort_oc_property_nullability_weight.setVisible(filter=='' or 'mod_sort_oc_property_nullability_weight'.find(filter)!=-1)
        self.option_mod_sort_oc_property_nullability_weight.setVisible(filter=='' or 'mod_sort_oc_property_nullability_weight'.find(filter)!=-1)
        self.label_pp_indent_with_tabs.setVisible(filter=='' or 'pp_indent_with_tabs'.find(filter)!=-1)
        self.option_pp_indent_with_tabs.setVisible(filter=='' or 'pp_indent_with_tabs'.find(filter)!=-1)
        self.label_pp_indent.setVisible(filter=='' or 'pp_indent'.find(filter)!=-1)
        self.option_pp_indent.setVisible(filter=='' or 'pp_indent'.find(filter)!=-1)
        self.label_pp_indent_at_level.setVisible(filter=='' or 'pp_indent_at_level'.find(filter)!=-1)
        self.option_pp_indent_at_level.setVisible(filter=='' or 'pp_indent_at_level'.find(filter)!=-1)
        self.label_pp_indent_at_level0.setVisible(filter=='' or 'pp_indent_at_level0'.find(filter)!=-1)
        self.option_pp_indent_at_level0.setVisible(filter=='' or 'pp_indent_at_level0'.find(filter)!=-1)
        self.label_pp_indent_count.setVisible(filter=='' or 'pp_indent_count'.find(filter)!=-1)
        self.option_pp_indent_count.setVisible(filter=='' or 'pp_indent_count'.find(filter)!=-1)
        self.label_pp_space_after.setVisible(filter=='' or 'pp_space_after'.find(filter)!=-1)
        self.option_pp_space_after.setVisible(filter=='' or 'pp_space_after'.find(filter)!=-1)
        self.label_pp_space_count.setVisible(filter=='' or 'pp_space_count'.find(filter)!=-1)
        self.option_pp_space_count.setVisible(filter=='' or 'pp_space_count'.find(filter)!=-1)
        self.label_pp_indent_region.setVisible(filter=='' or 'pp_indent_region'.find(filter)!=-1)
        self.option_pp_indent_region.setVisible(filter=='' or 'pp_indent_region'.find(filter)!=-1)
        self.label_pp_region_indent_code.setVisible(filter=='' or 'pp_region_indent_code'.find(filter)!=-1)
        self.option_pp_region_indent_code.setVisible(filter=='' or 'pp_region_indent_code'.find(filter)!=-1)
        self.label_pp_indent_if.setVisible(filter=='' or 'pp_indent_if'.find(filter)!=-1)
        self.option_pp_indent_if.setVisible(filter=='' or 'pp_indent_if'.find(filter)!=-1)
        self.label_pp_if_indent_code.setVisible(filter=='' or 'pp_if_indent_code'.find(filter)!=-1)
        self.option_pp_if_indent_code.setVisible(filter=='' or 'pp_if_indent_code'.find(filter)!=-1)
        self.label_pp_indent_in_guard.setVisible(filter=='' or 'pp_indent_in_guard'.find(filter)!=-1)
        self.option_pp_indent_in_guard.setVisible(filter=='' or 'pp_indent_in_guard'.find(filter)!=-1)
        self.label_pp_define_at_level.setVisible(filter=='' or 'pp_define_at_level'.find(filter)!=-1)
        self.option_pp_define_at_level.setVisible(filter=='' or 'pp_define_at_level'.find(filter)!=-1)
        self.label_pp_include_at_level.setVisible(filter=='' or 'pp_include_at_level'.find(filter)!=-1)
        self.option_pp_include_at_level.setVisible(filter=='' or 'pp_include_at_level'.find(filter)!=-1)
        self.label_pp_ignore_define_body.setVisible(filter=='' or 'pp_ignore_define_body'.find(filter)!=-1)
        self.option_pp_ignore_define_body.setVisible(filter=='' or 'pp_ignore_define_body'.find(filter)!=-1)
        self.label_pp_multiline_define_body_indent.setVisible(filter=='' or 'pp_multiline_define_body_indent'.find(filter)!=-1)
        self.option_pp_multiline_define_body_indent.setVisible(filter=='' or 'pp_multiline_define_body_indent'.find(filter)!=-1)
        self.label_pp_indent_case.setVisible(filter=='' or 'pp_indent_case'.find(filter)!=-1)
        self.option_pp_indent_case.setVisible(filter=='' or 'pp_indent_case'.find(filter)!=-1)
        self.label_pp_indent_func_def.setVisible(filter=='' or 'pp_indent_func_def'.find(filter)!=-1)
        self.option_pp_indent_func_def.setVisible(filter=='' or 'pp_indent_func_def'.find(filter)!=-1)
        self.label_pp_indent_extern.setVisible(filter=='' or 'pp_indent_extern'.find(filter)!=-1)
        self.option_pp_indent_extern.setVisible(filter=='' or 'pp_indent_extern'.find(filter)!=-1)
        self.label_pp_indent_brace.setVisible(filter=='' or 'pp_indent_brace'.find(filter)!=-1)
        self.option_pp_indent_brace.setVisible(filter=='' or 'pp_indent_brace'.find(filter)!=-1)
        self.label_pp_unbalanced_if_action.setVisible(filter=='' or 'pp_unbalanced_if_action'.find(filter)!=-1)
        self.option_pp_unbalanced_if_action.setVisible(filter=='' or 'pp_unbalanced_if_action'.find(filter)!=-1)
        self.label_include_category_0.setVisible(filter=='' or 'include_category_0'.find(filter)!=-1)
        self.option_include_category_0.setVisible(filter=='' or 'include_category_0'.find(filter)!=-1)
        self.label_include_category_1.setVisible(filter=='' or 'include_category_1'.find(filter)!=-1)
        self.option_include_category_1.setVisible(filter=='' or 'include_category_1'.find(filter)!=-1)
        self.label_include_category_2.setVisible(filter=='' or 'include_category_2'.find(filter)!=-1)
        self.option_include_category_2.setVisible(filter=='' or 'include_category_2'.find(filter)!=-1)
        self.label_use_indent_func_call_param.setVisible(filter=='' or 'use_indent_func_call_param'.find(filter)!=-1)
        self.option_use_indent_func_call_param.setVisible(filter=='' or 'use_indent_func_call_param'.find(filter)!=-1)
        self.label_use_indent_continue_only_once.setVisible(filter=='' or 'use_indent_continue_only_once'.find(filter)!=-1)
        self.option_use_indent_continue_only_once.setVisible(filter=='' or 'use_indent_continue_only_once'.find(filter)!=-1)
        self.label_indent_cpp_lambda_only_once.setVisible(filter=='' or 'indent_cpp_lambda_only_once'.find(filter)!=-1)
        self.option_indent_cpp_lambda_only_once.setVisible(filter=='' or 'indent_cpp_lambda_only_once'.find(filter)!=-1)
        self.label_use_sp_after_angle_always.setVisible(filter=='' or 'use_sp_after_angle_always'.find(filter)!=-1)
        self.option_use_sp_after_angle_always.setVisible(filter=='' or 'use_sp_after_angle_always'.find(filter)!=-1)
        self.label_use_options_overriding_for_qt_macros.setVisible(filter=='' or 'use_options_overriding_for_qt_macros'.find(filter)!=-1)
        self.option_use_options_overriding_for_qt_macros.setVisible(filter=='' or 'use_options_overriding_for_qt_macros'.find(filter)!=-1)
        self.label_use_form_feed_no_more_as_whitespace_character.setVisible(filter=='' or 'use_form_feed_no_more_as_whitespace_character'.find(filter)!=-1)
        self.option_use_form_feed_no_more_as_whitespace_character.setVisible(filter=='' or 'use_form_feed_no_more_as_whitespace_character'.find(filter)!=-1)
        self.label_warn_level_tabs_found_in_verbatim_string_literals.setVisible(filter=='' or 'warn_level_tabs_found_in_verbatim_string_literals'.find(filter)!=-1)
        self.option_warn_level_tabs_found_in_verbatim_string_literals.setVisible(filter=='' or 'warn_level_tabs_found_in_verbatim_string_literals'.find(filter)!=-1)
        self.label_debug_max_number_of_loops.setVisible(filter=='' or 'debug_max_number_of_loops'.find(filter)!=-1)
        self.option_debug_max_number_of_loops.setVisible(filter=='' or 'debug_max_number_of_loops'.find(filter)!=-1)
        self.label_debug_line_number_to_protocol.setVisible(filter=='' or 'debug_line_number_to_protocol'.find(filter)!=-1)
        self.option_debug_line_number_to_protocol.setVisible(filter=='' or 'debug_line_number_to_protocol'.find(filter)!=-1)
        self.label_debug_timeout.setVisible(filter=='' or 'debug_timeout'.find(filter)!=-1)
        self.option_debug_timeout.setVisible(filter=='' or 'debug_timeout'.find(filter)!=-1)
        self.label_debug_truncate.setVisible(filter=='' or 'debug_truncate'.find(filter)!=-1)
        self.option_debug_truncate.setVisible(filter=='' or 'debug_truncate'.find(filter)!=-1)
        self.label_debug_sort_the_tracks.setVisible(filter=='' or 'debug_sort_the_tracks'.find(filter)!=-1)
        self.option_debug_sort_the_tracks.setVisible(filter=='' or 'debug_sort_the_tracks'.find(filter)!=-1)
        self.label_debug_decode_the_flags.setVisible(filter=='' or 'debug_decode_the_flags'.find(filter)!=-1)
        self.option_debug_decode_the_flags.setVisible(filter=='' or 'debug_decode_the_flags'.find(filter)!=-1)
        self.label_debug_use_the_exit_function_pop.setVisible(filter=='' or 'debug_use_the_exit_function_pop'.find(filter)!=-1)
        self.option_debug_use_the_exit_function_pop.setVisible(filter=='' or 'debug_use_the_exit_function_pop'.find(filter)!=-1)
        self.label_debug_print_version.setVisible(filter=='' or 'debug_print_version'.find(filter)!=-1)
        self.option_debug_print_version.setVisible(filter=='' or 'debug_print_version'.find(filter)!=-1)
        self.label_set_numbering_for_html_output.setVisible(filter=='' or 'set_numbering_for_html_output'.find(filter)!=-1)
        self.option_set_numbering_for_html_output.setVisible(filter=='' or 'set_numbering_for_html_output'.find(filter)!=-1)